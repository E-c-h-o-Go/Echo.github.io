<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Posts on _Echo_</title>
		<link>http://echoblog.cc/posts/</link>
		<description>Recent content in Posts on _Echo_</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>zh-cn</language>
		<copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
		<lastBuildDate>Wed, 27 Jan 2021 00:00:00 +0000</lastBuildDate>
		<atom:link href="http://echoblog.cc/posts/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>「Golang」 Map源码解析</title>
			<link>http://echoblog.cc/posts/golangmap%E8%A7%A3%E6%9E%90/</link>
			<pubDate>Wed, 27 Jan 2021 00:00:00 +0000</pubDate>
			
			<guid>http://echoblog.cc/posts/golangmap%E8%A7%A3%E6%9E%90/</guid>
			<description>[TOC]
Map Map通常称哈希表（Hash Table）、散列表等，是根据键（Key）而直接访问在内存储存位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做散列函数，存放记录的数组称做桶。哈希表是计算机科学中的最重要数据结构之一，这不仅因为它 𝑂(1) 的读写性能非常优秀，还因为它提供了键值之间的映射。想要实现一个性能优异的哈希表，需要注意两个关键点 —— 哈希函数和冲突解决方法。哈希表的实现主要需要解决两个问题，哈希函数和冲突解决。
在很多编程语言中都有哈希表的相关库的提供，比如C++，Java等，均在语言内部标准库中实现了哈希表相关数据结构的使用方式，而在Go语言中，哈希表则是一个内嵌类型。
哈希表设计及哈希碰撞解决方式 哈希函数 在哈希表实现过程中，哈希函数是一个很重要的部分，哈希函数选择的好坏很大程度的影响哈希表整体性能的好坏，实际上，哈希表是一个表结构，其在读写时，可以通过使用哈希函数对传入的Key进行哈希计算得出其哈希值，能够将不同Key映射到不同的索引上，一般来说，存储表结构的数据结构通常使用数组来做存储某些Key的哈希值对应的Value，通常存储这些Value的数组的每个位置，我们通常称其为桶。
较为理想的哈希函数实现的哈希表，对其任意元素的查找速度始终为𝑂(1) 。因为其每个Key所映射到的桶都是唯一的，即每个Key都有不同的桶的位置，但是这种情况非常难以实现因为，这要求哈希函数的输出范围大于输入范围，但是由于键的数量会远远大于映射的范围，所以在实际使用时，这个理想的效果是不可能实现的。
那么当两个不同的Key经过哈希函数计算后所得到的桶的位置是相同的时候，就产生了哈希碰撞，要注意的是，两个不同的Key产生哈希碰撞不代表两个Key的哈希值完全相同，有可能只是部分相同，比如高X位或者低X位。
哈希碰撞 当产生哈希碰撞时，该如何解决呢？目前比较常见的就是开放地址法和链表法，接下来我们简要的了解一下这两种哈希冲突的解决办法。
开放地址法 开放地址法的基本思想是：当发生哈希碰撞时，按照某种方法继续探测哈希表中的其他存储单元，直到找到空位置为止。这个过程可用以下过程描述：
 首先注明，哈希函数计算哈希索引的公式假若为： $$ index=HashFunction(Key) % Len(Bucket) $$ 其中HashFunction(Key)为求出当前Key的哈希值，然后对当前桶的总数求余
  发现发生哈希碰撞，此时计算出的index=1（只是举例） 此时发现index=1处有Value存储，则探测index+1处也就是index=2处 如果index=2处仍然有Value存储则继续往后探测，直到找到某个桶中不存在Value（写）或者找到目标元素（读）时或到桶的长度时结束  有上述过程可以看出，当哈希表越来越满时聚集越来越严重，这导致产生非常长的探测长度，后续的数据插入将会非常费时。
 开放地址法对性能影响最大的是装载因子，它是数组中元素的数量与数组大小的比值。随着装载因子的增加，线性探测的平均用时就会逐渐增加，这会影响哈希表的读写性能。当装载率超过 70% 之后，哈希表的性能就会急剧下降，而一旦装载率达到 100%，整个哈希表就会完全失效，这时查找和插入任意元素的时间复杂度都是 𝑂(𝑛)的，这时需要遍历数组中的全部元素，所以在实现哈希表时一定要关注装载因子的变化。
 链表法 链表法的基本思想是：当发生哈希碰撞时，将该Key与其hash值相同的Key链接在同一个单链表中，因为一般来说这个链表的长度并不会太长（比如Go中这个链表长度取8），所以查询仍然可以按照𝑂(1)时间计算，链表法有一个很重要的变量，即装载因子 这个装载因子的大小会影响链表的性能，因此，当装载因子达到一定程度的时候就需要进行哈希表的扩容，装载因子的求出公式为： $$ 装载因子=哈希表总元素数量 ➗ 哈希表桶的数量 $$
Go中的Map 概述 Map是一种方便而强大的内置数据结构，它将一种类型的Key（键）与另一种类型的Value（元素或值）关联起来。Key可以是任何可以进行比较的类型，如整数、浮点和复数、字符串、指针、interface{}（但是前提是interface中的数据类型也必须是可以比较的）、结构和数组。和切片一样，Map 也持有对底层数据结构的引用。如果你把一个Map传给一个函数，该函数改变了Map的内容，那么这些改变将在调用者中可见。
数据结构 Map在Go中是按照一种内置数据结构的形式出现，在使用的时候只需要像使用切片那样即可：
func main() { a := make(map[string]string,10) a[&amp;#34;test&amp;#34;]=&amp;#34;test&amp;#34; } 同时跟切片一样Map在Go语言底层也是一种结构体的实现，现在来看一下Map在Go中最底层的结构体样式以及相关字段功能：
type hmap struct { // 当前map中元素数量 即len(map)返回的值。 	count int // 当前map所处状态标记，比如正在写入正在迭代等。 	flags uint8 // 桶的数量的值，最终map创建的桶的数量为 2^B  // 另外在使用Key的哈希值选桶的时候  // 取的是该哈希值的低B位作为选桶的值 	B uint8 // 当前溢出桶的数量 	noverflow uint16 // hash种子，在创建该结构体的时候动态生成 	hash0 uint32 // 指向第一个桶的指针 是一个连续的地址 因为是个数组  // 这里面存的是 *bmap 	buckets unsafe.</description>
			<content type="html"><![CDATA[<p>[TOC]</p>
<h2 id="map">Map</h2>
<p>Map通常称哈希表（Hash Table）、散列表等，是根据键（Key）而直接访问在内存储存位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做散列函数，存放记录的数组称做<strong>桶</strong>。哈希表是计算机科学中的最重要数据结构之一，这不仅因为它 𝑂(1) 的读写性能非常优秀，还因为它提供了键值之间的映射。想要实现一个性能优异的哈希表，需要注意两个关键点 —— 哈希函数和冲突解决方法。哈希表的实现主要需要解决两个问题，哈希函数和冲突解决。</p>
<p>在很多编程语言中都有哈希表的相关库的提供，比如C++，Java等，均在语言内部标准库中实现了哈希表相关数据结构的使用方式，而在Go语言中，哈希表则是一个内嵌类型。</p>
<h2 id="哈希表设计及哈希碰撞解决方式">哈希表设计及哈希碰撞解决方式</h2>
<h3 id="哈希函数">哈希函数</h3>
<p>在哈希表实现过程中，哈希函数是一个很重要的部分，哈希函数选择的好坏很大程度的影响哈希表整体性能的好坏，实际上，哈希表是一个表结构，其在读写时，可以通过使用哈希函数对传入的Key进行哈希计算得出其哈希值，能够将不同Key映射到不同的索引上，一般来说，存储表结构的数据结构通常使用数组来做存储某些Key的哈希值对应的Value，通常存储这些Value的数组的每个位置，我们通常称其为<strong>桶</strong>。</p>
<p>较为理想的哈希函数实现的哈希表，对其任意元素的查找速度始终为𝑂(1) 。因为其每个Key所映射到的桶都是唯一的，即每个Key都有不同的桶的位置，但是这种情况非常难以实现因为，这要求哈希函数的输出范围大于输入范围，但是由于键的数量会远远大于映射的范围，所以在实际使用时，这个理想的效果是不可能实现的。</p>
<p>那么当两个不同的Key经过哈希函数计算后所得到的桶的位置是相同的时候，就产生了哈希碰撞，要注意的是，两个不同的Key产生哈希碰撞不代表两个Key的哈希值完全相同，有可能只是部分相同，比如高X位或者低X位。</p>
<h3 id="哈希碰撞">哈希碰撞</h3>
<p>当产生哈希碰撞时，该如何解决呢？目前比较常见的就是开放地址法和链表法，接下来我们简要的了解一下这两种哈希冲突的解决办法。</p>
<h4 id="开放地址法">开放地址法</h4>
<p>开放地址法的基本思想是：当发生哈希碰撞时，按照某种方法继续探测哈希表中的其他存储单元，直到找到空位置为止。这个过程可用以下过程描述：</p>
<blockquote>
<p>首先注明，哈希函数计算哈希索引的公式假若为：
$$
index=HashFunction(Key) % Len(Bucket)
$$
其中HashFunction(Key)为求出当前Key的哈希值，然后对当前桶的总数求余</p>
</blockquote>
<ol>
<li>发现发生哈希碰撞，此时计算出的index=1（只是举例）</li>
<li>此时发现index=1处有Value存储，则探测index+1处也就是index=2处</li>
<li>如果index=2处仍然有Value存储则继续往后探测，直到找到某个桶中不存在Value（写）或者找到目标元素（读）时或到桶的长度时结束</li>
</ol>
<p>有上述过程可以看出，当哈希表越来越满时聚集越来越严重，这导致产生非常长的探测长度，后续的数据插入将会非常费时。</p>
<blockquote>
<p>开放地址法对性能影响最大的是装载因子，它是数组中元素的数量与数组大小的比值。随着装载因子的增加，线性探测的平均用时就会逐渐增加，这会影响哈希表的读写性能。当装载率超过 70% 之后，哈希表的性能就会急剧下降，而一旦装载率达到 100%，整个哈希表就会完全失效，这时查找和插入任意元素的时间复杂度都是 𝑂(𝑛)的，这时需要遍历数组中的全部元素，所以在实现哈希表时一定要关注装载因子的变化。</p>
</blockquote>
<h4 id="链表法">链表法</h4>
<p>链表法的基本思想是：当发生哈希碰撞时，将该Key与其hash值相同的Key链接在同一个单链表中，因为一般来说这个链表的长度并不会太长（比如Go中这个链表长度取8），所以查询仍然可以按照𝑂(1)时间计算，链表法有一个很重要的变量，即<strong>装载因子</strong> 这个装载因子的大小会影响链表的性能，因此，当装载因子达到一定程度的时候就需要进行哈希表的扩容，装载因子的求出公式为：
$$
装载因子=哈希表总元素数量 ➗ 哈希表桶的数量
$$</p>
<h2 id="go中的map">Go中的Map</h2>
<h3 id="概述">概述</h3>
<p>Map是一种方便而强大的内置数据结构，它将一种类型的Key（键）与另一种类型的Value（元素或值）关联起来。Key可以是任何可以进行比较的类型，如整数、浮点和复数、字符串、指针、interface{}（但是前提是interface中的数据类型也必须是可以比较的）、结构和数组。和切片一样，Map 也持有对底层数据结构的引用。如果你把一个Map传给一个函数，该函数改变了Map的内容，那么这些改变将在调用者中可见。</p>
<h3 id="数据结构">数据结构</h3>
<p>Map在Go中是按照一种内置数据结构的形式出现，在使用的时候只需要像使用切片那样即可：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">a</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span>
	<span class="nx">a</span><span class="p">[</span><span class="s">&#34;test&#34;</span><span class="p">]=</span><span class="s">&#34;test&#34;</span>
<span class="p">}</span>
</code></pre></div><p>同时跟切片一样Map在Go语言底层也是一种结构体的实现，现在来看一下Map在Go中最底层的结构体样式以及相关字段功能：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">hmap</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="c1">// 当前map中元素数量 即len(map)返回的值。
</span><span class="c1"></span>	<span class="nx">count</span>     <span class="kt">int</span> 
  <span class="c1">// 当前map所处状态标记，比如正在写入正在迭代等。
</span><span class="c1"></span>	<span class="nx">flags</span>     <span class="kt">uint8</span>
  <span class="c1">// 桶的数量的值，最终map创建的桶的数量为 2^B 
</span><span class="c1"></span>  <span class="c1">// 另外在使用Key的哈希值选桶的时候
</span><span class="c1"></span>  <span class="c1">// 取的是该哈希值的低B位作为选桶的值
</span><span class="c1"></span>	<span class="nx">B</span>         <span class="kt">uint8</span>   
  <span class="c1">// 当前溢出桶的数量
</span><span class="c1"></span>	<span class="nx">noverflow</span> <span class="kt">uint16</span>
  <span class="c1">// hash种子，在创建该结构体的时候动态生成
</span><span class="c1"></span>	<span class="nx">hash0</span>     <span class="kt">uint32</span>  
	
  <span class="c1">// 指向第一个桶的指针 是一个连续的地址 因为是个数组
</span><span class="c1"></span>  <span class="c1">// 这里面存的是 *bmap
</span><span class="c1"></span>	<span class="nx">buckets</span>    <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>  
  <span class="c1">// 旧桶第一个桶的指针，用于在扩容搬迁的时候未完成搬迁时保存之前的旧桶
</span><span class="c1"></span>	<span class="nx">oldbuckets</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>  
  <span class="c1">// 搬迁桶的进度 就是处于扩容搬迁时，目前搬到哪了
</span><span class="c1"></span>	<span class="nx">nevacuate</span>  <span class="kt">uintptr</span> 
  <span class="c1">// 溢出桶  当bmap中存储的数据过多
</span><span class="c1"></span>  <span class="c1">// 单个bmap已经装满时就会使用 extra.nextOverflow 中桶存储溢出的数据。
</span><span class="c1"></span>  <span class="c1">// 溢出桶不一定会使用，因为他是个可选字段
</span><span class="c1"></span>	<span class="nx">extra</span> <span class="o">*</span><span class="nx">mapextra</span>  
<span class="p">}</span>

 <span class="kd">type</span> <span class="nx">mapextra</span> <span class="kd">struct</span> <span class="p">{</span>
 <span class="c1">// 如果key和value都不包含指针，而且是内联的，那么我们就将bucket类型标记为不包含指针。
</span><span class="c1"></span> <span class="c1">// 这样就避免了对这类地图的扫描。
</span><span class="c1"></span> <span class="c1">// 然而，bmap.overflow 是一个指针。为了防止溢出桶被gc处理
</span><span class="c1"></span> <span class="c1">// 我们在hmap.extra.overflow和hmap.extra.oldoverflow中存储所有溢出桶的指针。
</span><span class="c1"></span> <span class="c1">// overflow和oldoverflow只在key和value不包含指针的情况下使用
</span><span class="c1"></span>	<span class="nx">overflow</span>    <span class="o">*</span><span class="p">[]</span><span class="o">*</span><span class="nx">bmap</span>
	<span class="nx">oldoverflow</span> <span class="o">*</span><span class="p">[]</span><span class="o">*</span><span class="nx">bmap</span>
 <span class="c1">// 存储一个已经创建好了但是暂未使用的空bmap溢出桶
</span><span class="c1"></span> 	<span class="nx">nextOverflow</span> <span class="o">*</span><span class="nx">bmap</span>
<span class="p">}</span>
 <span class="c1">// 实际存储k，v数据的桶
</span><span class="c1">// 该结构体还有一些字段会在编译期添加
</span><span class="c1">// 比如 下一个溢出桶的地址
</span><span class="c1">// key，value所处的地址等
</span><span class="c1"></span> <span class="kd">type</span> <span class="nx">bmap</span> <span class="kd">struct</span> <span class="p">{</span>
   <span class="c1">// 这里存储可 Key的哈希值的高8位 例子 11111111 00000000
</span><span class="c1"></span>   <span class="c1">// 用于在查找时快速的去判断当前Key是否存在这个桶里
</span><span class="c1"></span>   <span class="c1">// 因此得出，每个桶只能存放8个Key-Value映射
</span><span class="c1"></span>	<span class="nx">tophash</span> <span class="p">[</span><span class="nx">bucketCnt</span><span class="p">]</span><span class="kt">uint8</span>
<span class="p">}</span>
</code></pre></div><p>关于Map的结构体，就是上述代码中所描述的一些信息，由此可以得出几个信息：</p>
<ol>
<li>Map的最大桶的数量为1&laquo;255个，因为hmap.B为uint8类型，最大值为255.</li>
<li>桶的数量时1&laquo;B个</li>
<li>每个bmap只能存放8对Key-Value，当这个bmap装满的时候就会使用hmap.extra.nextOverflow中已经创建好的空bmap作为溢出桶，如果不存在则创建一个溢出桶。</li>
</ol>
<h3 id="构建map">构建Map</h3>
<p>看完了Map的数据结构，那么接下来看一下Map的构建方式以及构建过程之中到底发生了什么，首先Map的几种构建方式如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">a</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span>
		<span class="mi">1</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
		<span class="mi">2</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="c1">// let [a] alloc from heap
</span><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
	
	<span class="c1">// let this map alloc alloc from stack
</span><span class="c1"></span>	<span class="nx">_</span> <span class="p">=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span>
		<span class="mi">1</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
		<span class="mi">2</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="nx">b</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
	<span class="nx">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="mi">2</span>
	<span class="nx">b</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="p">=</span> <span class="mi">3</span>
	
	<span class="kd">var</span> <span class="nx">c</span> <span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">int</span>
	<span class="nx">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]=</span><span class="mi">2</span> <span class="c1">// wrong! map is not init,it will panic
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>上面4种方式都是构建一个Map的方式，但是第4种方式只是声明了一个Map并未初始化，所以当对其赋值的时候会出现panic，那么这两种构建的方式区别在哪呢？遇事不决先看汇编。</p>
<h5 id="构建方式1--小型map堆分配">构建方式1&ndash;小型Map堆分配</h5>
<p>首先看第一个方式的汇编代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">  			<span class="mh">0x002f</span> <span class="mo">00047</span>      <span class="nx">CALL</span>    <span class="nx">runtime</span><span class="p">.</span><span class="nf">makemap_small</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
        <span class="mh">0x0034</span> <span class="mo">00052</span>      <span class="nf">MOVQ</span>    <span class="p">(</span><span class="nx">SP</span><span class="p">),</span> <span class="nx">AX</span>
        <span class="mh">0x0038</span> <span class="mo">00056</span>      <span class="nx">MOVQ</span>    <span class="nx">AX</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">.</span><span class="nx">a</span><span class="o">+</span><span class="mi">72</span><span class="p">(</span><span class="nx">SP</span><span class="p">)</span>
        <span class="mh">0x003d</span> <span class="mo">00061</span>      <span class="nx">MOVQ</span>    <span class="err">$</span><span class="mi">1</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">..</span><span class="nx">autotmp_4</span><span class="o">+</span><span class="mi">56</span><span class="p">(</span><span class="nx">SP</span><span class="p">)</span>

</code></pre></div><p>首先不看别的只看第一行，00047 部分，此处调用了函数构建了一个新的map，此函数的实现代码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">makemap_small</span><span class="p">()</span> <span class="o">*</span><span class="nx">hmap</span> <span class="p">{</span>
	<span class="nx">h</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">hmap</span><span class="p">)</span>
	<span class="nx">h</span><span class="p">.</span><span class="nx">hash0</span> <span class="p">=</span> <span class="nf">fastrand</span><span class="p">()</span>
	<span class="k">return</span> <span class="nx">h</span>
<span class="p">}</span>
</code></pre></div><p>短短的3行代码，很简单，runtime.makemap_small() 实现了在编译时已知元素数量，即Key-Value个数&lt;=8或者make时明确len&lt;=8，且Map需要在堆上分配时（因为我这个代码下面使用了fmt.Println()输出了a，所以在堆上分配了Map），为make(map[k]v)和make(map[k]v, hint)创建Map。</p>
<h5 id="构建方式2--小型map栈分配">构建方式2&ndash;小型Map栈分配</h5>
<p>接下来看一下第二种Map的字面量构建方式，这种方式是在栈上构建的，因为避免输出汇编时出现未使用变量错误所以忽略了变量名，接下来看一下汇编代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"> <span class="mh">0x01e2</span> <span class="mo">004</span><span class="mi">82</span>      <span class="nx">CALL</span>    <span class="nx">runtime</span><span class="p">.</span><span class="nf">fastrand</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
 <span class="mh">0x01e7</span> <span class="mo">004</span><span class="mi">87</span>     <span class="nx">MOVQ</span>    <span class="s">&#34;&#34;</span><span class="p">..</span><span class="nx">autotmp_14</span><span class="o">+</span><span class="mi">312</span><span class="p">(</span><span class="nx">SP</span><span class="p">),</span> <span class="nx">AX</span>

</code></pre></div><p>还是只看第一行，其调用了runtime.fastrand()，这是为什么呢？因为在编译期间，当创建的Map被分配到栈上并且其Key-Value个数&lt;=8或者make时明确len&lt;=8时，Go 语言在编译阶段会使用runtime.fastrand()快速初始化哈希，这也是编译器对小容量的哈希做的优化，也就是说会生成类似下面的代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span>
<span class="kd">var</span> <span class="nx">hv</span> <span class="nx">hmap</span>
<span class="kd">var</span> <span class="nx">bv</span> <span class="nx">bmap</span>
<span class="nx">h</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">hv</span>
<span class="nx">b</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">bv</span>
<span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span> <span class="p">=</span> <span class="nx">b</span>
<span class="nx">h</span><span class="p">.</span><span class="nx">hash0</span> <span class="p">=</span> <span class="nf">fashtrand0</span><span class="p">()</span>
</code></pre></div><h5 id="常规构建方式--make的len8或key-value个数8">常规构建方式&ndash;Make的len&gt;8或Key-Value个数&gt;8</h5>
<p>第三种方式是经常使用的一种初始化方式，即使用make函数进行初始化，这与切片的初始化方式相同，但是不同的是，使用make初始化Map只可以传递两个参数一个是类型一个是长度，而不能像切片一样传递一个容量。</p>
<p>接下来看一下第三种方式所产生的汇编代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="mh">0x04b8</span> <span class="mo">0120</span><span class="mi">8</span>    <span class="nx">CALL</span>    <span class="nx">runtime</span><span class="p">.</span><span class="nf">makemap</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
</code></pre></div><p>从上述汇编可以看出，创建Map调用了runtime.makemap()这个函数不光只有在使用make方式时会调用，也会在不满足上面2种方式的时候进行调用，也就是说runtime.makemap()是一个构建Map最后调用的都是runtime.makemap()，接下来来详细讲解这个函数的逻辑：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 传入的三个参数分别为
</span><span class="c1">// 1.map的类型即 key和value的类型信息等其他数据
</span><span class="c1">// 2.长度 即 make 传入的len
</span><span class="c1">// 3.hmap结构体 可以为nil
</span><span class="c1">// 返回值为经过处理的 *hmap
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">makemap</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">hint</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">)</span> <span class="o">*</span><span class="nx">hmap</span> <span class="p">{</span>
  <span class="c1">// 校验一下需求的长度和类型占用字节数的乘积
</span><span class="c1"></span>  <span class="c1">// 是否超过内存限制
</span><span class="c1"></span>	<span class="nx">mem</span><span class="p">,</span> <span class="nx">overflow</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nf">MulUintptr</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">hint</span><span class="p">),</span> <span class="nx">t</span><span class="p">.</span><span class="nx">bucket</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">overflow</span> <span class="o">||</span> <span class="nx">mem</span> <span class="p">&gt;</span> <span class="nx">maxAlloc</span> <span class="p">{</span>
		<span class="nx">hint</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>
	<span class="c1">// 创建一个新的 hmap结构体
</span><span class="c1"></span> 	<span class="k">if</span> <span class="nx">h</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">h</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">hmap</span><span class="p">)</span>
	<span class="p">}</span>
  <span class="c1">// 获取一个随机的哈希种子
</span><span class="c1"></span>	<span class="nx">h</span><span class="p">.</span><span class="nx">hash0</span> <span class="p">=</span> <span class="nf">fastrand</span><span class="p">()</span>

 	
	<span class="nx">B</span> <span class="o">:=</span> <span class="nb">uint8</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
  <span class="c1">// 通过输入的长度 算出一个合适的B值
</span><span class="c1"></span>	<span class="k">for</span> <span class="nf">overLoadFactor</span><span class="p">(</span><span class="nx">hint</span><span class="p">,</span> <span class="nx">B</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">B</span><span class="o">++</span>
	<span class="p">}</span>
	<span class="nx">h</span><span class="p">.</span><span class="nx">B</span> <span class="p">=</span> <span class="nx">B</span>

	 <span class="c1">// 如果B不为0
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="kd">var</span> <span class="nx">nextOverflow</span> <span class="o">*</span><span class="nx">bmap</span>
 		<span class="c1">// 调用makeBucketArray 返回一个溢出bmap和开辟完内存的桶的首地址指针
</span><span class="c1"></span>		<span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span><span class="p">,</span> <span class="nx">nextOverflow</span> <span class="p">=</span> <span class="nf">makeBucketArray</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
    <span class="c1">// 如果有溢出bmap
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">nextOverflow</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">h</span><span class="p">.</span><span class="nx">extra</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">mapextra</span><span class="p">)</span>
			<span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">nextOverflow</span> <span class="p">=</span> <span class="nx">nextOverflow</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">h</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">makeBucketArray</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">uint8</span><span class="p">,</span> <span class="nx">dirtyalloc</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="p">(</span><span class="nx">buckets</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">nextOverflow</span> <span class="o">*</span><span class="nx">bmap</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 求出需要桶的个数 即返回 1&lt;&lt;B的值
</span><span class="c1"></span>	<span class="nx">base</span> <span class="o">:=</span> <span class="nf">bucketShift</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
	<span class="nx">nbuckets</span> <span class="o">:=</span> <span class="nx">base</span>
	<span class="c1">// 如果需要的桶的个数小于4个 那么就不需要创建溢出bmap
</span><span class="c1"></span>  <span class="c1">// 为的是防止有可能不需要bmap的时候却创建了bmap
</span><span class="c1"></span>  <span class="c1">// 使其降低资源开销
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">b</span> <span class="o">&gt;=</span> <span class="mi">4</span> <span class="p">{</span>
		<span class="c1">// 创建的溢出bmap的数量是1&lt;&lt;（B-4）个
</span><span class="c1"></span>    <span class="c1">// 获得所需的桶与溢出bmap的数量
</span><span class="c1"></span>		<span class="nx">nbuckets</span> <span class="o">+=</span> <span class="nf">bucketShift</span><span class="p">(</span><span class="nx">b</span> <span class="o">-</span> <span class="mi">4</span><span class="p">)</span>
    <span class="c1">// 计算类型 占用字节数 * 所需的桶与溢出bmap的数量的乘积
</span><span class="c1"></span>		<span class="nx">sz</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">bucket</span><span class="p">.</span><span class="nx">size</span> <span class="o">*</span> <span class="nx">nbuckets</span>
    <span class="c1">// 获取对应长度的内存块的大小
</span><span class="c1"></span>		<span class="nx">up</span> <span class="o">:=</span> <span class="nf">roundupsize</span><span class="p">(</span><span class="nx">sz</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">up</span> <span class="o">!=</span> <span class="nx">sz</span> <span class="p">{</span>
			<span class="nx">nbuckets</span> <span class="p">=</span> <span class="nx">up</span> <span class="o">/</span> <span class="nx">t</span><span class="p">.</span><span class="nx">bucket</span><span class="p">.</span><span class="nx">size</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">// 如果之前没分配过
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">dirtyalloc</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="c1">// 分配一个nbuckets 长度的bmap数组 返回首指针
</span><span class="c1"></span>    <span class="c1">// 正常情况下桶和溢出bmap是连续的
</span><span class="c1"></span>    <span class="c1">// 但是当溢出bmap过多的时候每次通过runtime.newobject申请的bmap
</span><span class="c1"></span>    <span class="c1">// 与最初创建的不一定是连续的了
</span><span class="c1"></span>		<span class="nx">buckets</span> <span class="p">=</span> <span class="nf">newarray</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucket</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="nx">nbuckets</span><span class="p">))</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// 这块是用来清空已经分配的桶的内存的逻辑
</span><span class="c1"></span>		<span class="nx">buckets</span> <span class="p">=</span> <span class="nx">dirtyalloc</span>
 		<span class="nx">size</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">bucket</span><span class="p">.</span><span class="nx">size</span> <span class="o">*</span> <span class="nx">nbuckets</span>
		<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">bucket</span><span class="p">.</span><span class="nx">ptrdata</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
 			<span class="nf">memclrHasPointers</span><span class="p">(</span><span class="nx">buckets</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nf">memclrNoHeapPointers</span><span class="p">(</span><span class="nx">buckets</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">// 如果创建了溢出bmap
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">base</span> <span class="o">!=</span> <span class="nx">nbuckets</span> <span class="p">{</span>
    <span class="c1">// 如果有溢出桶
</span><span class="c1"></span>    <span class="c1">// 就把溢出bmap设置为申请的bmap数组的 nbuckets-base处的那个当作空闲溢出bmap
</span><span class="c1"></span>		<span class="nx">nextOverflow</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">buckets</span><span class="p">,</span> <span class="nx">base</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span>
    <span class="c1">// 然后把剩下那个 即最后那个bmap（应该是）做一下标记
</span><span class="c1"></span>    <span class="c1">// 这个地方有疑，官方的意思是
</span><span class="c1"></span>    <span class="c1">// 我们预先分配了一些溢出桶。为了将跟踪这些溢出桶的开销降到最低
</span><span class="c1"></span>    <span class="c1">// 我们使用的惯例是，如果一个预分配溢出桶的溢出 指针为nil
</span><span class="c1"></span>    <span class="c1">// 那么就可以通过bumping指针来获得更多的可用指针。
</span><span class="c1"></span>    
    <span class="c1">// 个人理解 就是给申请好了的溢出bmap 但是还不是nextOverflow的溢出bmap
</span><span class="c1"></span>    <span class="c1">// 加个类似标记的东西，方便下次需要nextOverflow时但 nextOverflow ==nil 时
</span><span class="c1"></span>    <span class="c1">// 直接通过某种方式快速查找使用
</span><span class="c1"></span>		<span class="nx">last</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">buckets</span><span class="p">,</span> <span class="p">(</span><span class="nx">nbuckets</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span>
		<span class="nx">last</span><span class="p">.</span><span class="nf">setoverflow</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nx">buckets</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">buckets</span><span class="p">,</span> <span class="nx">nextOverflow</span>
<span class="p">}</span>

</code></pre></div><h5 id="总结">总结</h5>
<p>至此讲完了关于构建Map的方式，接下来做个总结：</p>
<ol>
<li>无论是字面量初始化还是make初始化，当所需Map分配到堆上且所需长度&lt;=8时，使用runtime.makemap_small()初始化。</li>
<li>无论是字面量初始化还是make初始化，当所需Map分配到不需要分配到堆上且所需长度&lt;=8时，通过快速哈希方式创建。</li>
<li>其余情况会调用runtime.makemap()，该函数的执行过程如下：
<ol>
<li>校验是否内存溢出</li>
<li>获得随机哈希种子</li>
<li>计算传入长度所需的B值，这个值是最小值，即最小需要1&laquo;B个bmap</li>
<li>如果B&lt;4则不创建溢出bmap ，为的是节省资源，否则创建1&laquo;(B-4)个溢出bmap</li>
<li>然后创建一个所需长度的连续的bmap数组，并且返回头指针给hmap.buckets。</li>
<li>设置溢出bmap（如果有）的一些信息。</li>
<li>返回*hmap，也就是说 make(map)返回的是一个hmap的指针。</li>
</ol>
</li>
</ol>
<h3 id="map的读写">Map的读写</h3>
<h4 id="map的写入删除">Map的写入/删除</h4>
<p>在构建完Map之后，可以向Map中进行读写和删除数据了，因为删除算是写的一种，所以本章会将Map的删除和写入放到一起来讲，常见的Map的写入删除方式如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">m</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
	<span class="nx">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1</span>
	<span class="nx">m</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="p">=</span> <span class="mi">2</span>
	<span class="nb">delete</span><span class="p">(</span><span class="nx">m</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="c1">// normal delete Key == 1
</span><span class="c1"></span>	<span class="nb">delete</span><span class="p">(</span><span class="nx">m</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="c1">// not found Key == 3  
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>类似m[1]=1这种就是对Map的写入，即将Key设置为1并且对应的Value也是1，在写入时，如果这个Key存在于当前Map时，其目前的值就会被覆盖掉，如果不存在则会直接写入</p>
<p>后面的delete(m,1)是一个内建函数，用于删除Map中的某个Key及其对应的值，第一个参数传递的是目标Map，第二个是Key的值，这个函数不会返回任何参数，并且当要删除的Key不存在时，也不会出现任何问题。</p>
<h5 id="map的写入解析">Map的写入解析</h5>
<p>现在来解析一下关于Map的写入的解析，首先还是根据上面的代码去输出汇编代码看看写入的时候到底发生了什么？</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">        <span class="mh">0x00af</span> <span class="mo">00175</span>      <span class="nx">CALL</span>    <span class="nx">runtime</span><span class="p">.</span><span class="nf">mapassign_fast64</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>

</code></pre></div><p>上述汇编代码看出，再向Map中写入数据的时候调用了runtime.mapassign_fast64()函数，但是作者并没有在runtime.map.go文件中找到相对应的函数，根据网上其他一些文章得知，最终的写入时的函数调用都会调用到runtime.mapassign()中，那么，接下来我们就开始讲一下关于runtime.mapassign()函数的一些逻辑的代码解析：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 该函数传入的参数分别为
</span><span class="c1">// 1.map的类型即 key和value的类型信息等其他数据
</span><span class="c1">// 2.那个map
</span><span class="c1">// 3.key所在内存的地址
</span><span class="c1">// 返回的参数为
</span><span class="c1">// 1.找到的可用的可存储value的内存地址
</span><span class="c1">// 返回后具体的赋值操作由汇编完成
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">mapassign</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">key</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="p">{</span>
  <span class="c1">// 不能往nil map中进行写入
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">h</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nf">plainError</span><span class="p">(</span><span class="s">&#34;assignment to entry in nil map&#34;</span><span class="p">))</span>
	<span class="p">}</span>
	
	<span class="c1">// 校验标记为是否存在并发写状态
</span><span class="c1"></span>  <span class="c1">// 如果是则panic
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">flags</span><span class="o">&amp;</span><span class="nx">hashWriting</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;concurrent map writes&#34;</span><span class="p">)</span>
	<span class="p">}</span>
  <span class="c1">// 求出这个key的哈希值
</span><span class="c1"></span>	<span class="nx">hash</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">hasher</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">hash0</span><span class="p">))</span>

	<span class="c1">// 设置写标记，避免并发写
</span><span class="c1"></span>	<span class="nx">h</span><span class="p">.</span><span class="nx">flags</span> <span class="p">^=</span> <span class="nx">hashWriting</span>
	<span class="c1">// 如果当前么得可用的桶
</span><span class="c1"></span>  <span class="c1">// 那就创建一个bmap用于装数据
</span><span class="c1"></span>  <span class="c1">// 调用 makemap_small 创建map的时候可能会出现此问题
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span> <span class="p">=</span> <span class="nf">newobject</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucket</span><span class="p">)</span>  
	<span class="p">}</span>

<span class="nx">again</span><span class="p">:</span>
  <span class="c1">// 算出这个key应该落到哪个bmap里
</span><span class="c1"></span>	<span class="nx">bucket</span> <span class="o">:=</span> <span class="nx">hash</span> <span class="o">&amp;</span> <span class="nf">bucketMask</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span>
  <span class="c1">// 判断是否处于搬迁桶的状态
</span><span class="c1"></span>  <span class="c1">// 如果处于该状态则进行旧桶 -&gt; 新桶的搬迁
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nf">growing</span><span class="p">()</span> <span class="p">{</span>
		<span class="nf">growWork</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">bucket</span><span class="p">)</span>
	<span class="p">}</span>
  <span class="c1">// 通过位移操作获得 bucket := hash &amp; bucketMask(h.B) 这个桶的对象
</span><span class="c1"></span>	<span class="nx">b</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span><span class="p">)</span> <span class="o">+</span> <span class="nx">bucket</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span>
  <span class="c1">// 计算出key的哈希值之后的高8位哈希值
</span><span class="c1"></span>	<span class="nx">top</span> <span class="o">:=</span> <span class="nf">tophash</span><span class="p">(</span><span class="nx">hash</span><span class="p">)</span>
	
  <span class="c1">// 元素在bmap中tophash数组的地址
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">inserti</span> <span class="o">*</span><span class="kt">uint8</span>
  <span class="c1">// key的地址
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">insertk</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
  <span class="c1">// value 的地址
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">elem</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
<span class="nx">bucketloop</span><span class="p">:</span>
	<span class="k">for</span> <span class="p">{</span>
    <span class="c1">// 遍历当前选中的bmap
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">bucketCnt</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
      <span class="c1">// 对比高8位，如果不等于
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">top</span> <span class="p">{</span>
        <span class="c1">// 如果这个tophash为nil且当前索引=nil
</span><span class="c1"></span>        <span class="c1">// 那么就直接用这个位置
</span><span class="c1"></span>        <span class="c1">// 这个操作是插入且不存在扩容时的操作
</span><span class="c1"></span>				<span class="k">if</span> <span class="nf">isEmpty</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="o">&amp;&amp;</span> <span class="nx">inserti</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
          <span class="c1">// 设置元素在bmap中tophash数组的地址
</span><span class="c1"></span>					<span class="nx">inserti</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
          <span class="c1">// 通过位移找到对应的可用的key的地址位置
</span><span class="c1"></span>					<span class="nx">insertk</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nx">i</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">))</span>
          <span class="c1">// 通过位移找到对应的可用的value的地址位置
</span><span class="c1"></span>					<span class="nx">elem</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nx">bucketCnt</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">)</span><span class="o">+</span><span class="nx">i</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">elemsize</span><span class="p">))</span>
				<span class="p">}</span>
        <span class="c1">// 如果 b.tophash[i] == emptyRest 
</span><span class="c1"></span>        <span class="c1">// 代表后续的b.tophash没有 溢出bmap或者可遍历的b.tophash了
</span><span class="c1"></span>				<span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="nx">emptyRest</span> <span class="p">{</span>
          <span class="c1">// 跳出循环
</span><span class="c1"></span>					<span class="k">break</span> <span class="nx">bucketloop</span>
				<span class="p">}</span>
				<span class="k">continue</span>
			<span class="p">}</span>
      <span class="c1">// 偏移到到对应的key的位置
</span><span class="c1"></span>			<span class="nx">k</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nx">i</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">))</span>
			<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">indirectkey</span><span class="p">()</span> <span class="p">{</span>
				<span class="nx">k</span> <span class="p">=</span> <span class="o">*</span><span class="p">((</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">k</span><span class="p">))</span>
			<span class="p">}</span>
      <span class="c1">// 传入的key的值和当前k处存在的key的值比较一下是否相等 
</span><span class="c1"></span>      <span class="c1">// 如果不相等代表没找到
</span><span class="c1"></span>			<span class="k">if</span> <span class="p">!</span><span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">.</span><span class="nf">equal</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">continue</span>
			<span class="p">}</span>
			<span class="c1">// 如果相等那么就代表是更新操作
</span><span class="c1"></span>      <span class="c1">// 先把传入的key的赋值到k处
</span><span class="c1"></span>      <span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">needkeyupdate</span><span class="p">()</span> <span class="p">{</span>
				<span class="nf">typedmemmove</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">,</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span>
			<span class="p">}</span>
      <span class="c1">// 计算出k对应value的地址
</span><span class="c1"></span>			<span class="nx">elem</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nx">bucketCnt</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">)</span><span class="o">+</span><span class="nx">i</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">elemsize</span><span class="p">))</span>
      <span class="c1">// 直接跳转到结束
</span><span class="c1"></span>			<span class="k">goto</span> <span class="nx">done</span>
		<span class="p">}</span>
    <span class="c1">// 获取溢出bmap
</span><span class="c1"></span>    <span class="c1">// 代表在当前bmap里面么得找到可用的地址
</span><span class="c1"></span>		<span class="nx">ovf</span> <span class="o">:=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">overflow</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
    <span class="c1">// 没有溢出bmap就跳出
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">ovf</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>
    <span class="c1">// 继续循环
</span><span class="c1"></span>		<span class="nx">b</span> <span class="p">=</span> <span class="nx">ovf</span>
	<span class="p">}</span>
	<span class="c1">// 如果没找到可用的插槽，那么就创建一个
</span><span class="c1"></span>	 
  <span class="c1">// 判断是否需要扩容
</span><span class="c1"></span>  <span class="c1">// 扩容条件为：
</span><span class="c1"></span>  <span class="c1">// 1.当装载因子&gt;=6.5
</span><span class="c1"></span>  <span class="c1">// 2.溢出bmap过多
</span><span class="c1"></span>  <span class="c1">// 第二种情况只会出现在先大量的写然后再大量删除的情况
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">h</span><span class="p">.</span><span class="nf">growing</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nf">overLoadFactor</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">count</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="o">||</span> <span class="nf">tooManyOverflowBuckets</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">noverflow</span><span class="p">,</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span><span class="p">))</span> <span class="p">{</span>
    <span class="c1">// 扩容
</span><span class="c1"></span>		<span class="nf">hashGrow</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">h</span><span class="p">)</span>
    <span class="c1">// 重新找
</span><span class="c1"></span>		<span class="k">goto</span> <span class="nx">again</span>  
	<span class="p">}</span>
	<span class="c1">// 如果在当前的bmap及其溢出的bmap都没找到合适的地方
</span><span class="c1"></span>  <span class="c1">// 即 所有的bmap都满了
</span><span class="c1"></span>  <span class="c1">// 那就创建一个新的溢出bmap
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">inserti</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">newb</span> <span class="o">:=</span> <span class="nx">h</span><span class="p">.</span><span class="nf">newoverflow</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span>
		<span class="nx">inserti</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">newb</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
		<span class="nx">insertk</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">newb</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="p">)</span>
		<span class="nx">elem</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">insertk</span><span class="p">,</span> <span class="nx">bucketCnt</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">))</span>
	<span class="p">}</span>

	<span class="c1">// 将新key/elem存储在插入位置	
</span><span class="c1"></span>  <span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">indirectkey</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">kmem</span> <span class="o">:=</span> <span class="nf">newobject</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">)</span>
		<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">insertk</span><span class="p">)</span> <span class="p">=</span> <span class="nx">kmem</span>
		<span class="nx">insertk</span> <span class="p">=</span> <span class="nx">kmem</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">indirectelem</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">vmem</span> <span class="o">:=</span> <span class="nf">newobject</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">elem</span><span class="p">)</span>
		<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">elem</span><span class="p">)</span> <span class="p">=</span> <span class="nx">vmem</span>
	<span class="p">}</span>
  <span class="c1">// 把插入的key的值写入到对应的key的地址里
</span><span class="c1"></span>	<span class="nf">typedmemmove</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">,</span> <span class="nx">insertk</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span>
  <span class="c1">// 把插入的key的高8值写入到对应的tophash的地址里 
</span><span class="c1"></span>	<span class="o">*</span><span class="nx">inserti</span> <span class="p">=</span> <span class="nx">top</span>
  <span class="c1">// 当前元素个数+1
</span><span class="c1"></span>	<span class="nx">h</span><span class="p">.</span><span class="nx">count</span><span class="o">++</span>

<span class="nx">done</span><span class="p">:</span>
  <span class="c1">// 再次校验并发写
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">flags</span><span class="o">&amp;</span><span class="nx">hashWriting</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;concurrent map writes&#34;</span><span class="p">)</span>
	<span class="p">}</span>
  <span class="c1">// 取消写标记
</span><span class="c1"></span>	<span class="nx">h</span><span class="p">.</span><span class="nx">flags</span> <span class="o">&amp;^=</span> <span class="nx">hashWriting</span>
	<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">indirectelem</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">elem</span> <span class="p">=</span> <span class="o">*</span><span class="p">((</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">elem</span><span class="p">))</span>
	<span class="p">}</span>
  <span class="c1">// 返回可用的value 存放地址
</span><span class="c1"></span>  <span class="c1">// 随后的赋值操作会在汇编中进行
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">elem</span>
<span class="p">}</span>

</code></pre></div><h6 id="map写入操作过程的总结">Map写入操作过程的总结</h6>
<ol>
<li>首先会计算出传入Key的哈希，其低B位用于选择对应的bmap，其哈希值的高8位用于在对应的bmap中快速的查找是否有此key的存在，并且对该map打上写标记，防止并发读写。</li>
<li>遍历找到的bmap及其溢出bmap，并按照下面的条件执行
<ol>
<li>如果比较到当前的tophash不等于传入key的tophash，且未找到可用tophash地址时，如果当前tophash无已存放的key，那么记录下这个tophash的地址和其对应的k，v的地址，此条件为插入操作。</li>
<li>如果当前tophash是emptyRest，则代表后续没有溢出bmap或者可遍历的tophash了</li>
<li>如果当前的tophash==传入key的tophash，则会对比传入的Key以及tophash对应的Key的地址的值是否相等，如果相等则代表已经存在了当前传入的Key，则此操作为更新操作，此时计算出对应value的存放地址</li>
<li>如果上述条件都不满足则遍历溢出bmap（如果有）</li>
</ol>
</li>
<li>如果在bmap及其溢出bmap中都没有找到可用的存放地址，则创建一个新的溢出bmap，因为没找到说明没有可用的tophash位置了，即所有的bmap都满了。</li>
<li>如果符合下列扩容条件就会产生扩容，扩容完毕后重新开始 序号2 的过程。
<ol>
<li>当装载因子&gt;=6.5</li>
<li>溢出bmap过多，该情况只会出现在先大量的写然后再大量删除但装载因子并没有&gt;=6.5的情况</li>
</ol>
</li>
<li>如果不需要扩容则创建一个新的bmap，给传入Key的哈希，其低B位用于选择对应的bmap的溢出bmap链表尾部，然后获得可用的tophash，key，value地址。然后取消写标记，返回可用的value 存放地址 ， 随后的赋值操作会在汇编中进行</li>
</ol>
<h6 id="map的扩容">Map的扩容</h6>
<p>在刚才的上文说了，写入的时候如果在bmap及其溢出bmap中都没有找到可用的存放地址，则创建一个新的溢出bmap，因为没找到说明没有可用的tophash位置了，即所有的bmap都满了。那么我们接下来看一下这个关于扩容函数hashGrow()的源代码解析</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">hashGrow</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 需要扩容多少bmap
</span><span class="c1"></span>  <span class="c1">// 默认为翻倍扩容
</span><span class="c1"></span>  <span class="c1">// 此情况为装载因子&gt;=6.5
</span><span class="c1"></span>	<span class="nx">bigger</span> <span class="o">:=</span> <span class="nb">uint8</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">!</span><span class="nf">overLoadFactor</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">count</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 如果是因为溢出bmap过多导致扩容
</span><span class="c1"></span>    <span class="c1">// 则不会增加新的bmap
</span><span class="c1"></span>    <span class="c1">// 此情况为等量扩容（整理）
</span><span class="c1"></span>		<span class="nx">bigger</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="nx">h</span><span class="p">.</span><span class="nx">flags</span> <span class="o">|=</span> <span class="nx">sameSizeGrow</span>
	<span class="p">}</span>
  <span class="c1">// 把原来的bmap列表放到旧bmap字段里
</span><span class="c1"></span>	<span class="nx">oldbuckets</span> <span class="o">:=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span>
  <span class="c1">// 申请新的翻倍长度的bmap 因为bmap的个数为1&lt;&lt;B个所以当B+1时就会增加一倍
</span><span class="c1"></span>	<span class="nx">newbuckets</span><span class="p">,</span> <span class="nx">nextOverflow</span> <span class="o">:=</span> <span class="nf">makeBucketArray</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span><span class="o">+</span><span class="nx">bigger</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
	<span class="c1">// 判断当前状态
</span><span class="c1"></span>	<span class="nx">flags</span> <span class="o">:=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">flags</span> <span class="o">&amp;^</span> <span class="p">(</span><span class="nx">iterator</span> <span class="p">|</span> <span class="nx">oldIterator</span><span class="p">)</span>
  <span class="c1">// 如果当前状态不是迭代状态
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">flags</span><span class="o">&amp;</span><span class="nx">iterator</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="c1">// 让迭代的时候去迭代旧桶
</span><span class="c1"></span>    <span class="c1">// 因为还没有搬迁完毕
</span><span class="c1"></span>		<span class="nx">flags</span> <span class="o">|=</span> <span class="nx">oldIterator</span>
	<span class="p">}</span>
	<span class="c1">// 对hmap做赋值操作
</span><span class="c1"></span>	<span class="nx">h</span><span class="p">.</span><span class="nx">B</span> <span class="o">+=</span> <span class="nx">bigger</span>
	<span class="nx">h</span><span class="p">.</span><span class="nx">flags</span> <span class="p">=</span> <span class="nx">flags</span>
	<span class="nx">h</span><span class="p">.</span><span class="nx">oldbuckets</span> <span class="p">=</span> <span class="nx">oldbuckets</span>
	<span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span> <span class="p">=</span> <span class="nx">newbuckets</span>
	<span class="nx">h</span><span class="p">.</span><span class="nx">nevacuate</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">h</span><span class="p">.</span><span class="nx">noverflow</span> <span class="p">=</span> <span class="mi">0</span>
	
  <span class="c1">// 如果之前有溢出bmap的话，把原来所持有的溢出bmap也变成旧的溢出bmap
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">extra</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">overflow</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">oldoverflow</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;oldoverflow is not nil&#34;</span><span class="p">)</span>
      <span class="p">}</span>
		<span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">oldoverflow</span> <span class="p">=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">overflow</span>
		<span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">overflow</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="p">}</span>
  <span class="c1">// 如果扩容的新bmap列表存在可用溢出bmap
</span><span class="c1"></span>  <span class="c1">// 那就设置一下
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">nextOverflow</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">extra</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">h</span><span class="p">.</span><span class="nx">extra</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">mapextra</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">nextOverflow</span> <span class="p">=</span> <span class="nx">nextOverflow</span>
	<span class="p">}</span>

	<span class="c1">// 此处没有发现扩容时的数据搬迁（从旧bmap中拷贝原数据到新的bmap中）工作
</span><span class="c1"></span> 	<span class="c1">// 因为哈希表数据的实际复制是由growWork()和evacuate()逐步完成的。
</span><span class="c1"></span>  <span class="c1">// 这两个函数的触发时机是在写/删除操作时触发
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="nf">growWork</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">bucket</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 计算一下当前的Key的hash出来的桶的索引在旧桶的哪个位置
</span><span class="c1"></span>	<span class="nf">evacuate</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">bucket</span><span class="o">&amp;</span><span class="nx">h</span><span class="p">.</span><span class="nf">oldbucketmask</span><span class="p">())</span>
	<span class="c1">// 如果搬完了一个之后发现还没搬迁完
</span><span class="c1"></span>  <span class="c1">// 就再搬一个
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nf">growing</span><span class="p">()</span> <span class="p">{</span>
		<span class="nf">evacuate</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">h</span><span class="p">.</span><span class="nx">nevacuate</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">//  用于保存分配上下文的结构体
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">evacDst</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">b</span> <span class="o">*</span><span class="nx">bmap</span>          <span class="c1">// 当前目标存储桶
</span><span class="c1"></span>	<span class="nx">i</span> <span class="kt">int</span>            <span class="c1">// 键/元素索引到b
</span><span class="c1"></span>	<span class="nx">k</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// 指向当前key的指针
</span><span class="c1"></span>	<span class="nx">e</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// 指向当前value的指针
</span><span class="c1"></span><span class="p">}</span>
 <span class="c1">// 实际的旧bmap 搬迁到新bmap的逻辑
</span><span class="c1"></span> <span class="c1">// 第三个参数是搬迁的那个桶
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">evacuate</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">oldbucket</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 找到要搬迁的桶
</span><span class="c1"></span>	<span class="nx">b</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">oldbuckets</span><span class="p">,</span> <span class="nx">oldbucket</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span>
  <span class="c1">// 算一下之前有多少个桶
</span><span class="c1"></span>	<span class="nx">newbit</span> <span class="o">:=</span> <span class="nx">h</span><span class="p">.</span><span class="nf">noldbuckets</span><span class="p">()</span>
  <span class="c1">// 判断是不是没有东西的bmap
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nf">evacuated</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 生成两个用于保存新桶上下文的结构体
</span><span class="c1"></span>		<span class="kd">var</span> <span class="nx">xy</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="nx">evacDst</span>
    <span class="c1">// 先保存一个 新bmap的上下文信息
</span><span class="c1"></span>		<span class="nx">x</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
		<span class="nx">x</span><span class="p">.</span><span class="nx">b</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span><span class="p">,</span> <span class="nx">oldbucket</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span>
		<span class="nx">x</span><span class="p">.</span><span class="nx">k</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="p">)</span>
		<span class="nx">x</span><span class="p">.</span><span class="nx">e</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">k</span><span class="p">,</span> <span class="nx">bucketCnt</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">))</span>
		<span class="c1">// 如果当前不是等量扩容（整理）
</span><span class="c1"></span>    <span class="c1">// 那么就搬两个桶
</span><span class="c1"></span>    <span class="c1">// 再获取一个新的bmap的上下文信息
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">!</span><span class="nx">h</span><span class="p">.</span><span class="nf">sameSizeGrow</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">y</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
			<span class="nx">y</span><span class="p">.</span><span class="nx">b</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span><span class="p">,</span> <span class="p">(</span><span class="nx">oldbucket</span><span class="o">+</span><span class="nx">newbit</span><span class="p">)</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span>
			<span class="nx">y</span><span class="p">.</span><span class="nx">k</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">y</span><span class="p">.</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="p">)</span>
			<span class="nx">y</span><span class="p">.</span><span class="nx">e</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">y</span><span class="p">.</span><span class="nx">k</span><span class="p">,</span> <span class="nx">bucketCnt</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">))</span>
		<span class="p">}</span>
		
    <span class="c1">// 循环当前需要搬迁的bmap及其溢出bmap
</span><span class="c1"></span>		<span class="k">for</span> <span class="p">;</span> <span class="nx">b</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="nx">b</span> <span class="p">=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">overflow</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// 找到第一个key和对应的value的地址
</span><span class="c1"></span>			<span class="nx">k</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="p">)</span>
			<span class="nx">e</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">bucketCnt</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">))</span>
      <span class="c1">// 遍历整个当前bmap的key和value
</span><span class="c1"></span>			<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">bucketCnt</span><span class="p">;</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">e</span> <span class="p">=</span> <span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nf">add</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">)),</span> <span class="nf">add</span><span class="p">(</span><span class="nx">e</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">elemsize</span><span class="p">))</span> <span class="p">{</span>
				<span class="c1">// 获取当前key value对应的tophash
</span><span class="c1"></span>        <span class="nx">top</span> <span class="o">:=</span> <span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
        <span class="c1">// 如果是空
</span><span class="c1"></span>				<span class="k">if</span> <span class="nf">isEmpty</span><span class="p">(</span><span class="nx">top</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// 做个标记 代表这个tophash已经搬走了
</span><span class="c1"></span>					<span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">evacuatedEmpty</span>
					<span class="k">continue</span>
				<span class="p">}</span>
        <span class="c1">// 有问题
</span><span class="c1"></span>				<span class="k">if</span> <span class="nx">top</span> <span class="p">&lt;</span> <span class="nx">minTopHash</span> <span class="p">{</span>
					<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;bad map state&#34;</span><span class="p">)</span>
        <span class="p">}</span>
				<span class="nx">k2</span> <span class="o">:=</span> <span class="nx">k</span>
				<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">indirectkey</span><span class="p">()</span> <span class="p">{</span>
					<span class="nx">k2</span> <span class="p">=</span> <span class="o">*</span><span class="p">((</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">k2</span><span class="p">))</span>
				<span class="p">}</span>
				<span class="kd">var</span> <span class="nx">useY</span> <span class="kt">uint8</span>
        <span class="c1">// 如果是翻倍扩容
</span><span class="c1"></span>				<span class="k">if</span> <span class="p">!</span><span class="nx">h</span><span class="p">.</span><span class="nf">sameSizeGrow</span><span class="p">()</span> <span class="p">{</span>
					<span class="c1">// 那么就需要重新计算当前这个key应该落到xy[0]还是xy[1]这两个新桶的哪个中去
</span><span class="c1"></span>          <span class="c1">// 因为等量扩容是整理，桶的数量并没有增加，所以原来在哪还是在哪
</span><span class="c1"></span>          <span class="c1">// 但是翻倍扩容则是增加了新的桶，就需要重新计算hash
</span><span class="c1"></span>          <span class="c1">// 也就是说翻倍扩容可能导致当前key的哈希值和之后的不是同一个
</span><span class="c1"></span>					<span class="nx">hash</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">hasher</span><span class="p">(</span><span class="nx">k2</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">hash0</span><span class="p">))</span>
          <span class="c1">// 这个是计算到底该把当前的key-value 放到xy[0]还是xy[1]
</span><span class="c1"></span>					<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">flags</span><span class="o">&amp;</span><span class="nx">iterator</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">t</span><span class="p">.</span><span class="nf">reflexivekey</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">.</span><span class="nf">equal</span><span class="p">(</span><span class="nx">k2</span><span class="p">,</span> <span class="nx">k2</span><span class="p">)</span> <span class="p">{</span>
						<span class="nx">useY</span> <span class="p">=</span> <span class="nx">top</span> <span class="o">&amp;</span> <span class="mi">1</span>
						<span class="nx">top</span> <span class="p">=</span> <span class="nf">tophash</span><span class="p">(</span><span class="nx">hash</span><span class="p">)</span>
					<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
						<span class="k">if</span> <span class="nx">hash</span><span class="o">&amp;</span><span class="nx">newbit</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
							<span class="nx">useY</span> <span class="p">=</span> <span class="mi">1</span>
						<span class="p">}</span>
					<span class="p">}</span>
				<span class="p">}</span>

				<span class="k">if</span> <span class="nx">evacuatedX</span><span class="o">+</span><span class="mi">1</span> <span class="o">!=</span> <span class="nx">evacuatedY</span> <span class="o">||</span> <span class="nx">evacuatedX</span><span class="p">^</span><span class="mi">1</span> <span class="o">!=</span> <span class="nx">evacuatedY</span> <span class="p">{</span>
					<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;bad evacuatedN&#34;</span><span class="p">)</span>
				<span class="p">}</span>
				<span class="c1">// 开始
</span><span class="c1"></span>				<span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">evacuatedX</span> <span class="o">+</span> <span class="nx">useY</span>  
				<span class="nx">dst</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">xy</span><span class="p">[</span><span class="nx">useY</span><span class="p">]</span>                 
				
				<span class="k">if</span> <span class="nx">dst</span><span class="p">.</span><span class="nx">i</span> <span class="o">==</span> <span class="nx">bucketCnt</span> <span class="p">{</span>
					<span class="nx">dst</span><span class="p">.</span><span class="nx">b</span> <span class="p">=</span> <span class="nx">h</span><span class="p">.</span><span class="nf">newoverflow</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">dst</span><span class="p">.</span><span class="nx">b</span><span class="p">)</span>
					<span class="nx">dst</span><span class="p">.</span><span class="nx">i</span> <span class="p">=</span> <span class="mi">0</span>
					<span class="nx">dst</span><span class="p">.</span><span class="nx">k</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">dst</span><span class="p">.</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="p">)</span>
					<span class="nx">dst</span><span class="p">.</span><span class="nx">e</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">dst</span><span class="p">.</span><span class="nx">k</span><span class="p">,</span> <span class="nx">bucketCnt</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">))</span>
				<span class="p">}</span>
				<span class="nx">dst</span><span class="p">.</span><span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">dst</span><span class="p">.</span><span class="nx">i</span><span class="o">&amp;</span><span class="p">(</span><span class="nx">bucketCnt</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span> <span class="p">=</span> <span class="nx">top</span>  
				<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">indirectkey</span><span class="p">()</span> <span class="p">{</span>
					<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">dst</span><span class="p">.</span><span class="nx">k</span><span class="p">)</span> <span class="p">=</span> <span class="nx">k2</span> 
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="nf">typedmemmove</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">,</span> <span class="nx">dst</span><span class="p">.</span><span class="nx">k</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span>  
				<span class="p">}</span>
				<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">indirectelem</span><span class="p">()</span> <span class="p">{</span>
					<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">dst</span><span class="p">.</span><span class="nx">e</span><span class="p">)</span> <span class="p">=</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">e</span><span class="p">)</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="nf">typedmemmove</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">elem</span><span class="p">,</span> <span class="nx">dst</span><span class="p">.</span><span class="nx">e</span><span class="p">,</span> <span class="nx">e</span><span class="p">)</span>
        <span class="p">}</span>
				<span class="nx">dst</span><span class="p">.</span><span class="nx">i</span><span class="o">++</span>
				<span class="nx">dst</span><span class="p">.</span><span class="nx">k</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">dst</span><span class="p">.</span><span class="nx">k</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">))</span>
				<span class="nx">dst</span><span class="p">.</span><span class="nx">e</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">dst</span><span class="p">.</span><span class="nx">e</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">elemsize</span><span class="p">))</span>
        <span class="c1">// 结束
</span><span class="c1"></span>        <span class="c1">// 从开始到结束这一块的代码大概意思就是找到搬到的目标是xy[0]还是xy[1]
</span><span class="c1"></span>        <span class="c1">// 如果是等量扩容则默认放到xy[0]桶里
</span><span class="c1"></span>        <span class="c1">// 然后如果不是等量扩容，可能会重新计算该key的tophash的值
</span><span class="c1"></span>        <span class="c1">// 然后把key value，和tophash 复制到xy[0]或xy[1]的对应位置
</span><span class="c1"></span>        <span class="c1">// 然后继续循环直到整个bmap及其溢出bmap被搬迁完
</span><span class="c1"></span>			<span class="p">}</span>
		<span class="p">}</span>
    <span class="c1">// 把搬完了的旧桶做一些标记以便等待gc清除
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">flags</span><span class="o">&amp;</span><span class="nx">oldIterator</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">t</span><span class="p">.</span><span class="nx">bucket</span><span class="p">.</span><span class="nx">ptrdata</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">b</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">oldbuckets</span><span class="p">,</span> <span class="nx">oldbucket</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">))</span>
			<span class="nx">ptr</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="nx">dataOffset</span><span class="p">)</span>
			<span class="nx">n</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)</span> <span class="o">-</span> <span class="nx">dataOffset</span>
			<span class="nf">memclrHasPointers</span><span class="p">(</span><span class="nx">ptr</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
  <span class="c1">// 如果此次搬迁是按照 h.nevacuate的搬迁则
</span><span class="c1"></span>	<span class="c1">// 做个标记，代表下一次要搬迁的桶是哪个
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">oldbucket</span> <span class="o">==</span> <span class="nx">h</span><span class="p">.</span><span class="nx">nevacuate</span> <span class="p">{</span>
		<span class="nf">advanceEvacuationMark</span><span class="p">(</span><span class="nx">h</span><span class="p">,</span> <span class="nx">t</span><span class="p">,</span> <span class="nx">newbit</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></div><h6 id="map扩容过程的总结">Map扩容过程的总结</h6>
<ol>
<li>当装载因子&gt;=6.5或者溢出bmap过多时，会产生扩容</li>
<li>如果是装载因子&gt;=6.5的扩容则为翻倍扩容，创建一个比当前桶个数*2的桶列表，如果溢出桶过多但装载因子&lt;6.5时为等量扩容，即把当前稀疏的桶内元素进行整理，使其没有那么多的溢出桶。</li>
<li>然后会把当前的桶放到hmap.oldbuckets字段作为旧桶，然后把当前的溢出桶（如果有）也放到hmap.extra.oldoverflow作为旧的溢出桶。</li>
<li>在扩容时不会触发搬迁操作，搬迁操作只会在写入/删除操作时被触发。</li>
<li>搬迁操作过程：
<ol>
<li>翻倍扩容搬迁过程：
<ol>
<li>找到当前key的hash对应的旧桶然后算出对应的新桶保存其上下文xy[0]，再找到一个根据当前新桶+旧桶数量偏移的哪个桶xy[1]，也保存其上下文。比如当前key的哈希对应的旧桶是3号，那么xy[0]也是新桶的3号桶，然后xy[1]的桶号就为3+旧桶的个数、比如7号。</li>
<li>由于翻倍扩容时当前旧桶对应两个新桶，所以需要针对当前旧桶中的key做重新hash，选择一个目标桶出来，即当前key处于3号桶，经过重新哈希后可能放到了7号桶，找到目标桶后，将对应的key，value，tophash复制过去，完成一个key-value的搬迁。然后循环此过程。</li>
</ol>
</li>
<li>等量扩容搬迁过程：
<ol>
<li>与翻倍扩容相同，但只保存一个新桶的上下文，因为等量扩容没有创建更多的桶，扩容是对应的关系，即当前的key处于3号桶，搬迁后也属于3号桶。</li>
<li>剩余过程与翻倍扩容相同。</li>
</ol>
</li>
<li>搬迁完毕后，将旧桶做一些标记以便可以gc清除，然后如果此次搬迁是按照顺序搬迁，即 h.nevacuate记录的桶搬迁的，则更新 h.nevacuate到下次应该搬迁的桶上。</li>
</ol>
</li>
</ol>
<h5 id="map的删除解析">Map的删除解析</h5>
<p>接下来来解析一下关于Map的删除，首先还是根据上面的代码去输出汇编代码看看删除的时候到底发生了什么？</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">        <span class="mh">0x0108</span> <span class="mo">00264</span>   <span class="nx">CALL</span>    <span class="nx">runtime</span><span class="p">.</span><span class="nf">mapdelete_fast64</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>

</code></pre></div><p>上述汇编代码看出，再向Map中删除数据的时候调用了runtime.mapdelete_fast64()函数，但是作者并没有在runtime.map.go文件中找到相对应的函数，根据网上其他一些文章得知，最终的写入时的函数调用都会调用到runtime.mapdelete()中，那么，接下来我们就开始讲一下关于runtime.mapdelete()函数的一些逻辑的代码解析：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">
<span class="kd">func</span> <span class="nf">mapdelete</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">key</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="p">{</span>
	 <span class="c1">// 如果map是nil或者没有元素则直接返回
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">h</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nx">h</span><span class="p">.</span><span class="nx">count</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="c1">// 好像是针对类型的错误校验
</span><span class="c1"></span>    <span class="c1">// 具体可以看issue 23734
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">hashMightPanic</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">t</span><span class="p">.</span><span class="nf">hasher</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>  
		<span class="p">}</span>
		<span class="k">return</span>
	<span class="p">}</span>
  <span class="c1">// 不能并发写！
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">flags</span><span class="o">&amp;</span><span class="nx">hashWriting</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;concurrent map writes&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 算出key的对应的hash
</span><span class="c1"></span>	<span class="nx">hash</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">hasher</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">hash0</span><span class="p">))</span>

	<span class="c1">// 做写标记
</span><span class="c1"></span>	<span class="nx">h</span><span class="p">.</span><span class="nx">flags</span> <span class="p">^=</span> <span class="nx">hashWriting</span>
	<span class="c1">// 选 桶
</span><span class="c1"></span>	<span class="nx">bucket</span> <span class="o">:=</span> <span class="nx">hash</span> <span class="o">&amp;</span> <span class="nf">bucketMask</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span>
  <span class="c1">// 如果正在进行扩容
</span><span class="c1"></span>  <span class="c1">// 那就进行搬迁
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nf">growing</span><span class="p">()</span> <span class="p">{</span>
		<span class="nf">growWork</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">bucket</span><span class="p">)</span>
	<span class="p">}</span>
  <span class="c1">// 找到那个bmap
</span><span class="c1"></span>	<span class="nx">b</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span><span class="p">,</span> <span class="nx">bucket</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span>
	<span class="nx">bOrig</span> <span class="o">:=</span> <span class="nx">b</span>
  <span class="c1">// 算出tophash
</span><span class="c1"></span>	<span class="nx">top</span> <span class="o">:=</span> <span class="nf">tophash</span><span class="p">(</span><span class="nx">hash</span><span class="p">)</span>
<span class="nx">search</span><span class="p">:</span>
  <span class="c1">// 循环遍历选中的那个桶及其溢出桶
</span><span class="c1"></span>	<span class="k">for</span> <span class="p">;</span> <span class="nx">b</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="nx">b</span> <span class="p">=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">overflow</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 遍历每个溢出桶的tophash进行快速比对
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">bucketCnt</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">top</span> <span class="p">{</span>
          <span class="c1">// 如果 b.tophash[i] == emptyRest 
</span><span class="c1"></span>        <span class="c1">// 代表后续的b.tophash没有 溢出bmap或者可遍历的b.tophash了
</span><span class="c1"></span>				<span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="nx">emptyRest</span> <span class="p">{</span>
					<span class="k">break</span> <span class="nx">search</span>
				<span class="p">}</span>
				<span class="k">continue</span>
			<span class="p">}</span>
      <span class="c1">// 有相等的tophash
</span><span class="c1"></span>      <span class="c1">// 就算出对应k的位置
</span><span class="c1"></span>			<span class="nx">k</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nx">i</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">))</span>
			<span class="nx">k2</span> <span class="o">:=</span> <span class="nx">k</span>
			<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">indirectkey</span><span class="p">()</span> <span class="p">{</span>
				<span class="nx">k2</span> <span class="p">=</span> <span class="o">*</span><span class="p">((</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">k2</span><span class="p">))</span>
			<span class="p">}</span>
      <span class="c1">// 比对key和要删除的key是否相等
</span><span class="c1"></span>			<span class="k">if</span> <span class="p">!</span><span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">.</span><span class="nf">equal</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">k2</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">continue</span>
			<span class="p">}</span>
 			<span class="c1">// 如果key是个指针 进行清空操作
</span><span class="c1"></span>      <span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">indirectkey</span><span class="p">()</span> <span class="p">{</span>
				<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">k</span><span class="p">)</span> <span class="p">=</span> <span class="kc">nil</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">.</span><span class="nx">ptrdata</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nf">memclrHasPointers</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span>
			<span class="p">}</span>
      <span class="c1">// 算出key对应的value的地址
</span><span class="c1"></span>			<span class="nx">e</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nx">bucketCnt</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">)</span><span class="o">+</span><span class="nx">i</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">elemsize</span><span class="p">))</span>
      <span class="c1">// 跟key一样如果是指针就清空它
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">indirectelem</span><span class="p">()</span> <span class="p">{</span>
				<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">e</span><span class="p">)</span> <span class="p">=</span> <span class="kc">nil</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">elem</span><span class="p">.</span><span class="nx">ptrdata</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nf">memclrHasPointers</span><span class="p">(</span><span class="nx">e</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">elem</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="nf">memclrNoHeapPointers</span><span class="p">(</span><span class="nx">e</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">elem</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span>
			<span class="p">}</span>
      <span class="c1">// 标记这个tophash 是一个空的
</span><span class="c1"></span>			<span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">emptyOne</span>
			<span class="c1">// 开始
</span><span class="c1"></span>      <span class="k">if</span> <span class="nx">i</span> <span class="o">==</span> <span class="nx">bucketCnt</span><span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
				<span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nf">overflow</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">b</span><span class="p">.</span><span class="nf">overflow</span><span class="p">(</span><span class="nx">t</span><span class="p">).</span><span class="nx">tophash</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">emptyRest</span> <span class="p">{</span>
					<span class="k">goto</span> <span class="nx">notLast</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">emptyRest</span> <span class="p">{</span>
					<span class="k">goto</span> <span class="nx">notLast</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">for</span> <span class="p">{</span>
				<span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">emptyRest</span>
				<span class="k">if</span> <span class="nx">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
					<span class="k">if</span> <span class="nx">b</span> <span class="o">==</span> <span class="nx">bOrig</span> <span class="p">{</span>
						<span class="k">break</span>  
					<span class="p">}</span>
					<span class="nx">c</span> <span class="o">:=</span> <span class="nx">b</span>
					<span class="k">for</span> <span class="nx">b</span> <span class="p">=</span> <span class="nx">bOrig</span><span class="p">;</span> <span class="nx">b</span><span class="p">.</span><span class="nf">overflow</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="o">!=</span> <span class="nx">c</span><span class="p">;</span> <span class="nx">b</span> <span class="p">=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">overflow</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
					<span class="p">}</span>
					<span class="nx">i</span> <span class="p">=</span> <span class="nx">bucketCnt</span> <span class="o">-</span> <span class="mi">1</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="nx">i</span><span class="o">--</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">emptyOne</span> <span class="p">{</span>
					<span class="k">break</span>
				<span class="p">}</span>
			<span class="p">}</span>
      <span class="c1">// 结束 
</span><span class="c1"></span>      <span class="c1">// 从开始到结束的意义是
</span><span class="c1"></span>      <span class="c1">// 如果当前桶现在以一堆 emptyOne 状态结束，就把这些状态改为 emptyRest 状态。
</span><span class="c1"></span>		<span class="nx">notLast</span><span class="p">:</span>
      <span class="c1">// 当前元素数量-1
</span><span class="c1"></span>			<span class="nx">h</span><span class="p">.</span><span class="nx">count</span><span class="o">--</span>
			<span class="k">break</span> <span class="nx">search</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">// 再次校验是否并发写
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">flags</span><span class="o">&amp;</span><span class="nx">hashWriting</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;concurrent map writes&#34;</span><span class="p">)</span>
	<span class="p">}</span>
  <span class="c1">// 取消写标记
</span><span class="c1"></span>	<span class="nx">h</span><span class="p">.</span><span class="nx">flags</span> <span class="o">&amp;^=</span> <span class="nx">hashWriting</span>
<span class="p">}</span>
</code></pre></div><h6 id="map删除过程的总结">Map删除过程的总结</h6>
<p>总的来说删除过程和写入过程没啥区别，只是触发哈希的删除需要使用关键字不同，如果在删除期间遇到了哈希表的扩容，就会分流桶中的元素，分流结束之后会找到桶中的目标元素完成键值对的删除工作。</p>
<h4 id="map的读取">Map的读取</h4>
<p>说完了写入和删除操作，接下来该说一下Map的读取操作了，读取操作再Go中分为三种形式，接下来看一下代码示例：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">m</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span>
		<span class="mi">1</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
		<span class="mi">2</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
		<span class="mi">3</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
	<span class="p">}</span>

	<span class="nx">value</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
	<span class="nx">value</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
	<span class="k">for</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">value</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">m</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>首先初始化了一个哈希表m，然后对其进行读取值，我们先来看看前两种，因为其实际的代码都差不多，首先第二个是返回了两个值，第二个值（即ok）代表当没有找到这个key的时候返回false，否则返回true。</p>
<p>接下来看一下这两种形式在汇编上有什么区别：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">        <span class="mh">0x01e0</span> <span class="mo">004</span><span class="mi">80</span>      <span class="nx">CALL</span>    <span class="nx">runtime</span><span class="p">.</span><span class="nf">mapaccess1_fast64</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
        <span class="mh">0x0213</span> <span class="mo">00531</span>      <span class="nx">CALL</span>    <span class="nx">runtime</span><span class="p">.</span><span class="nf">mapaccess2_fast64</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
</code></pre></div><p>上面的汇编依旧不同，但是区别也很小，一个是runtime.mapaccess1另一个是runtime.mapaccess2，有啥区别呢？在源代码里发现，这两个函数的代码实现没有区别，区别在于runtime.mapaccess2多返回了一个bool值用于标记是否查询到了数据，那么接下来我们就对runtime.mapaccess2就行代码解析：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">mapaccess2</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">key</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	 <span class="c1">// 如果map是nil或者没有元素则
</span><span class="c1"></span>  <span class="c1">// 返回对应类型的零值和false
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">h</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nx">h</span><span class="p">.</span><span class="nx">count</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="c1">// 同写入
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">hashMightPanic</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">t</span><span class="p">.</span><span class="nf">hasher</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> 
		<span class="p">}</span>
 		<span class="k">return</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">zeroVal</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="kc">false</span>
	<span class="p">}</span>
  <span class="c1">// 检查是否有正在写入
</span><span class="c1"></span>  <span class="c1">// 不能并发写
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">flags</span><span class="o">&amp;</span><span class="nx">hashWriting</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;concurrent map read and map write&#34;</span><span class="p">)</span>
	<span class="p">}</span>
  <span class="c1">// 算出哈希
</span><span class="c1"></span>	<span class="nx">hash</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">hasher</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">hash0</span><span class="p">))</span>
	<span class="nx">m</span> <span class="o">:=</span> <span class="nf">bucketMask</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span>
  <span class="c1">// 找到哈希的低B位的对应的桶
</span><span class="c1"></span>	<span class="nx">b</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="nx">hash</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">)</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span>
  <span class="c1">// 如果此时处于扩容状态
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">c</span> <span class="o">:=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">oldbuckets</span><span class="p">;</span> <span class="nx">c</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="c1">// 那么就去旧桶找
</span><span class="c1"></span>    <span class="c1">// 如果此时是翻倍扩容
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">!</span><span class="nx">h</span><span class="p">.</span><span class="nf">sameSizeGrow</span><span class="p">()</span> <span class="p">{</span>
      <span class="c1">// 因为旧桶是当前桶的一半所以需要把当前的桶/2
</span><span class="c1"></span>			<span class="nx">m</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span>
		<span class="p">}</span>
    <span class="c1">// 找到在旧桶里面对应的那个桶
</span><span class="c1"></span>		<span class="nx">oldb</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="nx">hash</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">)</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span>
    <span class="c1">// 如果这桶没被搬走
</span><span class="c1"></span>    <span class="c1">// 那就遍历这个旧桶
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">!</span><span class="nf">evacuated</span><span class="p">(</span><span class="nx">oldb</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">b</span> <span class="p">=</span> <span class="nx">oldb</span>
		<span class="p">}</span>
	<span class="p">}</span>
  <span class="c1">// 算出高八位
</span><span class="c1"></span>	<span class="nx">top</span> <span class="o">:=</span> <span class="nf">tophash</span><span class="p">(</span><span class="nx">hash</span><span class="p">)</span>
<span class="nx">bucketloop</span><span class="p">:</span>
  <span class="c1">// 遍历桶和其溢出桶
</span><span class="c1"></span>	<span class="k">for</span> <span class="p">;</span> <span class="nx">b</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="nx">b</span> <span class="p">=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">overflow</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 遍历tophash
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">bucketCnt</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">top</span> <span class="p">{</span>
				<span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="nx">emptyRest</span> <span class="p">{</span>
					<span class="k">break</span> <span class="nx">bucketloop</span>
				<span class="p">}</span>
				<span class="k">continue</span>
			<span class="p">}</span>
			<span class="nx">k</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nx">i</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">))</span>
			<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">indirectkey</span><span class="p">()</span> <span class="p">{</span>
				<span class="nx">k</span> <span class="p">=</span> <span class="o">*</span><span class="p">((</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">k</span><span class="p">))</span>
			<span class="p">}</span>
      <span class="c1">// 找到了！
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">.</span><span class="nf">equal</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 算出key对应的value
</span><span class="c1"></span>				<span class="nx">e</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nx">bucketCnt</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">)</span><span class="o">+</span><span class="nx">i</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">elemsize</span><span class="p">))</span>
				<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">indirectelem</span><span class="p">()</span> <span class="p">{</span>
					<span class="nx">e</span> <span class="p">=</span> <span class="o">*</span><span class="p">((</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">e</span><span class="p">))</span>
				<span class="p">}</span>
        <span class="c1">// 返回！
</span><span class="c1"></span>				<span class="k">return</span> <span class="nx">e</span><span class="p">,</span> <span class="kc">true</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
  <span class="c1">//到这了就说明没找到
</span><span class="c1"></span>    <span class="c1">// 返回对应类型的零值和false
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">zeroVal</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="kc">false</span>
<span class="p">}</span>

</code></pre></div><h6 id="map读取的总结">Map读取的总结</h6>
<p>其实map的读取没什么可说的大概就是以下几步：</p>
<ol>
<li>nil的Map或者len==0的Map直接返回对应类型零值</li>
<li>如果当前处于翻倍扩容状态且当前key的hash对应的桶还没搬迁完，那么就在旧桶里找对应的那个桶去找对应的key-value</li>
<li>跟写入一样 遍历桶及其溢出桶</li>
<li>找到了返回值，没找到返回返回对应类型零值</li>
</ol>
<h2 id="总结-1">总结</h2>
<p>经过上面的一堆长篇大论，Map的相关东西都已经大概齐的讲完了，还差Map的遍历和清空，但是这两个我打算在未来某天写Range的时候去讲（挖坑，啥时候填不一定），反正大概齐就是这么回事，目前Map主要的坑还是在并发读写的问题上，源代码中也能看得出，对并发读写都做了panic处理，那么如何避免并发读写或者使得Map可以并发的使用，请看我的这篇文章 <a href="https://blog.csdn.net/qq_37005831/article/details/111815704">《「Golang」并发场景下的Map使用方式及避坑指南》</a></p>
<p>由于我这人不喜欢审稿，写完了就写完了，上面的一些语句或者词汇可能并不是很通顺或者有语病，请各位指出，在此感谢各位，同时也感谢各位能够阅读本篇文章，如果能带给你一些收获是我的荣幸，同时希望能指出文章中的一些问题，或者各位看官的一些见解，让我们一同学习，再次感谢各位！</p>
]]></content>
		</item>
		
		<item>
			<title>「Golang」 通道源码解析</title>
			<link>http://echoblog.cc/posts/golangchannel%E8%A7%A3%E6%9E%90/</link>
			<pubDate>Wed, 20 Jan 2021 00:00:00 +0000</pubDate>
			
			<guid>http://echoblog.cc/posts/golangchannel%E8%A7%A3%E6%9E%90/</guid>
			<description>[TOC]
通道描述 通道（Channel/Chan）是在golang并发编程中用的最多的一个数据结构（也可以说是基础类型），在go中，作者在并发编程的环境下对于数据之间的共享提出了一个建议，也是go的经典开发准则：
 Do not communicate by sharing memory; instead, share memory by communicating. 不要通过共享内存来通信，而应该通过通信来共享内存
 在通信方面，通道给我们提供了一个很好的在并发编程环境中进行多Goroutine之间的数据共享。那么本篇文章就来解析一下通道在go中的源代码是如何实现的。
通道相关结构体解析 本篇文章所有的源代码数据均采用go1.15.5版本，如果和您的源代码不相同，建议更换1.15.5版本。
接下来我将根据通道的结构与其相关常量来进行解析，通道的源代码文件在 runtime/chan.go 路径下。
 (前方高能，代码巨长，请各位准备好瓜子饮料矿泉水耐心观看)
 type hchan struct { qcount uint // 队列中有多少数据，即len时获得的值 	dataqsiz uint // chan 是一个循环队列，这个字段代表这个循环队列的总大小，即cap时获取的值 	buf unsafe.Pointer // 指向数组的指针，这个循环队列时靠数组实现的 	elemsize uint16 // 每个元素的size，做为偏移使用 	closed uint32 // 这个chan 是否关闭的标记 	elemtype *_type // 构建chan时候的元素类型  // 这个索引是用于做地址偏移的而不是像数组一样的下标 	sendx uint // 发送索引 即当前发送到哪了 	recvx uint // 接收索引 	recvq waitq // 被阻塞的接收g的列表 	sendq waitq // 被阻塞的发送g的列表  // 一个锁 防止修改结构体中内容以及 waitq中的内容 	lock mutex } type waitq struct { first *sudog // 队列头 sudog是一个存有等待g相关信息的结构体 	last *sudog // 队列尾 sudog是一个存有等待g相关信息的结构体 } 构建通道操作 func makechan64(t *chantype, size int64) *hchan { // 应该是判断当前系统是不是64位系统，因为int的长度会随着系统长度改变而改变 	// 32位系统中 int 相当于int32 64位中 int相当于int64 	if int64(int(size)) !</description>
			<content type="html"><![CDATA[<p>[TOC]</p>
<h2 id="通道描述">通道描述</h2>
<p>通道（Channel/Chan）是在golang并发编程中用的最多的一个数据结构（也可以说是基础类型），在go中，作者在并发编程的环境下对于数据之间的共享提出了一个建议，也是go的经典开发准则：</p>
<blockquote>
<p>Do not communicate by sharing memory; instead, share memory by communicating.
不要通过共享内存来通信，而应该通过通信来共享内存</p>
</blockquote>
<p>在通信方面，通道给我们提供了一个很好的在并发编程环境中进行多Goroutine之间的数据共享。那么本篇文章就来解析一下通道在go中的源代码是如何实现的。</p>
<h2 id="通道相关结构体解析">通道相关结构体解析</h2>
<p>本篇文章所有的源代码数据均采用<strong>go1.15.5</strong>版本，如果和您的源代码不相同，建议更换1.15.5版本。</p>
<p>接下来我将根据通道的结构与其相关常量来进行解析，通道的源代码文件在 <strong>runtime/chan.go</strong> 路径下。</p>
<blockquote>
<p>(前方高能，代码巨长，请各位准备好瓜子饮料矿泉水耐心观看)</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">hchan</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">qcount</span>   <span class="kt">uint</span>           <span class="c1">// 队列中有多少数据，即len时获得的值
</span><span class="c1"></span>	<span class="nx">dataqsiz</span> <span class="kt">uint</span>           <span class="c1">// chan 是一个循环队列，这个字段代表这个循环队列的总大小，即cap时获取的值
</span><span class="c1"></span>	<span class="nx">buf</span>      <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// 指向数组的指针，这个循环队列时靠数组实现的
</span><span class="c1"></span>	<span class="nx">elemsize</span> <span class="kt">uint16</span> <span class="c1">// 每个元素的size，做为偏移使用
</span><span class="c1"></span>	<span class="nx">closed</span>   <span class="kt">uint32</span> <span class="c1">// 这个chan 是否关闭的标记
</span><span class="c1"></span>	<span class="nx">elemtype</span> <span class="o">*</span><span class="nx">_type</span> <span class="c1">// 构建chan时候的元素类型
</span><span class="c1"></span>  <span class="c1">// 这个索引是用于做地址偏移的而不是像数组一样的下标
</span><span class="c1"></span>	<span class="nx">sendx</span>    <span class="kt">uint</span>   <span class="c1">// 发送索引 即当前发送到哪了
</span><span class="c1"></span>	<span class="nx">recvx</span>    <span class="kt">uint</span>   <span class="c1">// 接收索引
</span><span class="c1"></span>	<span class="nx">recvq</span>    <span class="nx">waitq</span>  <span class="c1">// 被阻塞的接收g的列表 
</span><span class="c1"></span>	<span class="nx">sendq</span>    <span class="nx">waitq</span>  <span class="c1">// 被阻塞的发送g的列表
</span><span class="c1"></span>
	<span class="c1">// 一个锁 防止修改结构体中内容以及 waitq中的内容
</span><span class="c1"></span>	<span class="nx">lock</span> <span class="nx">mutex</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">waitq</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">first</span> <span class="o">*</span><span class="nx">sudog</span> <span class="c1">// 队列头 sudog是一个存有等待g相关信息的结构体
</span><span class="c1"></span>	<span class="nx">last</span>  <span class="o">*</span><span class="nx">sudog</span> <span class="c1">// 队列尾 sudog是一个存有等待g相关信息的结构体
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><h2 id="构建通道操作">构建通道操作</h2>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">makechan64</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">chantype</span><span class="p">,</span> <span class="nx">size</span> <span class="kt">int64</span><span class="p">)</span> <span class="o">*</span><span class="nx">hchan</span> <span class="p">{</span>
	<span class="c1">// 应该是判断当前系统是不是64位系统，因为int的长度会随着系统长度改变而改变
</span><span class="c1"></span>	<span class="c1">// 32位系统中 int 相当于int32 64位中 int相当于int64
</span><span class="c1"></span>	<span class="k">if</span> <span class="nb">int64</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nx">size</span><span class="p">))</span> <span class="o">!=</span> <span class="nx">size</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nf">plainError</span><span class="p">(</span><span class="s">&#34;makechan: size out of range&#34;</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="c1">// 调用构建chan的函数，实际上就是make（chan type）时
</span><span class="c1"></span>	<span class="c1">// 由runtime调用的makechan64
</span><span class="c1"></span>	<span class="k">return</span> <span class="nf">makechan</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="nx">size</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">makechan</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">chantype</span><span class="p">,</span> <span class="nx">size</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">hchan</span> <span class="p">{</span>
	<span class="c1">// chantype 代表着make(chan xxx)时的xxx的类型
</span><span class="c1"></span>	<span class="nx">elem</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">elem</span>
	
	<span class="c1">// 检查一下类型的一些信息
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">elem</span><span class="p">.</span><span class="nx">size</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">16</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;makechan: invalid channel element type&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">hchanSize</span><span class="o">%</span><span class="nx">maxAlign</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">elem</span><span class="p">.</span><span class="nx">align</span> <span class="p">&gt;</span> <span class="nx">maxAlign</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;makechan: bad alignment&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 检查元素的长度和要构建的chan的长度是否会造成内存溢出
</span><span class="c1"></span>	<span class="nx">mem</span><span class="p">,</span> <span class="nx">overflow</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nf">MulUintptr</span><span class="p">(</span><span class="nx">elem</span><span class="p">.</span><span class="nx">size</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">size</span><span class="p">))</span>
	<span class="k">if</span> <span class="nx">overflow</span> <span class="o">||</span> <span class="nx">mem</span> <span class="p">&gt;</span> <span class="nx">maxAlloc</span><span class="o">-</span><span class="nx">hchanSize</span> <span class="o">||</span> <span class="nx">size</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nf">plainError</span><span class="p">(</span><span class="s">&#34;makechan: size out of range&#34;</span><span class="p">))</span>
	<span class="p">}</span>

 	<span class="c1">// 初始化一个chan结构体指针
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">c</span> <span class="o">*</span><span class="nx">hchan</span>
	<span class="k">switch</span> <span class="p">{</span>
	<span class="c1">// 如果mem等于0 则代表make长度为0即 make(chan type)
</span><span class="c1"></span>	<span class="c1">// 或者元素的大小为0 即 make(chan struct{},10)
</span><span class="c1"></span>	<span class="k">case</span> <span class="nx">mem</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
		<span class="c1">// 当队列的长度为0或者元素的大小为0时，分配一个固定长度的内存地址
</span><span class="c1"></span>		<span class="nx">c</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">hchan</span><span class="p">)(</span><span class="nf">mallocgc</span><span class="p">(</span><span class="nx">hchanSize</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">true</span><span class="p">))</span>
		<span class="c1">// 做一下地址同步，防止未来访问地址是会与qcount。dataqsiz和closed字段产生冲突
</span><span class="c1"></span>		<span class="c1">// 此处存疑，如果说错了求大佬指正
</span><span class="c1"></span>		<span class="nx">c</span><span class="p">.</span><span class="nx">buf</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">raceaddr</span><span class="p">()</span>
	<span class="c1">// 代表make的元素类型不是个指针
</span><span class="c1"></span>	<span class="k">case</span> <span class="nx">elem</span><span class="p">.</span><span class="nx">ptrdata</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
		<span class="c1">// 当元素类型不是指针 就一次性分配了整个make时选择类型的内存
</span><span class="c1"></span>		<span class="nx">c</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">hchan</span><span class="p">)(</span><span class="nf">mallocgc</span><span class="p">(</span><span class="nx">hchanSize</span><span class="o">+</span><span class="nx">mem</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">true</span><span class="p">))</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">buf</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">c</span><span class="p">),</span> <span class="nx">hchanSize</span><span class="p">)</span>
	<span class="k">default</span><span class="p">:</span>
		<span class="c1">// 如果元素要是个指针。那就分配一个men的长度的elem类型的内存，
</span><span class="c1"></span>		<span class="nx">c</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">hchan</span><span class="p">)</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">buf</span> <span class="p">=</span> <span class="nf">mallocgc</span><span class="p">(</span><span class="nx">mem</span><span class="p">,</span> <span class="nx">elem</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 一些基本赋值
</span><span class="c1"></span>	<span class="nx">c</span><span class="p">.</span><span class="nx">elemsize</span> <span class="p">=</span> <span class="nb">uint16</span><span class="p">(</span><span class="nx">elem</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span> <span class="p">=</span> <span class="nx">elem</span>
	<span class="c1">// chan的容量
</span><span class="c1"></span>	<span class="nx">c</span><span class="p">.</span><span class="nx">dataqsiz</span> <span class="p">=</span> <span class="nb">uint</span><span class="p">(</span><span class="nx">size</span><span class="p">)</span>
	<span class="nf">lockInit</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">,</span> <span class="nx">lockRankHchan</span><span class="p">)</span>

	<span class="k">if</span> <span class="nx">debugChan</span> <span class="p">{</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;makechan: chan=&#34;</span><span class="p">,</span> <span class="nx">c</span><span class="p">,</span> <span class="s">&#34;; elemsize=&#34;</span><span class="p">,</span> <span class="nx">elem</span><span class="p">.</span><span class="nx">size</span><span class="p">,</span> <span class="s">&#34;; dataqsiz=&#34;</span><span class="p">,</span> <span class="nx">size</span><span class="p">,</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">c</span>
<span class="p">}</span>
</code></pre></div><p>构建一个通道的源代码部分已经写了一些注释，接下来做一个总结：</p>
<ol>
<li>程序在编译期间侦测到make(chan type,len )时，会将其替换成为
<code>func makechan(t *chantype, size int64) *hchan</code> ，我使用下列代码为大家呈现此调用在汇编中的样子。</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">a</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">string</span><span class="p">,</span> <span class="mi">998</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>其汇编代码输出为：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">	<span class="mh">0x0021</span> <span class="mo">00033</span>  	<span class="nx">LEAQ</span>	<span class="kd">type</span><span class="p">.</span><span class="kd">chan</span> <span class="nb">string</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">AX</span>
	<span class="mh">0x0028</span> <span class="mo">00040</span>  	<span class="nx">MOVQ</span>	<span class="nx">AX</span><span class="p">,</span> <span class="p">(</span><span class="nx">SP</span><span class="p">)</span>
	<span class="mh">0x002c</span> <span class="mo">00044</span> 		<span class="nx">MOVQ</span>	<span class="err">$</span><span class="mi">998</span><span class="p">,</span> <span class="mi">8</span><span class="p">(</span><span class="nx">SP</span><span class="p">)</span>
	<span class="mh">0x0035</span> <span class="mo">00053</span> 		<span class="nx">PCDATA</span>	<span class="err">$</span><span class="mi">1</span><span class="p">,</span> <span class="err">$</span><span class="mi">0</span>
	<span class="mh">0x0035</span> <span class="mo">00053</span>  	<span class="nx">CALL</span>	<span class="nx">runtime</span><span class="p">.</span><span class="nf">makechan</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
	<span class="mh">0x003a</span> <span class="mo">0005</span><span class="mi">8</span> 		<span class="nx">MOVQ</span>	<span class="mi">16</span><span class="p">(</span><span class="nx">SP</span><span class="p">),</span> <span class="nx">AX</span>
	<span class="mh">0x003f</span> <span class="mo">00063</span>  	<span class="nx">XORPS</span>	<span class="nx">X0</span><span class="p">,</span> <span class="nx">X0</span>
	<span class="mh">0x0042</span> <span class="mo">00066</span>  	<span class="nx">MOVUPS</span>	<span class="nx">X0</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">..</span><span class="nx">autotmp_13</span><span class="o">+</span><span class="mi">64</span><span class="p">(</span><span class="nx">SP</span><span class="p">)</span>
	<span class="mh">0x0047</span> <span class="mo">00071</span>  	<span class="nx">LEAQ</span>	<span class="kd">type</span><span class="p">.</span><span class="kd">chan</span> <span class="nb">string</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">CX</span>

</code></pre></div><p>因为go的汇编我不怎么熟，所以只提取部分汇编代码，上面汇编代码可以清楚的看出，第00044处，将998，放到了一个内存地址处此处998即make时chan的长度，第00053处，调用了runtime.makechan(SB)，代表将make(chan string, 998)转换为runtime.makechan(SB)调用</p>
<ol start="2">
<li>
<p>然后获取其要创建的chan的类型，首先判断该类型占用字节数是否大于2^16字节，<strong>即通道的类型size不能超过64kB</strong>，如果大于则代表此类型不符合创建的条件，会抛出panic。</p>
<p>（可以测试一下，构建一个下列代码，上面的就可以通过编译 下面就不可以）</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"> <span class="nx">a</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="p">[</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">16</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="kt">bool</span><span class="p">)</span>
     
 <span class="nx">a</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="p">[</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">16</span> <span class="p">]</span><span class="kt">bool</span><span class="p">)</span>
</code></pre></div></li>
<li>
<p>然后判断该类型该类型的对齐是否大于规定的<code>maxAlign</code>以及整体的hchan占用内存大小是否能整除<code>maxAlign</code></p>
</li>
<li>
<p>随后会判断该类型占用字节数与设定的make长度的乘积是否会溢出内存，如果溢出则会panic</p>
</li>
<li>
<p>然后会根据几个条件去做相应的内存分配：</p>
<ol>
<li>如果mem为0的话则代表类型的占用字节数为0，最典型的就是struct{} 空结构体类型，其不占用任何内存空间，或者make的长度为0，则要生成一个无缓冲的chan。此时则分配一个长度为<code>hchanSize</code>的内存空间。然后给c.buf做一下地址同步，因为其是不分配空间的，防止未来访问地址是会与qcount。dataqsiz和closed字段产生冲突（此处存疑，如果说错了求大佬指正） 。</li>
<li>如果类型不是一个指针类型的话，则直接一次性分配一个<code>hchanSize+mem</code>长度的顺序内存。然后把c.buf的起始位置设置到c的起始位置+hchanSize偏移的位置，也就是说分配的是一块内存但是分成两部分使用，一部分归hchan使用一部分归c.buf使用。</li>
<li>如果类型是一个指针类型，则直接分配一个符合类型指针长度的内存给c.buf。</li>
</ol>
</li>
<li>
<p>分配完内存之后就可以把相关数据信息设置到hchan结构体中了，包括设置类型占用字节数（为了做c.buf的偏移量方便依次访问)，还有类型，和hchan总的长度，即cap时的返回的长度。然后将锁初始化。</p>
</li>
<li>
<p>为什么要区分是否包含指针呢，官方给出了一个答案</p>
</li>
</ol>
<blockquote>
<pre><code>   Hchan does not contain pointers interesting for GC when elements stored in buf do not contain pointers.
</code></pre>
<p>也就是说，当类型不包含指针的时候，gc是不会去扫描并且回收的</p>
</blockquote>
<h2 id="通道的发送">通道的发送</h2>
<h3 id="发送代码解析">发送代码解析</h3>
<p>首先我们来讲一下通道的发送操作会在底层源代码处执行什么样的业务逻辑，废话不多说 show me code！</p>
<p>首先还是从会汇编阶段看一看对下面代码的编译会产生什么汇编代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">a</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="err">，</span><span class="mi">1</span><span class="p">)</span>
	<span class="nx">a</span> <span class="o">&lt;-</span> <span class="mi">1</span>
<span class="p">}</span>
</code></pre></div><p>我创建了一个有缓冲的通道并且向其发送了一个 1，运行下面的命令</p>
<blockquote>
<p>go build &ndash;gcflags=&quot;-N -l -S&quot; main.go</p>
</blockquote>
<p>我获得了一个未经过编译期优化的汇编代码</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">				<span class="mh">0x0035</span> <span class="mo">00053</span>      <span class="nx">CALL</span>    <span class="nx">runtime</span><span class="p">.</span><span class="nf">makechan</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
        <span class="o">...</span><span class="p">..</span>
        <span class="mh">0x0054</span> <span class="mo">000</span><span class="mi">84</span>      <span class="nx">CALL</span>    <span class="nx">runtime</span><span class="p">.</span><span class="nf">chansend1</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>

</code></pre></div><p>多余的我们不看，只看00053处调用runtime.makechan(SB)构建了一个通道，这和我们上面讲的通道的构建是相同的，随后去除中间我们不需要看到的代码看到00084处调用了runtime.chansend1(SB)，代表着向通道发送了一个数据。接下来我们看一下这个runtime.chansend1()的代码解析。</p>
<blockquote>
<p>(再次提醒，前方高能，代码巨长，请各位准备好瓜子饮料矿泉水耐心观看)</p>
<p>太长不爱看直接跳转 ：通道的发送总结</p>
<p>注：下面代码去掉了一些跟业务逻辑关系不大的代码</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"> <span class="c1">// 通道发送的入口函数，第一个参数是通道，第二个是发送数据的地址
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">chansend1</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">hchan</span><span class="p">,</span> <span class="nx">elem</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 调用发送函数，第三个参数true代表是否阻塞，true则为阻塞发送
</span><span class="c1"></span>  <span class="c1">// 最后一个参数是返回调用者的程序计数器和栈指针
</span><span class="c1"></span>  <span class="c1">// 不用关心第四个参数
</span><span class="c1"></span>	<span class="nf">chansend</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">elem</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="nf">getcallerpc</span><span class="p">())</span>
<span class="p">}</span>

 <span class="c1">// 真正的发送业务逻辑
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">chansend</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">hchan</span><span class="p">,</span> <span class="nx">ep</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">block</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">callerpc</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
  <span class="c1">// 如果要是当前通道为nil 并且是阻塞模式则直接永久阻塞
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">c</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="c1">// 如果为不阻塞发送则直接返回
</span><span class="c1"></span>    <span class="c1">// 当
</span><span class="c1"></span>    <span class="c1">// select {
</span><span class="c1"></span>    <span class="c1">// case channel&lt;-1:
</span><span class="c1"></span>    <span class="c1">// todo 
</span><span class="c1"></span>    <span class="c1">// default:
</span><span class="c1"></span>    <span class="c1">//   }
</span><span class="c1"></span>    <span class="c1">// 时会出现block == false的情况
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">!</span><span class="nx">block</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">false</span>
		<span class="p">}</span>
    <span class="c1">// 挂起当前协程
</span><span class="c1"></span>    <span class="c1">// 此时会永久阻塞，系统监控会直接抛出死锁
</span><span class="c1"></span>		<span class="nf">gopark</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">waitReasonChanSendNilChan</span><span class="p">,</span> <span class="nx">traceEvGoStop</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;unreachable&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 如果非阻塞并且还没关闭，并且通道还满了 直接返回
</span><span class="c1"></span>  <span class="c1">// 这个full需要说一下
</span><span class="c1"></span>  <span class="c1">// 这个函数会判断下面的条件返回
</span><span class="c1"></span>  <span class="c1">// 1。如果是无缓冲通道且没有接收端则返回true
</span><span class="c1"></span>  <span class="c1">// 2。如果是有缓冲通道 并且无可用缓冲区了 返回true
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">block</span> <span class="o">&amp;&amp;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">closed</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nf">full</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="c1">// 加锁 证明通道是一个有锁队列
</span><span class="c1"></span>	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="c1">// 对一个关闭了的通道发送会 panic
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">closed</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nf">plainError</span><span class="p">(</span><span class="s">&#34;send on closed channel&#34;</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="c1">// 如果当前存在一个接收端
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">sg</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvq</span><span class="p">.</span><span class="nf">dequeue</span><span class="p">();</span> <span class="nx">sg</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="c1">// 调用发送函数 然后解锁返回
</span><span class="c1"></span>		<span class="nf">send</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">sg</span><span class="p">,</span> <span class="nx">ep</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span> <span class="p">},</span> <span class="mi">3</span><span class="p">)</span>
		<span class="k">return</span> <span class="kc">true</span>
	<span class="p">}</span>
	<span class="c1">/// 如果当前缓冲区还有空余
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">qcount</span> <span class="p">&lt;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">dataqsiz</span> <span class="p">{</span>
    <span class="c1">// 找到当前发送索引所处位置的指针
</span><span class="c1"></span> 		<span class="nx">qp</span> <span class="o">:=</span> <span class="nf">chanbuf</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">sendx</span><span class="p">)</span>
		<span class="c1">// 把发送的元素复制过去
</span><span class="c1"></span>		<span class="nf">typedmemmove</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">qp</span><span class="p">,</span> <span class="nx">ep</span><span class="p">)</span>
    <span class="c1">// 发送索引+1
</span><span class="c1"></span>		<span class="nx">c</span><span class="p">.</span><span class="nx">sendx</span><span class="o">++</span>
    <span class="c1">// 因为底层是个环形队列，所以当索引==长度的时候，索引归0
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">sendx</span> <span class="o">==</span> <span class="nx">c</span><span class="p">.</span><span class="nx">dataqsiz</span> <span class="p">{</span>
			<span class="nx">c</span><span class="p">.</span><span class="nx">sendx</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="p">}</span>
    <span class="c1">// 当前元素数量+1 
</span><span class="c1"></span>		<span class="nx">c</span><span class="p">.</span><span class="nx">qcount</span><span class="o">++</span>
    <span class="c1">// 解锁
</span><span class="c1"></span>		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="k">return</span> <span class="kc">true</span>
	<span class="p">}</span>
	<span class="c1">// 此时就相当于缓冲区没有空余了
</span><span class="c1"></span>  <span class="c1">// 且非阻塞发送 那么 返回
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">block</span> <span class="p">{</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="c1">// 获取当前g  就是发送数据那个g
</span><span class="c1"></span>  <span class="c1">// 因为这个函数注释写的不大清楚，所以这个函数一直有疑问到底获取的是什么的g
</span><span class="c1"></span>  <span class="c1">// 根据官方某个文档给出的结果是
</span><span class="c1"></span>  <span class="c1">// `getg()` alone returns the current `g`, but when executing on the
</span><span class="c1"></span>	<span class="c1">// system or signal stacks, this will return the current M&#39;s &#34;g0&#34; or
</span><span class="c1"></span>	<span class="c1">// &#34;gsignal&#34;, respectively. 
</span><span class="c1"></span>  <span class="c1">// 翻译一下就是：
</span><span class="c1"></span>  <span class="c1">// `getg()`单独返回当前的`g`，但在系统或信号栈上执行时，
</span><span class="c1"></span>  <span class="c1">// 会分别返回当前M的 &#34;g0 &#34;或 &#34;gsignal&#34;。  
</span><span class="c1"></span> 	<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
  
  
  <span class="c1">// 开始
</span><span class="c1"></span>  <span class="c1">// 从开始到结束这一系列操作就是获取一个*sudog结构
</span><span class="c1"></span>  <span class="c1">// 这个结构放的是等待列表里的g的结构
</span><span class="c1"></span>  <span class="c1">// 然后设置一大堆的相关信息 比如发送元素的地址在哪，是不是在select里面
</span><span class="c1"></span>  <span class="c1">// 向哪个通道发送等等
</span><span class="c1"></span>  <span class="c1">// 在此不做赘述了
</span><span class="c1"></span>	<span class="nx">mysg</span> <span class="o">:=</span> <span class="nf">acquireSudog</span><span class="p">()</span>
	<span class="nx">mysg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="k">if</span> <span class="nx">t0</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">mysg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span>
	<span class="p">}</span>
	 
	<span class="nx">mysg</span><span class="p">.</span><span class="nx">elem</span> <span class="p">=</span> <span class="nx">ep</span>
	<span class="nx">mysg</span><span class="p">.</span><span class="nx">waitlink</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="nx">mysg</span><span class="p">.</span><span class="nx">g</span> <span class="p">=</span> <span class="nx">gp</span>
	<span class="nx">mysg</span><span class="p">.</span><span class="nx">isSelect</span> <span class="p">=</span> <span class="kc">false</span>
	<span class="nx">mysg</span><span class="p">.</span><span class="nx">c</span> <span class="p">=</span> <span class="nx">c</span>
  <span class="c1">// 把当前的g的等待设为mysg
</span><span class="c1"></span>  <span class="c1">// 代表当前g正在等待这个mysg
</span><span class="c1"></span>	<span class="nx">gp</span><span class="p">.</span><span class="nx">waiting</span> <span class="p">=</span> <span class="nx">mysg</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="p">=</span> <span class="kc">nil</span>
  <span class="c1">// 结束
</span><span class="c1"></span>  
  
  <span class="c1">// 把生成这个sudog放到发送等待队列里
</span><span class="c1"></span>	<span class="nx">c</span><span class="p">.</span><span class="nx">sendq</span><span class="p">.</span><span class="nf">enqueue</span><span class="p">(</span><span class="nx">mysg</span><span class="p">)</span>
	
  <span class="c1">// 栈内存收缩相关信息，告诉他别收缩我这个栈
</span><span class="c1"></span>	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store8</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gp</span><span class="p">.</span><span class="nx">parkingOnChan</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
  <span class="c1">// 阻塞等待唤醒
</span><span class="c1"></span>	<span class="nf">gopark</span><span class="p">(</span><span class="nx">chanparkcommit</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">),</span> <span class="nx">waitReasonChanSend</span><span class="p">,</span> <span class="nx">traceEvGoBlockSend</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
	<span class="c1">// 防止gc对这个发送的地址做点什么不好的事情
</span><span class="c1"></span>	<span class="nf">KeepAlive</span><span class="p">(</span><span class="nx">ep</span><span class="p">)</span>
	<span class="c1">// 把当前g的一些信息和sugog的一些信息清理一下 然后返回
</span><span class="c1"></span>  <span class="c1">// 因为已经放到了等待发送列表，当可发送的时候这个g就会被唤醒
</span><span class="c1"></span>  <span class="c1">// 所以到此处的时候代表该g已经被唤醒数据也已经发送成功了
</span><span class="c1"></span>	<span class="nx">gp</span><span class="p">.</span><span class="nx">waiting</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">activeStackChans</span> <span class="p">=</span> <span class="kc">false</span>
	<span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">closed</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;chansend: spurious wakeup&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nf">plainError</span><span class="p">(</span><span class="s">&#34;send on closed channel&#34;</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="k">if</span> <span class="nx">mysg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">blockevent</span><span class="p">(</span><span class="nx">mysg</span><span class="p">.</span><span class="nx">releasetime</span><span class="o">-</span><span class="nx">t0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">mysg</span><span class="p">.</span><span class="nx">c</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="nf">releaseSudog</span><span class="p">(</span><span class="nx">mysg</span><span class="p">)</span>
	<span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>

<span class="c1">// 发送逻辑
</span><span class="c1">// 参数：
</span><span class="c1">// 1。通道
</span><span class="c1">// 2。正在等待接收的那个sudog
</span><span class="c1">// 3。发送数据的地址
</span><span class="c1">// 4。发送结束后的回调
</span><span class="c1">// 5。这个参数是goready用的但是不知道实际用途是啥。。好像是运行时的跟踪相关
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">send</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">hchan</span><span class="p">,</span> <span class="nx">sg</span> <span class="o">*</span><span class="nx">sudog</span><span class="p">,</span> <span class="nx">ep</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">unlockf</span> <span class="kd">func</span><span class="p">(),</span> <span class="nx">skip</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 如果等待接受的目标地址不是nil
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">sg</span><span class="p">.</span><span class="nx">elem</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="c1">// 直接把要发送的变量的内存地址里面的数据拷贝到等待接受数据的内存地址上
</span><span class="c1"></span>		<span class="nf">sendDirect</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">sg</span><span class="p">,</span> <span class="nx">ep</span><span class="p">)</span>
    <span class="c1">// 拷贝完了 要他没用了
</span><span class="c1"></span>		<span class="nx">sg</span><span class="p">.</span><span class="nx">elem</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="p">}</span>
  <span class="c1">// 获取等待接收数据的g
</span><span class="c1"></span>	<span class="nx">gp</span> <span class="o">:=</span> <span class="nx">sg</span><span class="p">.</span><span class="nx">g</span>
  <span class="c1">// 调用回调
</span><span class="c1"></span>	<span class="nf">unlockf</span><span class="p">()</span>
  <span class="c1">// 唤醒的时候要传递的参数，如果不传就出问题了
</span><span class="c1"></span>	<span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="p">=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">sg</span><span class="p">)</span>
  <span class="c1">// 唤醒他！标记为_Grunnable
</span><span class="c1"></span>  <span class="c1">// 但是注意，不是让这个g所处的p立刻执行
</span><span class="c1"></span>  <span class="c1">// 而是放p.runnext上 让他在下一个执行
</span><span class="c1"></span>	<span class="nf">goready</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">skip</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h3 id="通道的发送总结">通道的发送总结</h3>
<p>好了上面一大段代码都是关于通道发送的一些代码解析，代码很长，但是去掉一些没啥用的代码之后还算很好理解，我来总结一下发送的具体流程吧：</p>
<ol>
<li>如果当前通道为nil，即未make的通道，则永久阻塞。</li>
<li>如果当前通道已关闭，则panic。</li>
<li>如果等待接收队列有正在等待的接收者则取出等待接收队列最前面的一个goroutine，直接把发送的变量内存地址里面的东西复制到其对应接收变量的内存地址中，然后唤醒等待方。例子：x:=&lt;-c，则直接发送方的发送变量的数据复制到x变量地址中。在复制完相关数据后，会唤醒接收方的goroutine，然后将其加入到其p的runnext字段中，代表该g为下一个运行的g，而不是立刻运行</li>
<li>如果当前缓冲区有空余的位置，则把发送变量内存地址里面的东西拷贝到对应的空余位置中。然后当前通道元素个数+1。</li>
<li>如果上面都不满足， 则把当前的goroutine绑定一个sudog并在sudog中存入的相关信息后将sudog放入发送等待列表，等待接收方接收数据后唤醒。</li>
</ol>
<h2 id="通道的接收">通道的接收</h2>
<h3 id="接收代码解析">接收代码解析</h3>
<p>针对通道的发送，我们仍然从汇编代码看起，当前我有一个代码段如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">a</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">a</span> <span class="o">&lt;-</span> <span class="mi">1</span>
	<span class="p">}()</span>
	<span class="nx">b</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">a</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
<span class="p">}</span>	
</code></pre></div><p>代码中，创建了一个无缓冲通道，然后往其中发送数据和接受数据，打印一下汇编代码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">  			<span class="mh">0x0043</span> <span class="mo">00067</span>    <span class="nx">CALL</span>    <span class="nx">runtime</span><span class="p">.</span><span class="nf">makechan</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
    		<span class="o">...</span> 
        <span class="mh">0x008b</span> <span class="mo">0013</span><span class="mi">9</span>    <span class="nx">CALL</span>    <span class="nx">runtime</span><span class="p">.</span><span class="nf">chanrecv1</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>

</code></pre></div><p>去除了一些无关代码，只看000139处的代码，runtime.chanrecv1(SB) 这个代码是针对b := &lt;-a的一个编译期间的改写，编译期间会将b := &lt;-a改为runtime.chanrecv1(SB)调用，而当代码为b, ok:= &lt;-a时，则会调用 runtime.chanrecv2(SB)。其区别就是返回了一个参数还是两个。其最终都会调用runtime.chanrecv()函数，下面我开始解析这个函数的相关源代码。</p>
<blockquote>
<p>(再再次提醒，前方高能，代码巨长，请各位准备好瓜子饮料矿泉水耐心观看)</p>
<p>太长不爱看直接跳转 ：通道的接收总结</p>
<p>注：下面代码去掉了一些跟业务逻辑关系不大的代码</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 实际的接收函数参数分别为
</span><span class="c1">// 1。通道
</span><span class="c1">// 2。接收变量的地址
</span><span class="c1">// 3。是否阻塞接收，跟接收一样，非阻塞接收在select有效
</span><span class="c1">// 返回值为：
</span><span class="c1">// 1.是否接收到了
</span><span class="c1">// 2.是否接收成功
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">chanrecv</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">hchan</span><span class="p">,</span> <span class="nx">ep</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">block</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">(</span><span class="nx">selected</span><span class="p">,</span> <span class="nx">received</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
<span class="c1">// 老规矩 对未make的通道进行收发操作均会阻塞
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">c</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
     <span class="c1">// 如果为非阻塞接收则直接返回
</span><span class="c1"></span>    <span class="c1">// 当
</span><span class="c1"></span>    <span class="c1">// select {
</span><span class="c1"></span>    <span class="c1">// case &lt;-channel:
</span><span class="c1"></span>    <span class="c1">// todo 
</span><span class="c1"></span>    <span class="c1">// default:
</span><span class="c1"></span>    <span class="c1">//   }
</span><span class="c1"></span>    <span class="c1">// 时会出现block == false的情况
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">!</span><span class="nx">block</span> <span class="p">{</span>
			<span class="k">return</span>
		<span class="p">}</span>
    <span class="c1">// 否则挂起直接阻塞
</span><span class="c1"></span>		<span class="nf">gopark</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">waitReasonChanReceiveNilChan</span><span class="p">,</span> <span class="nx">traceEvGoStop</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;unreachable&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 如果为非阻塞操作且为空
</span><span class="c1"></span>  <span class="c1">// empty返回条件：
</span><span class="c1"></span>  <span class="c1">// 1.非缓冲通道且无发送方时，返回true
</span><span class="c1"></span>  <span class="c1">// 2.如果通道里暂时没有数据时 返回true
</span><span class="c1"></span> 	<span class="k">if</span> <span class="p">!</span><span class="nx">block</span> <span class="o">&amp;&amp;</span> <span class="nf">empty</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 通道关了 返回
</span><span class="c1"></span>    <span class="c1">// 也就是说对关闭通道的接收操作不会panic
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">closed</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="k">return</span>
		<span class="p">}</span>
	 	<span class="c1">// 如果为空
</span><span class="c1"></span>		<span class="k">if</span> <span class="nf">empty</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// 且接收变量的地址不为nil 即不能未初始化
</span><span class="c1"></span>      <span class="c1">// 这个地方 ep== nil的情况可能是
</span><span class="c1"></span>      <span class="c1">// _,ok:=&lt;-chan的时候
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">ep</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="c1">// 这个是清空内存
</span><span class="c1"></span>        <span class="c1">// 将接收地址变量置为对应类型零值
</span><span class="c1"></span>				<span class="nf">typedmemclr</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">ep</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">false</span>
		<span class="p">}</span>
	<span class="p">}</span>
  <span class="c1">// 加锁
</span><span class="c1"></span>	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="c1">// 如果关了并且通道里也没有可接收数据的时候
</span><span class="c1"></span>  <span class="c1">// 解锁，并将接收地址变量置为对应类型零值
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">closed</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">qcount</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">ep</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nf">typedmemclr</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">ep</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="c1">// 如果目前等待发送队列里面有正在等待发送的goroutine
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">sg</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">sendq</span><span class="p">.</span><span class="nf">dequeue</span><span class="p">();</span> <span class="nx">sg</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
	 <span class="c1">// 直接发
</span><span class="c1"></span>		<span class="nf">recv</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">sg</span><span class="p">,</span> <span class="nx">ep</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span> <span class="p">},</span> <span class="mi">3</span><span class="p">)</span>
		<span class="k">return</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">true</span>
	<span class="p">}</span>
	<span class="c1">// 如果当前缓冲区里面有数据
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">qcount</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="c1">// 找到当前接收索引所处位置的指针
</span><span class="c1"></span> 		<span class="nx">qp</span> <span class="o">:=</span> <span class="nf">chanbuf</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span><span class="p">)</span>
		<span class="c1">// 把找到那个指针里面的数据，拷贝到接收者的地址
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">ep</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nf">typedmemmove</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">ep</span><span class="p">,</span> <span class="nx">qp</span><span class="p">)</span>
		<span class="p">}</span>
    <span class="c1">// 把索引位置那个指针的值归零
</span><span class="c1"></span>		<span class="nf">typedmemclr</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">qp</span><span class="p">)</span>
    <span class="c1">// 索引+1
</span><span class="c1"></span>		<span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span><span class="o">++</span>
    <span class="c1">// 因为底层是个环形队列，所以当索引==长度的时候，索引归0
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span> <span class="o">==</span> <span class="nx">c</span><span class="p">.</span><span class="nx">dataqsiz</span> <span class="p">{</span>
			<span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="p">}</span>
    <span class="c1">// 取出来一个了 那就当前元素个数-1
</span><span class="c1"></span>		<span class="nx">c</span><span class="p">.</span><span class="nx">qcount</span><span class="o">--</span>
   	<span class="c1">// 解锁 返回
</span><span class="c1"></span>		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="k">return</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">true</span>
	<span class="p">}</span>
  <span class="c1">// 如果缓冲区没数据的时候且
</span><span class="c1"></span>	<span class="c1">// 非阻塞直接解锁返回
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">block</span> <span class="p">{</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="k">return</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">false</span>
	<span class="p">}</span>
	
 	<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
  <span class="c1">// 开始
</span><span class="c1"></span>  <span class="c1">// 从开始到结束这一系列操作就是获取一个*sudog结构
</span><span class="c1"></span>  <span class="c1">// 这个结构放的是等待列表里的g的结构
</span><span class="c1"></span>  <span class="c1">// 然后设置一大堆的相关信息 比如接受数据的地址在哪，是不是在select里面
</span><span class="c1"></span>  <span class="c1">// 向接收的通道等等
</span><span class="c1"></span>  <span class="c1">// 在此不做赘述了
</span><span class="c1"></span>	<span class="nx">mysg</span> <span class="o">:=</span> <span class="nf">acquireSudog</span><span class="p">()</span>
	<span class="nx">mysg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">mysg</span><span class="p">.</span><span class="nx">elem</span> <span class="p">=</span> <span class="nx">ep</span>
	<span class="nx">mysg</span><span class="p">.</span><span class="nx">waitlink</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">waiting</span> <span class="p">=</span> <span class="nx">mysg</span>
	<span class="nx">mysg</span><span class="p">.</span><span class="nx">g</span> <span class="p">=</span> <span class="nx">gp</span>
	<span class="nx">mysg</span><span class="p">.</span><span class="nx">isSelect</span> <span class="p">=</span> <span class="kc">false</span>
	<span class="nx">mysg</span><span class="p">.</span><span class="nx">c</span> <span class="p">=</span> <span class="nx">c</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="p">=</span> <span class="kc">nil</span>
  <span class="c1">// 结束
</span><span class="c1"></span>  <span class="c1">// 做完上面的赋值
</span><span class="c1"></span>  <span class="c1">// 把这个mysg塞到等待接收队列
</span><span class="c1"></span>	<span class="nx">c</span><span class="p">.</span><span class="nx">recvq</span><span class="p">.</span><span class="nf">enqueue</span><span class="p">(</span><span class="nx">mysg</span><span class="p">)</span>
	<span class="c1">// 栈内存收缩相关信息，告诉他别收缩我这个栈
</span><span class="c1"></span>	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store8</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gp</span><span class="p">.</span><span class="nx">parkingOnChan</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
  <span class="c1">// 阻塞等待唤醒
</span><span class="c1"></span>	<span class="nf">gopark</span><span class="p">(</span><span class="nx">chanparkcommit</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">),</span> <span class="nx">waitReasonChanReceive</span><span class="p">,</span> <span class="nx">traceEvGoBlockRecv</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
	
  <span class="c1">// 嘿！被唤醒了
</span><span class="c1"></span> 	<span class="k">if</span> <span class="nx">mysg</span> <span class="o">!=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">waiting</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;G waiting list is corrupted&#34;</span><span class="p">)</span>
	<span class="p">}</span>
  <span class="c1">// 下面一系列都是唤醒后做了一些清空操作
</span><span class="c1"></span>	<span class="nx">gp</span><span class="p">.</span><span class="nx">waiting</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">activeStackChans</span> <span class="p">=</span> <span class="kc">false</span>
	<span class="k">if</span> <span class="nx">mysg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">blockevent</span><span class="p">(</span><span class="nx">mysg</span><span class="p">.</span><span class="nx">releasetime</span><span class="o">-</span><span class="nx">t0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">closed</span> <span class="o">:=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="o">==</span> <span class="kc">nil</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="nx">mysg</span><span class="p">.</span><span class="nx">c</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="nf">releaseSudog</span><span class="p">(</span><span class="nx">mysg</span><span class="p">)</span>
	<span class="k">return</span> <span class="kc">true</span><span class="p">,</span> <span class="p">!</span><span class="nx">closed</span>
<span class="p">}</span>

<span class="c1">// 真正的接收操作
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">recv</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">hchan</span><span class="p">,</span> <span class="nx">sg</span> <span class="o">*</span><span class="nx">sudog</span><span class="p">,</span> <span class="nx">ep</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">unlockf</span> <span class="kd">func</span><span class="p">(),</span> <span class="nx">skip</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 如果是无缓冲通道
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">dataqsiz</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="c1">// 直接把发送方的发送地址的值拷贝给接收变量的地址
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">ep</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
 			<span class="nf">recvDirect</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">sg</span><span class="p">,</span> <span class="nx">ep</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="c1">// 有缓冲通道
</span><span class="c1"></span>    <span class="c1">// 算一下当前接收到哪个索引了，找出他的地址
</span><span class="c1"></span>		<span class="nx">qp</span> <span class="o">:=</span> <span class="nf">chanbuf</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span><span class="p">)</span>
	 	<span class="c1">// 把索引哪个地址的值拷贝到接收变量的地址
</span><span class="c1"></span> 		<span class="k">if</span> <span class="nx">ep</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nf">typedmemmove</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">ep</span><span class="p">,</span> <span class="nx">qp</span><span class="p">)</span>
		<span class="p">}</span>
    <span class="c1">// 把等待发送的g的要发送的数据拷贝到哪个空出来的索引处
</span><span class="c1"></span> 		<span class="nf">typedmemmove</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">qp</span><span class="p">,</span> <span class="nx">sg</span><span class="p">.</span><span class="nx">elem</span><span class="p">)</span>
    <span class="c1">// 接收索引+1
</span><span class="c1"></span>		<span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span><span class="o">++</span>
    <span class="c1">// 环形队列不做解释了
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span> <span class="o">==</span> <span class="nx">c</span><span class="p">.</span><span class="nx">dataqsiz</span> <span class="p">{</span>
			<span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="p">}</span>
    <span class="c1">// 如果不设置  可能会在下次发送的时候
</span><span class="c1"></span>    <span class="c1">// 发送数据覆盖到已存在的数据上
</span><span class="c1"></span>		<span class="nx">c</span><span class="p">.</span><span class="nx">sendx</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span>  
	<span class="p">}</span>
	<span class="nx">sg</span><span class="p">.</span><span class="nx">elem</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="nx">gp</span> <span class="o">:=</span> <span class="nx">sg</span><span class="p">.</span><span class="nx">g</span>
	<span class="nf">unlockf</span><span class="p">()</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="p">=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">sg</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">sg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">sg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">=</span> <span class="nf">cputicks</span><span class="p">()</span>
	<span class="p">}</span>
   <span class="c1">// 唤醒他！标记为_Grunnable
</span><span class="c1"></span>  <span class="c1">// 但是注意，不是让这个g所处的p立刻执行
</span><span class="c1"></span>  <span class="c1">// 而是放p.runnext上 让他在下一个执行
</span><span class="c1"></span>	<span class="nf">goready</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">skip</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h3 id="通道的接收总结">通道的接收总结</h3>
<p>好了上面一大段代码都是关于通道接收的一些代码解析，代码很长，但是去掉一些没啥用的代码之后还算很好理解，我来总结一下发送的具体流程吧：</p>
<ol>
<li>老规矩，对未make的通道发送（即通道为nil）都会永久阻塞。</li>
<li>如果当前通道关闭了，则返回通道存储类型的零值，跟发送不同，接收关闭的通道不会panic。</li>
<li>如果当前等待发送队列存在正在等待发送的g，则取出第一个g，并且：
<ol>
<li>当前通道为无缓冲时直接把发送方存储数据的地址里面的数据拷贝到接收变量的地址上，然后唤醒发送方。</li>
<li>如果当前通道为有缓冲，则将当前接收的索引处的数据拷贝到接收变量的地址上，然后把等待发送的g所持有的发送东西的地址中的值拷贝到这个接收的索引处覆盖原值。</li>
</ol>
</li>
<li>如果不存在等待发送的g且为有缓冲通道，且缓冲区中有数据，那么则将当前接收的索引处的数据拷贝到接收变量的地址上，然后将索引处的数据置零。</li>
<li>如果上述都不符合，那么将会将当前g放入recvq即接收等待列表，等待发送方的唤醒和数据发送。</li>
</ol>
<h2 id="通道的关闭操">通道的关闭操</h2>
<p>关于通道的关闭，我就不上源代码解析了，只总结以下几点：</p>
<ol>
<li>把closed字段由0设置为1（我不知道为什么官方没有把这个字段设置为bool类型而是 uint32 ）。</li>
<li>然后把当前处于发送等待列表sendq和接收等待列表recvq中的所有g取出放入一个gList中。</li>
<li>然后把gList里面所有的g都唤醒，此时发送的数据都会被抛弃。</li>
</ol>
<h2 id="总结">总结</h2>
<p>至此我们来对通道做一个总体的总结：</p>
<ol>
<li>当前通道为无缓冲通道时，如果发送和接收方有一方不存在，则会阻塞当前对通道的接收和发送操作。</li>
<li>对关闭的通道进行发送会panic，而接收不会，但是会返回一个对应类型的零值和一个false。</li>
<li>当接收方的接收变量为 ‘_’ 时，不会拷贝数据到其中。</li>
<li>通道是一个有锁的环形的队列 。</li>
<li>创建通道时，make(chan int) 与 make(chan int ,0 )等同，皆为创建一个无缓冲通道。</li>
<li>创建通道时，通道的元素类型占用内存不能大于2^16 即，64KB。</li>
<li>无缓冲通道不会分配循环队列。</li>
<li>创建通道时元素类型为非指针的话， hchan和循环队列的内存地址是连续的，反之，循环队列的地址和hchan的内存地址不一定是连续的。</li>
</ol>
]]></content>
		</item>
		
		<item>
			<title>「Golang」 sync.Mutex源码讲解</title>
			<link>http://echoblog.cc/posts/golang-sync.mutex%E6%BA%90%E7%A0%81%E8%AE%B2%E8%A7%A3/</link>
			<pubDate>Mon, 04 Jan 2021 00:00:00 +0000</pubDate>
			
			<guid>http://echoblog.cc/posts/golang-sync.mutex%E6%BA%90%E7%A0%81%E8%AE%B2%E8%A7%A3/</guid>
			<description>sync.Mutex概述  后期更新：下面的代码中会多次出现 if race.Enabled { //todo } 这种代码，经过理解这种判断是进行判断当前程序是否开启了race竞态检测模式 ，即在运行go程序时是否采用 go run race xxx.go 这种进行进行竞态检测运行模式
 在进行源码解析之前，先看一下sync.Mutex是做什么的，首先看一下sync/mutex.go中的标注
 A Mutex is a mutual exclusion lock.The zero value for a Mutex is an unlocked mutex. A Mutex must not be copied after first use. 译注：Mutex是互斥锁，Mutex的零值是解锁的Mutex。Mutex在第一次使用后不得复制。
 从sync.Mutex的注释中可以看出，Mutex是一个互斥锁，根据百度百科给到的互斥锁的意义：
 在编程中，引入了对象互斥锁的概念，来保证共享数据操作的完整性。每个对象都对应于一个可称为&amp;quot; 互斥锁&amp;quot; 的标记，这个标记用来保证在任一时刻，只能有一个线程访问该对象。
 也就是说，当某个struct中存在一个Mutex字段时，在某些方法进行调用时，如果Mutex已经被其他go程占用，那么本次调用会进行阻塞直至该Mutex被解锁。
sync.Mutex解析 接下来看一下sync.Mutex结构体的字段内容：
type Mutex struct { state int32 //当前锁的状态，该int32字段通过位移操作使之可以包含不同意义 	sema uint32 //是一个信号变量用于负责go程的唤醒和阻塞休眠 } const ( mutexLocked = 1 &amp;lt;&amp;lt; iota // 锁是否被持有 即是否已经锁住 	mutexWoken // 是否有被唤醒的go程 	mutexStarving //是否处于饥饿状态，此标记可以确保某些go程不会长久获取不到锁 	mutexWaiterShift = iota // 目前等待锁的go程数量 	starvationThresholdNs = 1e6 //进入饥饿状态的阈值时间 1ms ) Lock() 关于饥饿状态这个问题等之后在进行讲解，首先先说一下对Mutex加锁的过程</description>
			<content type="html"><![CDATA[<h2 id="syncmutex概述">sync.Mutex概述</h2>
<blockquote>
<p>后期更新：下面的代码中会多次出现
<code>if race.Enabled { //todo  }</code>
这种代码，经过理解这种判断是进行判断当前程序是否开启了race竞态检测模式 ，即在运行go程序时是否采用
go run race xxx.go
这种进行进行竞态检测运行模式</p>
</blockquote>
<p>在进行源码解析之前，先看一下sync.Mutex是做什么的，首先看一下sync/mutex.go中的标注</p>
<blockquote>
<p>A Mutex is a mutual exclusion lock.The zero value for a Mutex is an unlocked mutex. A Mutex must not be copied after first use.
译注：Mutex是互斥锁，Mutex的零值是解锁的Mutex。Mutex在第一次使用后不得复制。</p>
</blockquote>
<p>从sync.Mutex的注释中可以看出，Mutex是一个互斥锁，根据百度百科给到的互斥锁的意义：</p>
<blockquote>
<p><a href="https://baike.baidu.com/item/%E4%BA%92%E6%96%A5%E9%94%81">在编程中，引入了对象互斥锁的概念，来保证共享数据操作的完整性。每个对象都对应于一个可称为&quot; 互斥锁&quot; 的标记，这个标记用来保证在任一时刻，只能有一个线程访问该对象。</a></p>
</blockquote>
<p>也就是说，当某个struct中存在一个Mutex字段时，在某些方法进行调用时，如果Mutex已经被其他go程占用，那么本次调用会进行阻塞直至该Mutex被解锁。</p>
<h2 id="syncmutex解析">sync.Mutex解析</h2>
<p>接下来看一下sync.Mutex结构体的字段内容：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Mutex</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">state</span> <span class="kt">int32</span> <span class="c1">//当前锁的状态，该int32字段通过位移操作使之可以包含不同意义
</span><span class="c1"></span>	<span class="nx">sema</span>  <span class="kt">uint32</span> <span class="c1">//是一个信号变量用于负责go程的唤醒和阻塞休眠
</span><span class="c1"></span><span class="p">}</span>


<span class="kd">const</span> <span class="p">(</span>
	<span class="nx">mutexLocked</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="kc">iota</span> <span class="c1">// 锁是否被持有 即是否已经锁住
</span><span class="c1"></span>	<span class="nx">mutexWoken</span> <span class="c1">// 是否有被唤醒的go程
</span><span class="c1"></span>	<span class="nx">mutexStarving</span> <span class="c1">//是否处于饥饿状态，此标记可以确保某些go程不会长久获取不到锁
</span><span class="c1"></span>	<span class="nx">mutexWaiterShift</span> <span class="p">=</span> <span class="kc">iota</span> <span class="c1">// 目前等待锁的go程数量
</span><span class="c1"></span>	
	<span class="nx">starvationThresholdNs</span> <span class="p">=</span> <span class="mf">1e6</span> <span class="c1">//进入饥饿状态的阈值时间 1ms
</span><span class="c1"></span><span class="p">)</span>

</code></pre></div><h2 id="lock">Lock()</h2>
<p>关于饥饿状态这个问题等之后在进行讲解，首先先说一下对Mutex加锁的过程</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Mutex</span><span class="p">)</span> <span class="nf">Lock</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// Fast path: grab unlocked mutex.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">CompareAndSwapInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">.</span><span class="nx">state</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">mutexLocked</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">race</span><span class="p">.</span><span class="nx">Enabled</span> <span class="p">{</span>
			<span class="nx">race</span><span class="p">.</span><span class="nf">Acquire</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">m</span><span class="p">))</span>
		<span class="p">}</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="c1">// Slow path (outlined so that the fast path can be inlined)
</span><span class="c1"></span>	<span class="nx">m</span><span class="p">.</span><span class="nf">lockSlow</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><p>Lock方法被分成了两个情况进行加锁，首先第一种情况 即<strong>Fast Path</strong>快速加锁方式，此方式会首先进行CAS<!-- raw HTML omitted -->1<!-- raw HTML omitted --> 判断，首先进行判断当前的state字段是否为0，如果为0则代表当前互斥锁未被占用，因此可以直接对其进行加锁操作然后直接返回，所以此情况被称为<strong>Fast Path</strong>，在判断语句中的</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">if</span> <span class="nx">race</span><span class="p">.</span><span class="nx">Enabled</span> <span class="p">{</span>
			<span class="nx">race</span><span class="p">.</span><span class="nf">Acquire</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">m</span><span class="p">))</span>
		<span class="p">}</span>
</code></pre></div><p>是go提供的竟态检测器，用于检测当前是否有其他操作同时操纵此Mutex对象。</p>
<blockquote>
<p>注：因为race包不甚了解因此解释可能有出入，如果有更好的解释，请多指教。</p>
</blockquote>
<p>之后来看一下第二种情况，即<strong>Slow Path</strong>，也就是说当前锁已经被人占用，需要进行一些其他操作。因为代码较长，可能会难读一些。我会尽量在每个语句中做注释讲解。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Mutex</span><span class="p">)</span> <span class="nf">lockSlow</span><span class="p">()</span> <span class="p">{</span>
   <span class="c1">// 记录等待开始时间，用于与starvationThresholdNs搭配判断是否开启饥饿状态
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">waitStartTime</span> <span class="kt">int64</span>
	<span class="c1">//是否是饥饿状态
</span><span class="c1"></span>	<span class="nx">starving</span> <span class="o">:=</span> <span class="kc">false</span>
	<span class="c1">//是否是唤醒状态
</span><span class="c1"></span>	<span class="nx">awoke</span> <span class="o">:=</span> <span class="kc">false</span>
	<span class="c1">//自旋次数累计
</span><span class="c1"></span>	<span class="nx">iter</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="c1">//下面操作的都是这个old 其为当前Mutex对象状态字段的copy
</span><span class="c1"></span>	<span class="nx">old</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">state</span>
	<span class="c1">//持续循环
</span><span class="c1"></span>	<span class="k">for</span> <span class="p">{</span>
		<span class="c1">// 判断锁是不是非饥饿状态，并且锁还没被释放，如果是那就开始尝试自旋，多次尝试获取锁
</span><span class="c1"></span>		<span class="c1">//不能再饥饿模式下进行自旋，因为可能会造成某些等待的很早的go程长时间获取不到锁。
</span><span class="c1"></span>		<span class="c1">//所以当处于饥饿状态时，不能自旋，并且如果锁已经被释放了就需要竞争锁
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">old</span><span class="o">&amp;</span><span class="p">(</span><span class="nx">mutexLocked</span><span class="p">|</span><span class="nx">mutexStarving</span><span class="p">)</span> <span class="o">==</span> <span class="nx">mutexLocked</span> <span class="o">&amp;&amp;</span> <span class="nf">runtime_canSpin</span><span class="p">(</span><span class="nx">iter</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">//如果非唤醒状态，并且mutexWoken标记位为0并且其他go程也在等待锁的时候
</span><span class="c1"></span>		<span class="c1">//尝试设置mutexWoken标记位，用于告知在Unlock的时候不需要去唤醒其他等待go程
</span><span class="c1"></span>		<span class="c1">//设置唤醒标记的意义在于可以告知Unlock有go程正在自旋等待锁，让其无需唤醒其他正在等待的go程
</span><span class="c1"></span>			<span class="k">if</span> <span class="p">!</span><span class="nx">awoke</span> <span class="o">&amp;&amp;</span> <span class="nx">old</span><span class="o">&amp;</span><span class="nx">mutexWoken</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">old</span><span class="o">&gt;&gt;</span><span class="nx">mutexWaiterShift</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
				<span class="nx">atomic</span><span class="p">.</span><span class="nf">CompareAndSwapInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">.</span><span class="nx">state</span><span class="p">,</span> <span class="nx">old</span><span class="p">,</span> <span class="nx">old</span><span class="p">|</span><span class="nx">mutexWoken</span><span class="p">)</span> <span class="p">{</span>
				<span class="nx">awoke</span> <span class="p">=</span> <span class="kc">true</span>
			<span class="p">}</span>
			<span class="c1">//开始自旋 自旋代码是runtime在编译期间动态生成
</span><span class="c1"></span>			<span class="nf">runtime_doSpin</span><span class="p">()</span>
			<span class="c1">//自旋次数+1
</span><span class="c1"></span>			<span class="nx">iter</span><span class="o">++</span>
			<span class="c1">//更新锁的状态
</span><span class="c1"></span>			<span class="nx">old</span> <span class="p">=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">state</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="c1">//检查的状态
</span><span class="c1"></span>		<span class="nx">new</span> <span class="o">:=</span> <span class="nx">old</span>
		<span class="c1">//如果不是饥饿状态，则获取锁
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">old</span><span class="o">&amp;</span><span class="nx">mutexStarving</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">new</span> <span class="o">|=</span> <span class="nx">mutexLocked</span>
		<span class="p">}</span>
		<span class="c1">//等待锁go程的数量+1
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">old</span><span class="o">&amp;</span><span class="p">(</span><span class="nx">mutexLocked</span><span class="p">|</span><span class="nx">mutexStarving</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">new</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nx">mutexWaiterShift</span>
		<span class="p">}</span>
		<span class="c1">// 如果是饥饿状态 并且有人占用了锁 就切换到饥饿模式
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">starving</span> <span class="o">&amp;&amp;</span> <span class="nx">old</span><span class="o">&amp;</span><span class="nx">mutexLocked</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">new</span> <span class="o">|=</span> <span class="nx">mutexStarving</span>
		<span class="p">}</span>
		<span class="c1">//看看当前是否是唤醒go程
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">awoke</span> <span class="p">{</span>
				<span class="c1">//如果不是唤醒go程 但是awoke变量被设置为true 则代表出错了，，
</span><span class="c1"></span>				<span class="k">if</span> <span class="nx">new</span><span class="o">&amp;</span><span class="nx">mutexWoken</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;sync: inconsistent mutex state&#34;</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="c1">//go程已从睡眠中唤醒，因此，无论哪种情况，都需要重置标志。
</span><span class="c1"></span>			<span class="nx">new</span> <span class="o">&amp;^=</span> <span class="nx">mutexWoken</span>
		<span class="p">}</span>
		<span class="c1">//cas 判断当前对象旧状态和old标记的状态是否相同，相同就换成new的，不相同就用当前对象的
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">CompareAndSwapInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">.</span><span class="nx">state</span><span class="p">,</span> <span class="nx">old</span><span class="p">,</span> <span class="nx">new</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">//old已经被解锁并释放并且不是饥饿状态 就代表正常的获取到了锁 则返回
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">old</span><span class="o">&amp;</span><span class="p">(</span><span class="nx">mutexLocked</span><span class="p">|</span><span class="nx">mutexStarving</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="k">break</span> 
			<span class="p">}</span>
			<span class="c1">//等待时间不等于0就代表之前就开始等待了
</span><span class="c1"></span>			<span class="nx">queueLifo</span> <span class="o">:=</span> <span class="nx">waitStartTime</span> <span class="o">!=</span> <span class="mi">0</span>
			<span class="k">if</span> <span class="nx">waitStartTime</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">waitStartTime</span> <span class="p">=</span> <span class="nf">runtime_nanotime</span><span class="p">()</span>
			<span class="p">}</span>
			<span class="c1">//如果之前就开始等待了那就放到队列前面
</span><span class="c1"></span>			<span class="nf">runtime_SemacquireMutex</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">.</span><span class="nx">sema</span><span class="p">,</span> <span class="nx">queueLifo</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
			<span class="c1">//如果等待时间超过1ms 即starvationThresholdNs常量中的设定值，则开启饥饿模式
</span><span class="c1"></span>			<span class="nx">starving</span> <span class="p">=</span> <span class="nx">starving</span> <span class="o">||</span> <span class="nf">runtime_nanotime</span><span class="p">()</span><span class="o">-</span><span class="nx">waitStartTime</span> <span class="p">&gt;</span> <span class="nx">starvationThresholdNs</span>
			<span class="nx">old</span> <span class="p">=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">state</span>
			<span class="c1">//如果当前状态非饥饿模式
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">old</span><span class="o">&amp;</span><span class="nx">mutexStarving</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="c1">//如果此goroutine被唤醒，并且互斥锁处于饥饿模式，则所有权已移交给我们，但互斥锁处于某种不一致的状态：MutexLocked未设置，我们仍被视为等待。即状态设置有误
</span><span class="c1"></span>				<span class="k">if</span> <span class="nx">old</span><span class="o">&amp;</span><span class="p">(</span><span class="nx">mutexLocked</span><span class="p">|</span><span class="nx">mutexWoken</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">old</span><span class="o">&gt;&gt;</span><span class="nx">mutexWaiterShift</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
					<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;sync: inconsistent mutex state&#34;</span><span class="p">)</span>
				<span class="p">}</span>
				<span class="c1">//减去一个等待者数量并且加锁
</span><span class="c1"></span>				<span class="nx">delta</span> <span class="o">:=</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">mutexLocked</span> <span class="o">-</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="nx">mutexWaiterShift</span><span class="p">)</span>
				<span class="c1">//如果不是饥饿模式或等待数量为1的话就代表是最后一个等待者并且非饥饿状态
</span><span class="c1"></span>				<span class="k">if</span> <span class="p">!</span><span class="nx">starving</span> <span class="o">||</span> <span class="nx">old</span><span class="o">&gt;&gt;</span><span class="nx">mutexWaiterShift</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
					<span class="c1">//那就解除饥饿标记
</span><span class="c1"></span>					<span class="nx">delta</span> <span class="o">-=</span> <span class="nx">mutexStarving</span>
				<span class="p">}</span>
				<span class="c1">//更新状态
</span><span class="c1"></span>				<span class="nx">atomic</span><span class="p">.</span><span class="nf">AddInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">.</span><span class="nx">state</span><span class="p">,</span> <span class="nx">delta</span><span class="p">)</span>
				<span class="k">break</span>
			<span class="p">}</span>
			<span class="c1">//设为唤醒状态
</span><span class="c1"></span>			<span class="nx">awoke</span> <span class="p">=</span> <span class="kc">true</span>
			<span class="c1">//重新开始循环
</span><span class="c1"></span>			<span class="nx">iter</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">old</span> <span class="p">=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">state</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">//竟态检测
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">race</span><span class="p">.</span><span class="nx">Enabled</span> <span class="p">{</span>
		<span class="nx">race</span><span class="p">.</span><span class="nf">Acquire</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">m</span><span class="p">))</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>现在进行一下Lock过程的总结：总的来说过程就是，如果当前锁没被其他go程获取，那么就直接获取锁，这也是最直接的方式，如果当前锁被其他go程占用，并且还没有进入饥饿状态时，进行自旋等待，并且通知UnLock有正在自旋go程正在等待锁，在释放锁时就不要唤醒其他go程，然后判断是否需要进入饥饿状态，进入饥饿状态的条件是，当前go程等待锁的时间已经超出starvationThresholdNs常量所设定的时间即1ms，此时进入饥饿状态，饥饿状态会把当前go程放入等待锁的队列的最前端，使得其能在UnLock后立刻获得锁，防止该go程被饿死。退出饥饿模式需要符合一下两个条件中的任意一条：</p>
<ol>
<li>此 go程已经是队列中的最后一个 waiter 了，没有其它的等待锁的 goroutine 了；</li>
<li>此 go程的等待时间小于 1 毫秒。</li>
</ol>
<p>那么当有很多的go程都在争相获取锁的时候，会按照什么顺序获取锁呢？</p>
<blockquote>
<p>等待的goroutine们是以FIFO排队的
1）当Mutex处于正常模式时，若此时没有新goroutine与队头goroutine竞争，则队头goroutine获得。若有新goroutine竞争大概率新goroutine获得。
2）当队头goroutine竞争锁失败1ms后，它会将Mutex调整为饥饿模式。进入饥饿模式后，锁的所有权会直接从解锁goroutine移交给队头goroutine，此时新来的goroutine直接放入队尾。
3）当一个goroutine获取锁后，如果发现自己满足下列条件中的任何一个#1它是队列中最后一个#2它等待锁的时间少于1ms，则将锁切换回正常模式</p>
</blockquote>
<p>那么问题来了，为什么正常模式下会让新来的go程获取到锁呢？因为新来的go程当前正在占用cpu的时间片，那么如果我们能够把锁交给正在占用 cpu 时间片的 go程 的话，那就不需要做上下文的切换，在高并发的情况下，可能会有更好的性能。所以在正常模式下会把锁交给新来的go程。</p>
<p>至此Lock()的过程就讲完了。接下来说Unlock。</p>
<h2 id="unlock">Unlock()</h2>
<p>首先看Unlock的代码</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Mutex</span><span class="p">)</span> <span class="nf">Unlock</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">race</span><span class="p">.</span><span class="nx">Enabled</span> <span class="p">{</span>
		<span class="nx">_</span> <span class="p">=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">state</span>
		<span class="nx">race</span><span class="p">.</span><span class="nf">Release</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">m</span><span class="p">))</span>
	<span class="p">}</span>

	<span class="c1">// Fast path: drop lock bit.
</span><span class="c1"></span>	<span class="nx">new</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">AddInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">.</span><span class="nx">state</span><span class="p">,</span> <span class="o">-</span><span class="nx">mutexLocked</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">new</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// Outlined slow path to allow inlining the fast path.
</span><span class="c1"></span>		<span class="c1">// To hide unlockSlow during tracing we skip one extra frame when tracing GoUnblock.
</span><span class="c1"></span>		<span class="nx">m</span><span class="p">.</span><span class="nf">unlockSlow</span><span class="p">(</span><span class="nx">new</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>Unlock与Lock一样分为两个情况，<strong>Fast Path</strong>直接将state标记位-1进行解锁，如果返回值不为0那么就代表还有等待锁的go程这样就需要对其进行一些处理，就进入了<strong>Slow Path</strong>情况：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Mutex</span><span class="p">)</span> <span class="nf">unlockSlow</span><span class="p">(</span><span class="nx">new</span> <span class="kt">int32</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">//首选判断是不是被解锁过了，因为不可二次解锁
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="nx">new</span><span class="o">+</span><span class="nx">mutexLocked</span><span class="p">)</span><span class="o">&amp;</span><span class="nx">mutexLocked</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;sync: unlock of unlocked mutex&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">//如果不是饥饿状态则做处理 否则就唤醒处于等待队列第一个的go程
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">new</span><span class="o">&amp;</span><span class="nx">mutexStarving</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">old</span> <span class="o">:=</span> <span class="nx">new</span>
		<span class="k">for</span> <span class="p">{</span>
		<span class="c1">//判断是否是最后一个go程或者唤醒标记处于已标记状态则不唤醒任何等待go程
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">old</span><span class="o">&gt;&gt;</span><span class="nx">mutexWaiterShift</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">old</span><span class="o">&amp;</span><span class="p">(</span><span class="nx">mutexLocked</span><span class="p">|</span><span class="nx">mutexWoken</span><span class="p">|</span><span class="nx">mutexStarving</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="k">return</span>
			<span class="p">}</span>
			<span class="c1">//否则就等待队列-1 并且设置唤醒标记
</span><span class="c1"></span>			<span class="nx">new</span> <span class="p">=</span> <span class="p">(</span><span class="nx">old</span> <span class="o">-</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="nx">mutexWaiterShift</span><span class="p">)</span> <span class="p">|</span> <span class="nx">mutexWoken</span>
			<span class="c1">//然后进行CAS处理
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">CompareAndSwapInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">.</span><span class="nx">state</span><span class="p">,</span> <span class="nx">old</span><span class="p">,</span> <span class="nx">new</span><span class="p">)</span> <span class="p">{</span>
				<span class="nf">runtime_Semrelease</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">.</span><span class="nx">sema</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
				<span class="k">return</span>
			<span class="p">}</span>
			<span class="nx">old</span> <span class="p">=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">state</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nf">runtime_Semrelease</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">.</span><span class="nx">sema</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>Unlock的代码要比Lock少很多，也好理解的多，总的来说就是首选判断是否是重复解锁，如果是就报错，否则判断是否是饥饿状态如果是就直接唤醒当前等待锁队列的第一个go程，否则就判断是否是还有没有等待的go程或者是否已经被Lock标记不需要唤醒其他go程，如果是的话就直接返回，否则就将等待数量-1并且设置唤醒标记然后唤醒一个等待锁队列中的go程，让其得到锁。</p>
<h2 id="总结">总结</h2>
<p>至此sync.Mutex的源码解析就解析完了，可能有些地方有些理解上的错误，请各位谅解并且帮忙指出修改意见，如果这篇文章能帮到你，这是我的荣幸。</p>
<h2 id="参考链接">参考链接：</h2>
<p>[^1]	CAS比较与交换:<a href="https://baike.baidu.com/item/CAS/1329876#viewPageContent">https://baike.baidu.com/item/CAS/1329876#viewPageContent</a></p>
]]></content>
		</item>
		
		<item>
			<title>「Golang」 sync.Mutex源码讲解</title>
			<link>http://echoblog.cc/posts/golang%E5%B9%B6%E5%8F%91%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84map%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%E5%8F%8A%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97/</link>
			<pubDate>Mon, 04 Jan 2021 00:00:00 +0000</pubDate>
			
			<guid>http://echoblog.cc/posts/golang%E5%B9%B6%E5%8F%91%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84map%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%E5%8F%8A%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97/</guid>
			<description>非线程安全的map map是一个在开发过程中常用的内建类型，也是各位很熟悉的一个数据结构，他可以很方便的让我们做一些关于针对某些key-value结构的CRUD操作，但是在官方设计中，内建类型的map并不是一个可以在并发场景下进行并发读写的线程安全类型，此时我们就需要考虑对其进行一些线程安全的改造，首先我们要了解一下为什么```map``是一个非线程安全的类型，首先看下列代码：
func main() { m := make(map[string]int, 2) m[&amp;#34;dd&amp;#34;] = 22 go func() { for { m[&amp;#34;ff&amp;#34;] = 1 } }() go func() { for { _ = m[&amp;#34;dd&amp;#34;] } }() time.Sleep(1 * time.Hour) } // out: // fatal error: concurrent map read and map write 上面的代码在运行期抛出了：fatal error: concurrent map read and map write异常，代表在读写过程中出现了同时读写的问题，那么为什么会出现这个问题呢？在map底层源代码的针对读和写的函数中有下列两段代码：
// runtime.mapassign 即在map进行写入操作时调用的函数 func mapassign(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer { // ..............  // 在写入时会对h.</description>
			<content type="html"><![CDATA[<h2 id="非线程安全的map">非线程安全的<code>map</code></h2>
<p><code>map</code>是一个在开发过程中常用的内建类型，也是各位很熟悉的一个数据结构，他可以很方便的让我们做一些关于针对某些key-value结构的CRUD操作，但是在官方设计中，内建类型的map并不是一个可以在并发场景下进行并发读写的线程安全类型，此时我们就需要考虑对其进行一些线程安全的改造，首先我们要了解一下为什么```map``是一个非线程安全的类型，首先看下列代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">m</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
	<span class="nx">m</span><span class="p">[</span><span class="s">&#34;dd&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="mi">22</span>
	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">{</span>
			<span class="nx">m</span><span class="p">[</span><span class="s">&#34;ff&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1</span>
		<span class="p">}</span>
	<span class="p">}()</span>
	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">{</span>
			<span class="nx">_</span> <span class="p">=</span> <span class="nx">m</span><span class="p">[</span><span class="s">&#34;dd&#34;</span><span class="p">]</span>
		<span class="p">}</span>
	<span class="p">}()</span>
	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Hour</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// out:
</span><span class="c1">// fatal error: concurrent map read and map write
</span></code></pre></div><p>上面的代码在运行期抛出了：<code>fatal error: concurrent map read and map write</code>异常，代表在读写过程中出现了同时读写的问题，那么为什么会出现这个问题呢？在<code>map</code>底层源代码的针对读和写的函数中有下列两段代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">
<span class="c1">// runtime.mapassign 即在map进行写入操作时调用的函数
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">mapassign</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">key</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="p">{</span>
	<span class="c1">// ..............
</span><span class="c1"></span>
	<span class="c1">// 在写入时会对h.flags字段进行正在写入标记以防止并发读写
</span><span class="c1"></span>	<span class="nx">h</span><span class="p">.</span><span class="nx">flags</span> <span class="p">^=</span> <span class="nx">hashWriting</span>
	<span class="c1">// ..........
</span><span class="c1"></span>	
	<span class="c1">// 检查是否有并发写的问题
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">flags</span><span class="o">&amp;</span><span class="nx">hashWriting</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;concurrent map writes&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 写入完毕回复标记字段
</span><span class="c1"></span>	<span class="nx">h</span><span class="p">.</span><span class="nx">flags</span> <span class="o">&amp;^=</span> <span class="nx">hashWriting</span>
	<span class="c1">//.........
</span><span class="c1"></span><span class="p">}</span>
<span class="c1">// runtime.mapaccess1 在 value:=m[key]时调用的函数
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">mapaccess1</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">key</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="p">{</span>
	<span class="c1">// .............
</span><span class="c1"></span>	<span class="c1">// 检测标记字段 是否不等于0 如果不等于0则代表发生并发读写
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">flags</span><span class="o">&amp;</span><span class="nx">hashWriting</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;concurrent map read and map write&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// .............
</span><span class="c1"></span><span class="p">}</span>
<span class="c1">// runtime.mapaccess2 在 value,ok:=m[key]时调用的函数
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">mapaccess2</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">key</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// .............
</span><span class="c1"></span>	<span class="c1">// 检测标记字段 是否不等于0 如果不等于0则代表发生并发读写
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">flags</span><span class="o">&amp;</span><span class="nx">hashWriting</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;concurrent map read and map write&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// .............
</span><span class="c1"></span><span class="p">}</span>	
</code></pre></div><p>上述源代码做了很大一部分的省略，仅留下了针对并发读写标记的设置、取消、以及检查的语句，在此能看出<code>map</code>的底层根据并发场景做了非线程安全的处理。</p>
<h2 id="如何使得map变成线程安全">如何使得<code>map</code>变成线程安全</h2>
<h3 id="mutexmap的实现"><code>MutexMap</code>的实现</h3>
<p>上面讲了<code>map</code>在并发环境下非线程安全的例子以及原因，那么目前我们如何解决这个问题呢？从之前作者的文章：<a href="https://blog.csdn.net/qq_37005831/article/details/110311956">「Golang」 sync.Mutex源码讲解</a> 中可以看到使用互斥锁可以使得在并发环境下某些对象只能在某些事件内只有一个goroutine持有对其进行CRUD操作，那么我们可以使用互斥锁对<code>map</code>对其进行封装，例子代码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">MutexMap</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">lock</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
	<span class="nx">m</span>    <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">receiver</span> <span class="o">*</span><span class="nx">MutexMap</span><span class="p">)</span> <span class="nf">Get</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">receiver</span><span class="p">.</span><span class="nx">lock</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="nx">value</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">receiver</span><span class="p">.</span><span class="nx">m</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span>
	<span class="nx">receiver</span><span class="p">.</span><span class="nx">lock</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="k">return</span> <span class="nx">value</span><span class="p">,</span> <span class="nx">ok</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">receiver</span> <span class="o">*</span><span class="nx">MutexMap</span><span class="p">)</span> <span class="nf">Set</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">value</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">receiver</span><span class="p">.</span><span class="nx">lock</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="nx">receiver</span><span class="p">.</span><span class="nx">m</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="nx">value</span>
	<span class="nx">receiver</span><span class="p">.</span><span class="nx">lock</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">receiver</span> <span class="o">*</span><span class="nx">MutexMap</span><span class="p">)</span> <span class="nf">Del</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">receiver</span><span class="p">.</span><span class="nx">lock</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="nb">delete</span><span class="p">(</span><span class="nx">receiver</span><span class="p">.</span><span class="nx">m</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span>
	<span class="nx">receiver</span><span class="p">.</span><span class="nx">lock</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><p>上述代码中作者使用了一个结构体对<code>sync.Mutex</code>和<code>map</code>进行了封装，并且对外提供了一系列的方法以供使用，从上述方法中可以看到，在<code>Get(),Set(),Del()</code>方法中进行<code>map</code>操作前均对其进行了互斥锁加锁操作，这样使得该结构体对象可以在并发环境下保证只有一个goroutine持有对其<code>map</code>进行CRUD操作，这样也就消除了并发读写问题的影响。</p>
<h3 id="mutexmap的优化rwmutexmap的诞生"><code>MutexMap</code>的优化，<code>RWMutexMap</code>的诞生</h3>
<p>在上一节中，我们进行了<code>MutexMap</code>的实现，但是有一个问题也就产生了，由于互斥锁的特性，虽然可以提供线程安全的 <code>map</code>，但是在大量并发读写的情况下，锁的竞争会非常激烈。尤其在读的并发非常大的时候，互斥锁会严重影响读取的性能，因为在通过<code>map</code>底层源码发现，并发的读并不会产生<code>panic</code>只有并发读写时，才会发生，因此，互斥锁会导致整体读的效率下降很多，此时我们就应该使用读写锁来进行优化，读写锁相关解析请阅读: <a href="https://blog.csdn.net/qq_37005831/article/details/110739530">「Golang」sync.RWMutex源码讲解</a>，该文章中指出：</p>
<blockquote>
<p>读写锁就是一个可以并发读但是不可以并发写的锁，由于互斥锁的特性，会导致将所有goroutine（下称协程）串行化，从而影响整体程序运行的性能，如果写的数量大于读的数量时，性能损耗暂且可以忽略不计（建议不要忽略），但是当读的数量大于写的数量时，互斥锁对性能的影响是很大的，所以此刻我们需要采用读写锁来进行读操作和写操作的分开。</p>
</blockquote>
<p>现在我们就对<code>MutexMap</code>进行读写锁的优化，优化后的代码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">RWMutexMap</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">lock</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">RWMutex</span>
	<span class="nx">m</span>    <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">receiver</span> <span class="o">*</span><span class="nx">RWMutexMap</span><span class="p">)</span> <span class="nf">Get</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">receiver</span><span class="p">.</span><span class="nx">lock</span><span class="p">.</span><span class="nf">RLock</span><span class="p">()</span>
	<span class="nx">value</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">receiver</span><span class="p">.</span><span class="nx">m</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span>
	<span class="nx">receiver</span><span class="p">.</span><span class="nx">lock</span><span class="p">.</span><span class="nf">RUnlock</span><span class="p">()</span>
	<span class="k">return</span> <span class="nx">value</span><span class="p">,</span> <span class="nx">ok</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">receiver</span> <span class="o">*</span><span class="nx">RWMutexMap</span><span class="p">)</span> <span class="nf">Set</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">value</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">receiver</span><span class="p">.</span><span class="nx">lock</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="nx">receiver</span><span class="p">.</span><span class="nx">m</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="nx">value</span>
	<span class="nx">receiver</span><span class="p">.</span><span class="nx">lock</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">receiver</span> <span class="o">*</span><span class="nx">RWMutexMap</span><span class="p">)</span> <span class="nf">Del</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">receiver</span><span class="p">.</span><span class="nx">lock</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="nb">delete</span><span class="p">(</span><span class="nx">receiver</span><span class="p">.</span><span class="nx">m</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span>
	<span class="nx">receiver</span><span class="p">.</span><span class="nx">lock</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><p>上述代码中，将<code>lock sync.Mutex</code>字段替换成为了<code>lock sync.RWMutex</code>字段，并且将<code>Get()</code>方法转而使用读锁进行加锁，此时，当前的 <code>RWMutexMap</code>结构体就针对读多写少的并发情况有了很好的性能提升，</p>
<h2 id="标准库的syncmap">标准库的<code>sync.Map</code></h2>
<p>标准库中提供了一种官方实现的线程安全的<code>map</code>结构，即<code>sync.Map</code>，该包虽然是线程安全的，但是使用场景很少，这个 <code>sync.Map</code>并不是用来替换内建的 <code>map</code>类型的，它只能被应用在一些特殊的场景里。官方文档指出可以用在以下场景：</p>
<blockquote>
<p>1.只会增长的缓存系统中，一个 key 只写入一次而被读很多次，即读多写少
2.多个 goroutine 为不相交的键集读、写和重写键值对，即多个goroutineCRUD操作不同的key-value</p>
</blockquote>
<p>但是，最好在使用的时候根据场景首先进行性能测试后，再根据性能测试结果选用<code>sync.Map</code>或者<code>RWMutexMap </code>。
<code>sync.Map</code>的实现，其针对<code>RWMutexMap </code>做了下面几个优化。</p>
<ol>
<li>空间换时间。通过冗余的两个数据结构（只读的 read 字段、可写的 dirty），来减少加锁对性能的影响。 对只读字段（read）的操作不需要加锁。</li>
<li>优先从 read 字段读取、更新、删除，因为对 read 字段的读取不需要锁。</li>
<li>动态调整。miss次数多了之后，将 dirty 数据提升为 read，避免总是从 dirty 中加锁读取。</li>
<li>double-checking。加锁之后先还要再检查 read 字段，确定真的不存在才操作 dirty 字段。</li>
<li>延迟删除。删除一个键值只是打标记，只有在提升 dirty字段为 read 字段的时候才清理删除的数据。</li>
</ol>
<p>既然<code>sync.Map</code>这么好，那么就来测试一下<code>MutexMap </code>，<code>RWMutexMap </code>，<code>sync.Map</code>的性能差距吧，下面我针对这两个结构体进行性能测试看看其在大量只读，只写，读写的情况下的性能如何（代码引用于<a href="https://www.jianshu.com/p/cffffa914381">goalng1.14不同场景下sync.Map、Mutex、RWMutex锁性能测试对比</a>）：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;sync&#34;</span>
	<span class="s">&#34;testing&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="p">(</span>
	<span class="nx">num</span>  <span class="p">=</span> <span class="mi">1000</span> <span class="o">*</span> <span class="mi">10</span>
	<span class="nx">gnum</span> <span class="p">=</span> <span class="mi">1000</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">Test_main</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">count</span> <span class="o">:=</span> <span class="mi">10000</span>
	<span class="nx">div</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span> <span class="c1">//抽样写比例 1/5
</span><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;only read&#34;</span><span class="p">)</span>
	<span class="nf">testRwmutexReadOnly</span><span class="p">(</span><span class="nx">count</span><span class="p">)</span>
	<span class="nf">testMutexReadOnly</span><span class="p">(</span><span class="nx">count</span><span class="p">)</span>
	<span class="c1">//test sync.map
</span><span class="c1"></span>	<span class="nf">testSyncMapReadOnly</span><span class="p">(</span><span class="nx">count</span><span class="p">)</span>

	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;write and read&#34;</span><span class="p">)</span>
	<span class="nf">testRwmutexWriteRead</span><span class="p">(</span><span class="nx">count</span><span class="p">,</span> <span class="nx">div</span><span class="p">)</span>
	<span class="nf">testMutexWriteRead</span><span class="p">(</span><span class="nx">count</span><span class="p">,</span> <span class="nx">div</span><span class="p">)</span>
	<span class="nf">testSyncMapWriteRead</span><span class="p">(</span><span class="nx">count</span><span class="p">,</span> <span class="nx">div</span><span class="p">)</span>

	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;write only&#34;</span><span class="p">)</span>
	<span class="nf">testRwmutexWriteOnly</span><span class="p">(</span><span class="nx">count</span><span class="p">)</span>
	<span class="nf">testMutexWriteOnly</span><span class="p">(</span><span class="nx">count</span><span class="p">)</span>
	<span class="nf">testSyncMapWriteOnly</span><span class="p">(</span><span class="nx">count</span><span class="p">)</span>

<span class="p">}</span>

<span class="kd">func</span> <span class="nf">testRwmutexReadOnly</span><span class="p">(</span><span class="nx">count</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">w</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><span class="p">{}</span>
	<span class="kd">var</span> <span class="nx">rwmutexTmp</span> <span class="p">=</span> <span class="nf">newRwmutex</span><span class="p">(</span><span class="nx">count</span><span class="p">)</span>
	<span class="nx">w</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">gnum</span><span class="p">)</span>
	<span class="nx">t1</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">()</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">gnum</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="k">defer</span> <span class="nx">w</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
			<span class="k">for</span> <span class="nx">in</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">in</span> <span class="p">&lt;</span> <span class="nx">num</span><span class="p">;</span> <span class="nx">in</span><span class="o">++</span> <span class="p">{</span>
				<span class="nx">rwmutexTmp</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="nx">in</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}()</span>
	<span class="p">}</span>
	<span class="nx">w</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;testRwmutexReadOnly cost:&#34;</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Sub</span><span class="p">(</span><span class="nx">t1</span><span class="p">).</span><span class="nf">String</span><span class="p">())</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">testRwmutexWriteOnly</span><span class="p">(</span><span class="nx">count</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">w</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><span class="p">{}</span>
	<span class="kd">var</span> <span class="nx">rwmutexTmp</span> <span class="p">=</span> <span class="nf">newRwmutex</span><span class="p">(</span><span class="nx">count</span><span class="p">)</span>
	<span class="nx">w</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">gnum</span><span class="p">)</span>
	<span class="nx">t1</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">()</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">gnum</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="k">defer</span> <span class="nx">w</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
			<span class="k">for</span> <span class="nx">in</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">in</span> <span class="p">&lt;</span> <span class="nx">num</span><span class="p">;</span> <span class="nx">in</span><span class="o">++</span> <span class="p">{</span>
				<span class="nx">rwmutexTmp</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">in</span><span class="p">,</span> <span class="nx">in</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}()</span>
	<span class="p">}</span>
	<span class="nx">w</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;testRwmutexWriteOnly cost:&#34;</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Sub</span><span class="p">(</span><span class="nx">t1</span><span class="p">).</span><span class="nf">String</span><span class="p">())</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">testRwmutexWriteRead</span><span class="p">(</span><span class="nx">count</span><span class="p">,</span> <span class="nx">div</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">w</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><span class="p">{}</span>
	<span class="kd">var</span> <span class="nx">rwmutexTmp</span> <span class="p">=</span> <span class="nf">newRwmutex</span><span class="p">(</span><span class="nx">count</span><span class="p">)</span>
	<span class="nx">w</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">gnum</span><span class="p">)</span>
	<span class="nx">t1</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">()</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">gnum</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">i</span><span class="o">%</span><span class="nx">div</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
				<span class="k">defer</span> <span class="nx">w</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
				<span class="k">for</span> <span class="nx">in</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">in</span> <span class="p">&lt;</span> <span class="nx">num</span><span class="p">;</span> <span class="nx">in</span><span class="o">++</span> <span class="p">{</span>
					<span class="nx">rwmutexTmp</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="nx">in</span><span class="p">)</span>
				<span class="p">}</span>
			<span class="p">}()</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
				<span class="k">defer</span> <span class="nx">w</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
				<span class="k">for</span> <span class="nx">in</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">in</span> <span class="p">&lt;</span> <span class="nx">num</span><span class="p">;</span> <span class="nx">in</span><span class="o">++</span> <span class="p">{</span>
					<span class="nx">rwmutexTmp</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">in</span><span class="p">,</span> <span class="nx">in</span><span class="p">)</span>
				<span class="p">}</span>
			<span class="p">}()</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nx">w</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;testRwmutexWriteRead cost:&#34;</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Sub</span><span class="p">(</span><span class="nx">t1</span><span class="p">).</span><span class="nf">String</span><span class="p">())</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">testMutexReadOnly</span><span class="p">(</span><span class="nx">count</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">w</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><span class="p">{}</span>
	<span class="kd">var</span> <span class="nx">mutexTmp</span> <span class="p">=</span> <span class="nf">newMutex</span><span class="p">(</span><span class="nx">count</span><span class="p">)</span>
	<span class="nx">w</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">gnum</span><span class="p">)</span>

	<span class="nx">t1</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">()</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">gnum</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="k">defer</span> <span class="nx">w</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
			<span class="k">for</span> <span class="nx">in</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">in</span> <span class="p">&lt;</span> <span class="nx">num</span><span class="p">;</span> <span class="nx">in</span><span class="o">++</span> <span class="p">{</span>
				<span class="nx">mutexTmp</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="nx">in</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}()</span>
	<span class="p">}</span>
	<span class="nx">w</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;testMutexReadOnly cost:&#34;</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Sub</span><span class="p">(</span><span class="nx">t1</span><span class="p">).</span><span class="nf">String</span><span class="p">())</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">testMutexWriteOnly</span><span class="p">(</span><span class="nx">count</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">w</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><span class="p">{}</span>
	<span class="kd">var</span> <span class="nx">mutexTmp</span> <span class="p">=</span> <span class="nf">newMutex</span><span class="p">(</span><span class="nx">count</span><span class="p">)</span>
	<span class="nx">w</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">gnum</span><span class="p">)</span>

	<span class="nx">t1</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">()</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">gnum</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="k">defer</span> <span class="nx">w</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
			<span class="k">for</span> <span class="nx">in</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">in</span> <span class="p">&lt;</span> <span class="nx">num</span><span class="p">;</span> <span class="nx">in</span><span class="o">++</span> <span class="p">{</span>
				<span class="nx">mutexTmp</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">in</span><span class="p">,</span> <span class="nx">in</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}()</span>
	<span class="p">}</span>
	<span class="nx">w</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;testMutexWriteOnly cost:&#34;</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Sub</span><span class="p">(</span><span class="nx">t1</span><span class="p">).</span><span class="nf">String</span><span class="p">())</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">testMutexWriteRead</span><span class="p">(</span><span class="nx">count</span><span class="p">,</span> <span class="nx">div</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">w</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><span class="p">{}</span>
	<span class="kd">var</span> <span class="nx">mutexTmp</span> <span class="p">=</span> <span class="nf">newMutex</span><span class="p">(</span><span class="nx">count</span><span class="p">)</span>
	<span class="nx">w</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">gnum</span><span class="p">)</span>
	<span class="nx">t1</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">()</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">gnum</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">i</span><span class="o">%</span><span class="nx">div</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
				<span class="k">defer</span> <span class="nx">w</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
				<span class="k">for</span> <span class="nx">in</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">in</span> <span class="p">&lt;</span> <span class="nx">num</span><span class="p">;</span> <span class="nx">in</span><span class="o">++</span> <span class="p">{</span>
					<span class="nx">mutexTmp</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="nx">in</span><span class="p">)</span>
				<span class="p">}</span>
			<span class="p">}()</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
				<span class="k">defer</span> <span class="nx">w</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
				<span class="k">for</span> <span class="nx">in</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">in</span> <span class="p">&lt;</span> <span class="nx">num</span><span class="p">;</span> <span class="nx">in</span><span class="o">++</span> <span class="p">{</span>
					<span class="nx">mutexTmp</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">in</span><span class="p">,</span> <span class="nx">in</span><span class="p">)</span>
				<span class="p">}</span>
			<span class="p">}()</span>
		<span class="p">}</span>

	<span class="p">}</span>
	<span class="nx">w</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;testMutexWriteRead cost:&#34;</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Sub</span><span class="p">(</span><span class="nx">t1</span><span class="p">).</span><span class="nf">String</span><span class="p">())</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">testSyncMapReadOnly</span><span class="p">(</span><span class="nx">count</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">w</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><span class="p">{}</span>
	<span class="kd">var</span> <span class="nx">mutexTmp</span> <span class="p">=</span> <span class="nf">newSyncMap</span><span class="p">(</span><span class="nx">count</span><span class="p">)</span>
	<span class="nx">w</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">gnum</span><span class="p">)</span>

	<span class="nx">t1</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">()</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">gnum</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="k">defer</span> <span class="nx">w</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
			<span class="k">for</span> <span class="nx">in</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">in</span> <span class="p">&lt;</span> <span class="nx">num</span><span class="p">;</span> <span class="nx">in</span><span class="o">++</span> <span class="p">{</span>
				<span class="nx">mutexTmp</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="nx">in</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}()</span>
	<span class="p">}</span>
	<span class="nx">w</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;testSyncMapReadOnly cost:&#34;</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Sub</span><span class="p">(</span><span class="nx">t1</span><span class="p">).</span><span class="nf">String</span><span class="p">())</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">testSyncMapWriteOnly</span><span class="p">(</span><span class="nx">count</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">w</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><span class="p">{}</span>
	<span class="kd">var</span> <span class="nx">mutexTmp</span> <span class="p">=</span> <span class="nf">newSyncMap</span><span class="p">(</span><span class="nx">count</span><span class="p">)</span>
	<span class="nx">w</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">gnum</span><span class="p">)</span>

	<span class="nx">t1</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">()</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">gnum</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="k">defer</span> <span class="nx">w</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
			<span class="k">for</span> <span class="nx">in</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">in</span> <span class="p">&lt;</span> <span class="nx">num</span><span class="p">;</span> <span class="nx">in</span><span class="o">++</span> <span class="p">{</span>
				<span class="nx">mutexTmp</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="nx">in</span><span class="p">,</span> <span class="nx">in</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}()</span>
	<span class="p">}</span>
	<span class="nx">w</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;testSyncMapWriteOnly cost:&#34;</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Sub</span><span class="p">(</span><span class="nx">t1</span><span class="p">).</span><span class="nf">String</span><span class="p">())</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">testSyncMapWriteRead</span><span class="p">(</span><span class="nx">count</span><span class="p">,</span> <span class="nx">div</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">w</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><span class="p">{}</span>
	<span class="kd">var</span> <span class="nx">mutexTmp</span> <span class="p">=</span> <span class="nf">newSyncMap</span><span class="p">(</span><span class="nx">count</span><span class="p">)</span>
	<span class="nx">w</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">gnum</span><span class="p">)</span>
	<span class="nx">t1</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">()</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">gnum</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">i</span><span class="o">%</span><span class="nx">div</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
				<span class="k">defer</span> <span class="nx">w</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
				<span class="k">for</span> <span class="nx">in</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">in</span> <span class="p">&lt;</span> <span class="nx">num</span><span class="p">;</span> <span class="nx">in</span><span class="o">++</span> <span class="p">{</span>
					<span class="nx">mutexTmp</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="nx">in</span><span class="p">)</span>
				<span class="p">}</span>
			<span class="p">}()</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
				<span class="k">defer</span> <span class="nx">w</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
				<span class="k">for</span> <span class="nx">in</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">in</span> <span class="p">&lt;</span> <span class="nx">num</span><span class="p">;</span> <span class="nx">in</span><span class="o">++</span> <span class="p">{</span>
					<span class="nx">mutexTmp</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="nx">in</span><span class="p">,</span> <span class="nx">in</span><span class="p">)</span>
				<span class="p">}</span>
			<span class="p">}()</span>
		<span class="p">}</span>

	<span class="p">}</span>
	<span class="nx">w</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;testSyncMapWriteRead cost:&#34;</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Sub</span><span class="p">(</span><span class="nx">t1</span><span class="p">).</span><span class="nf">String</span><span class="p">())</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">newRwmutex</span><span class="p">(</span><span class="nx">count</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">rwmutex</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">t</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">rwmutex</span><span class="p">{}</span>
	<span class="nx">t</span><span class="p">.</span><span class="nx">mu</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">sync</span><span class="p">.</span><span class="nx">RWMutex</span><span class="p">{}</span>
	<span class="nx">t</span><span class="p">.</span><span class="nx">ipmap</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">count</span><span class="p">)</span>

	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">count</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">t</span><span class="p">.</span><span class="nx">ipmap</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">t</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">rwmutex</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">mu</span>    <span class="o">*</span><span class="nx">sync</span><span class="p">.</span><span class="nx">RWMutex</span>
	<span class="nx">ipmap</span> <span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">int</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">rwmutex</span><span class="p">)</span> <span class="nf">get</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">t</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">RLock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">t</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">RUnlock</span><span class="p">()</span>

	<span class="k">return</span> <span class="nx">t</span><span class="p">.</span><span class="nx">ipmap</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">rwmutex</span><span class="p">)</span> <span class="nf">set</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">v</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">t</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">t</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

	<span class="nx">t</span><span class="p">.</span><span class="nx">ipmap</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span> <span class="p">=</span> <span class="nx">v</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">newMutex</span><span class="p">(</span><span class="nx">count</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">mutex</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">t</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">mutex</span><span class="p">{}</span>
	<span class="nx">t</span><span class="p">.</span><span class="nx">mu</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span><span class="p">{}</span>
	<span class="nx">t</span><span class="p">.</span><span class="nx">ipmap</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">count</span><span class="p">)</span>

	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">count</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">t</span><span class="p">.</span><span class="nx">ipmap</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">t</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">newSyncMap</span><span class="p">(</span><span class="nx">count</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">sync</span><span class="p">.</span><span class="nx">Map</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">t</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">sync</span><span class="p">.</span><span class="nx">Map</span><span class="p">{}</span>

	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">count</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">t</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">t</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">mutex</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">mu</span>    <span class="o">*</span><span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
	<span class="nx">ipmap</span> <span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">int</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">mutex</span><span class="p">)</span> <span class="nf">get</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">t</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">t</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

	<span class="k">return</span> <span class="nx">t</span><span class="p">.</span><span class="nx">ipmap</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">mutex</span><span class="p">)</span> <span class="nf">set</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">v</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">t</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">t</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

	<span class="nx">k</span> <span class="p">=</span> <span class="nx">k</span> <span class="o">%</span> <span class="mi">100</span>
	<span class="nx">t</span><span class="p">.</span><span class="nx">ipmap</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span> <span class="p">=</span> <span class="nx">v</span>
<span class="p">}</span>
<span class="c1">// only read
</span><span class="c1">// testRwmutexReadOnly cost: 346.72604ms
</span><span class="c1">// testMutexReadOnly cost: 1.56353484s
</span><span class="c1">// testSyncMapReadOnly cost: 94.436269ms
</span><span class="c1">// write and read
</span><span class="c1">// testRwmutexWriteRead cost: 511.433544ms
</span><span class="c1">// testMutexWriteRead cost: 1.439301381s
</span><span class="c1">// testSyncMapWriteRead cost: 106.220371ms
</span><span class="c1">// write only
</span><span class="c1">// testRwmutexWriteOnly cost: 2.579502195s
</span><span class="c1">// testMutexWriteOnly cost: 1.922190051s
</span><span class="c1">// testSyncMapWriteOnly cost: 4.177583278s
</span></code></pre></div><p>结论：</p>
<blockquote>
<p>只读场景：sync.map &gt; rwmutex &raquo; mutex
读写场景（边读边写）：rwmutex &gt; mutex &raquo; sync.map
读写场景（读80% 写20%）：sync.map &gt; rwmutex &gt; mutex
读写场景（读98% 写2%）：sync.map &gt; rwmutex &raquo; mutex
只写场景：sync.map &raquo; mutex &gt; rwmutex</p>
</blockquote>
<h2 id="使用环境不负责任推荐">使用环境不负责任推荐</h2>
<p>关于<code>MutexMap </code>，<code>RWMutexMap </code>，<code>sync.Map</code>的选择问题，其实不一定只能看上述的测试结论，还需要根据应用场合以及实际情况来使用，根据我自己的情况来看的话，有以下几个方面可以考虑，只是我个人见解。</p>
<ol>
<li>由于<code>sync.Map</code>的通用性的问题，所以返回的值均为<code>interface{}</code>类型，这样在我们进行一些操作的时候就会需要不断的去断言他，导致麻烦，此时如果性能要求不是特别高的情况下可以使用<code>RWMutexMap </code>用作专用性替换，这样可以免去了断言的一些性能损耗和麻烦。</li>
<li>之前看过一篇文章，<code>RWMutexMap </code>在并发量异常庞大的时候性能下降会很快，比如1000万，所以如果高并发的时候尽可能采用<code>sync.Map</code></li>
<li>当读写均多的时候<code>sync.Map</code>就显得力不从心，因为其内部实现原因需要针对只读<code>map</code>进行适时更换，如果一旦写入过多，就会导致更换的过于频繁，但是<code>RWMutexMap </code>就不会产生这个问题，除扩容和写锁的性能下降外，基本上没有什么其他损耗。</li>
<li>如果<code>map</code>遍历情况过多请使用<code>RWMutexMap </code>，因为<code>sync.Map</code>的时间复杂度最低为O(n)，所以此时<code>sync.Map</code>的遍历性能就很差了。</li>
</ol>
]]></content>
		</item>
		
		<item>
			<title>「Golang」Slice源码讲解</title>
			<link>http://echoblog.cc/posts/golangslice%E6%BA%90%E7%A0%81%E8%AE%B2%E8%A7%A3/</link>
			<pubDate>Mon, 04 Jan 2021 00:00:00 +0000</pubDate>
			
			<guid>http://echoblog.cc/posts/golangslice%E6%BA%90%E7%A0%81%E8%AE%B2%E8%A7%A3/</guid>
			<description>前言  ​ 在golang中有很多的数据结构是很常用的数据结构，比如array，slice，map等，其中最为常用的就是array和slice还有map了，理论上来讲array和slice在数据结构上是一种结构，都是顺序结构，但是由于array的固定长度特性，在有些时候对于需要动态的长度的使用情况很不友好，此时就需要利用slice进行对固定长度数组的代替
 什么是Slice  官方解释如下：
​	Slices wrap arrays to give a more general, powerful, and convenient interface to sequences of data. Except for items with explicit dimension such as transformation matrices, most array programming in Go is done with slices rather than simple arrays.
大概意思如下：
​	Slice是一个经过包装的array，其可为数据序列提供更通用，更强大和更方便的接口。 除了具有明确维数的项（例如转换矩阵）外，Go中的大多数数组编程都是使用切片而不是简单数组完成的。
 ​	切片个人认为有点像c++标准库中的vector，只不过是底层的实现方式可能有些许不同（不太了解c++，如果有大佬知道vector的底层实现的话，可以解惑一下），slice是一个把go数组进行了包装的一个结构体，但是这个结构体只是在编译等其他层面能看到，在我们使用过程中只需要像定义数组那样定义就可以在编译期间被转换为slice结构体。接下来我来解析一下slice的相关结构体源代码以及操作源代码。
代码解析  本篇文章所有代码基于Go1.15+版本编写
 slice的结构体 // slice 结构体，这个结构体会在编译期间构建 // 如果想在运行期间使用的话可以使用其对应的reflect结构体 // 即reflect.SliceHeader type slice struct { // 一个指向底层数组的指针 	array unsafe.</description>
			<content type="html"><![CDATA[<h2 id="前言">前言</h2>
<blockquote>
<p>​        在golang中有很多的数据结构是很常用的数据结构，比如array，slice，map等，其中最为常用的就是array和slice还有map了，理论上来讲array和slice在数据结构上是一种结构，都是顺序结构，但是由于array的固定长度特性，在有些时候对于需要动态的长度的使用情况很不友好，此时就需要利用slice进行对固定长度数组的代替</p>
</blockquote>
<h2 id="什么是slice">什么是Slice</h2>
<blockquote>
<p>官方解释如下：</p>
<p>​		Slices wrap arrays to give a more general, powerful, and convenient interface to sequences of data. Except for items with explicit dimension such as transformation matrices, most array programming in Go is done with slices rather than simple arrays.</p>
<p>大概意思如下：</p>
<p>​		Slice是一个经过包装的array，其可为数据序列提供更通用，更强大和更方便的接口。 除了具有明确维数的项（例如转换矩阵）外，Go中的大多数数组编程都是使用切片而不是简单数组完成的。</p>
</blockquote>
<p>​		切片个人认为有点像c++标准库中的vector，只不过是底层的实现方式可能有些许不同（不太了解c++，如果有大佬知道vector的底层实现的话，可以解惑一下），slice是一个把go数组进行了包装的一个结构体，但是这个结构体只是在编译等其他层面能看到，在我们使用过程中只需要像定义数组那样定义就可以在编译期间被转换为slice结构体。接下来我来解析一下slice的相关结构体源代码以及操作源代码。</p>
<h2 id="代码解析">代码解析</h2>
<blockquote>
<p>本篇文章所有代码基于Go1.15+版本编写</p>
</blockquote>
<h3 id="slice的结构体">slice的结构体</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// slice 结构体，这个结构体会在编译期间构建
</span><span class="c1">// 如果想在运行期间使用的话可以使用其对应的reflect结构体
</span><span class="c1">// 即reflect.SliceHeader
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">slice</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// 一个指向底层数组的指针
</span><span class="c1"></span>	<span class="nx">array</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
	<span class="c1">// slice当前元素个数 即len()时返回的数
</span><span class="c1"></span>	<span class="nx">len</span>   <span class="kt">int</span>
	<span class="c1">// slice的容量 即cap()时返回的数
</span><span class="c1"></span>	<span class="nx">cap</span>   <span class="kt">int</span>
<span class="p">}</span>
</code></pre></div><h3 id="slice的初始化">slice的初始化</h3>
<p>slice的初始化方式分为三种：</p>
<ol>
<li>
<p>下标初始化方式：<code>a:=slice[:] // 这个slice是一个其他以创建好的slice</code>。这种创建方式时最接近底层的创建方式，在编译期间该语句会被转换为编译器的<code>OpSliceMake</code>操作,该操作会调用<code>SliceMake</code>操作，<code>SliceMake</code>操作会接受四个参数创建新的切片，元素类型、数组指针、切片大小和容量，这与上一章所展示的slice的结构体的字段构成相同，<strong>另外下标初始化方式不会对原数组中的数据进行复制，而是直接引用指向原数组的指针，这会导致在修改切片<code>a</code>时，对原切片<code>slice</code>也会产生影响。</strong></p>
</li>
<li>
<p>字面量初始化方式:```a:=[]int{1,2,3}``，过程如下</p>
<ol>
<li>该方法在编译期间创建首先会生成一个长度为3（该长度根据字面量数量自动推断）的数组</li>
<li>给这个数组的元素进行赋值</li>
<li>而后会new出一个新的长度为3（该长度根据字面量数量</li>
<li>自动推断）的数组的指针</li>
<li>将这个指针按照最基本的下标初始化方式进行赋值给slice</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">arr</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">int</span>
<span class="nx">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1</span>
<span class="nx">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="mi">2</span>
<span class="nx">arr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="p">=</span> <span class="mi">3</span>
<span class="kd">var</span> <span class="nx">arrp</span> <span class="o">*</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">int</span> <span class="p">=</span> <span class="nb">new</span><span class="p">([</span><span class="mi">3</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>
<span class="o">*</span><span class="nx">arrp</span> <span class="p">=</span> <span class="nx">arr</span>
<span class="nx">slice</span> <span class="o">:=</span> <span class="nx">arrp</span><span class="p">[:]</span>
</code></pre></div></li>
<li>
<p>通过关键字<code>make([]int,3,3)</code>创建切片：通过<code>make</code>关键字进行切片初始化，首先会在编译阶段对其传入的len与cap进行校验，校验其是否为负值，是否<code>len</code>&gt;<code>cap</code>，并且通过判断切片的大小以及是否逃逸来确定其是否会初始化在堆上，如果当切片足够小并且没有发生逃逸时，会创建一个<code>cap</code>值的数组，然后像字面量初始化方式一样对其进行初始化，如果<code>cap</code>为0，则按照<code>len</code>的值创建对应长度的数组。如果发生逃逸或者切片过大时，会调用<code>runtime.makeslice()</code>函数进行堆上的切片内存分配。<code>runtime.makeslice</code>代码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 该函数传入需要初始化的切片的类型，长度以及容量，返回的指针会通过调用方组建成一个完成的slice结构体
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">makeslice</span><span class="p">(</span><span class="nx">et</span> <span class="o">*</span><span class="nx">_type</span><span class="p">,</span> <span class="nx">len</span><span class="p">,</span> <span class="nx">cap</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="p">{</span>
  <span class="c1">// 判断类型，和容量的乘积会不会超过可分配内存的大小，以及长度是否为0和容量是否小于长度
</span><span class="c1"></span> <span class="nx">mem</span><span class="p">,</span> <span class="nx">overflow</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nf">MulUintptr</span><span class="p">(</span><span class="nx">et</span><span class="p">.</span><span class="nx">size</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">cap</span><span class="p">))</span>
 <span class="k">if</span> <span class="nx">overflow</span> <span class="o">||</span> <span class="nx">mem</span> <span class="p">&gt;</span> <span class="nx">maxAlloc</span> <span class="o">||</span> <span class="nx">len</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">len</span> <span class="p">&gt;</span> <span class="nx">cap</span> <span class="p">{</span>
     <span class="nx">mem</span><span class="p">,</span> <span class="nx">overflow</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nf">MulUintptr</span><span class="p">(</span><span class="nx">et</span><span class="p">.</span><span class="nx">size</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">len</span><span class="p">))</span>
     <span class="k">if</span> <span class="nx">overflow</span> <span class="o">||</span> <span class="nx">mem</span> <span class="p">&gt;</span> <span class="nx">maxAlloc</span> <span class="o">||</span> <span class="nx">len</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
         <span class="nf">panicmakeslicelen</span><span class="p">()</span>
     <span class="p">}</span>
     <span class="nf">panicmakeslicecap</span><span class="p">()</span>
 <span class="p">}</span>
 <span class="c1">// 如果都正常，则调用此函数申请返回一个连续 切片中元素大小×切片容量 长度的内存空间的指针
</span><span class="c1"></span> <span class="k">return</span> <span class="nf">mallocgc</span><span class="p">(</span><span class="nx">mem</span><span class="p">,</span> <span class="nx">et</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></li>
</ol>
<h3 id="访问元素">访问元素</h3>
<p>slice的访问元素是通过slice结构体中
$$
对应索引的元素地址=指向底层数组的指针+对应元素的占用字节数*索引
$$
编译器会通过对应索引的元素地址返回其中对应的值，即直接进行地址访问</p>
<h3 id="追加和扩容">追加和扩容</h3>
<p>​		slice相比于array的一大优点就是可以根据使用情况动态的进行扩容，来适应随时增加的数据，在追加时，通过调用<code>append</code>函数来针对slice进行尾部追加，如果此时slice的<code>cap</code>值小于当前<code>len</code>加上<code>append</code>中传入值的数量，那么就会出发扩容操作，<code>append</code>函数没有明确的函数体，而是通过编译期间被转换。当<code>append</code>发现需要扩容时，则会调用<code>runtime.growslice</code>方法，该方法源代码如下（以去除一些无用代码）：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">growslice</span><span class="p">(</span><span class="nx">et</span> <span class="o">*</span><span class="nx">_type</span><span class="p">,</span> <span class="nx">old</span> <span class="nx">slice</span><span class="p">,</span> <span class="nx">cap</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">slice</span> <span class="p">{</span>
	<span class="c1">// 如果需求的容量小于就容量则报错
</span><span class="c1"></span>  <span class="c1">// 理论上来讲不应该出现这个问题
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">cap</span> <span class="p">&lt;</span> <span class="nx">old</span><span class="p">.</span><span class="nx">cap</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nf">errorString</span><span class="p">(</span><span class="s">&#34;growslice: cap out of range&#34;</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="c1">// append 没法创建一个nil指针的但是len不为0的切片
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">et</span><span class="p">.</span><span class="nx">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">slice</span><span class="p">{</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">zerobase</span><span class="p">),</span> <span class="nx">old</span><span class="p">.</span><span class="nx">len</span><span class="p">,</span> <span class="nx">cap</span><span class="p">}</span>
	<span class="p">}</span>
	
	<span class="nx">newcap</span> <span class="o">:=</span> <span class="nx">old</span><span class="p">.</span><span class="nx">cap</span>
	<span class="nx">doublecap</span> <span class="o">:=</span> <span class="nx">newcap</span> <span class="o">+</span> <span class="nx">newcap</span>
  <span class="c1">// 如果需求容量大于双倍的旧容量那就直接使用需求容量
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">cap</span> <span class="p">&gt;</span> <span class="nx">doublecap</span> <span class="p">{</span>
		<span class="nx">newcap</span> <span class="p">=</span> <span class="nx">cap</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// 如果当前len小于1024则容量直接翻倍，否则按照1.25倍去递增直到满足需求容量
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">old</span><span class="p">.</span><span class="nx">len</span> <span class="p">&lt;</span> <span class="mi">1024</span> <span class="p">{</span>
			<span class="nx">newcap</span> <span class="p">=</span> <span class="nx">doublecap</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">for</span> <span class="mi">0</span> <span class="p">&lt;</span> <span class="nx">newcap</span> <span class="o">&amp;&amp;</span> <span class="nx">newcap</span> <span class="p">&lt;</span> <span class="nx">cap</span> <span class="p">{</span>
				<span class="nx">newcap</span> <span class="o">+=</span> <span class="nx">newcap</span> <span class="o">/</span> <span class="mi">4</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">newcap</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">newcap</span> <span class="p">=</span> <span class="nx">cap</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="kd">var</span> <span class="nx">overflow</span> <span class="kt">bool</span>
	<span class="kd">var</span> <span class="nx">lenmem</span><span class="p">,</span> <span class="nx">newlenmem</span><span class="p">,</span> <span class="nx">capmem</span> <span class="kt">uintptr</span>
<span class="c1">// 在扩容时不能单单按照len来判断扩容所需要的内存长度
</span><span class="c1">// 还要根据切片的元素类型去进行内存对齐
</span><span class="c1">// 当元素的占用字节数为1，8 或者2的倍数时会进行内存对对齐
</span><span class="c1">// 内存对齐策略按照向上取整方式进行
</span><span class="c1">// 取整的目标时go内存分配策略中67个class分页中的大小进行取整
</span><span class="c1"></span>	<span class="k">switch</span> <span class="p">{</span>
	<span class="k">case</span> <span class="nx">et</span><span class="p">.</span><span class="nx">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
		<span class="nx">lenmem</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">old</span><span class="p">.</span><span class="nx">len</span><span class="p">)</span>
		<span class="nx">newlenmem</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">cap</span><span class="p">)</span>
		<span class="nx">capmem</span> <span class="p">=</span> <span class="nf">roundupsize</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">newcap</span><span class="p">))</span>
		<span class="nx">overflow</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">newcap</span><span class="p">)</span> <span class="p">&gt;</span> <span class="nx">maxAlloc</span>
		<span class="nx">newcap</span> <span class="p">=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">capmem</span><span class="p">)</span>
	<span class="k">case</span> <span class="nx">et</span><span class="p">.</span><span class="nx">size</span> <span class="o">==</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">:</span>
		<span class="nx">lenmem</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">old</span><span class="p">.</span><span class="nx">len</span><span class="p">)</span> <span class="o">*</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span>
		<span class="nx">newlenmem</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">cap</span><span class="p">)</span> <span class="o">*</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span>
		<span class="nx">capmem</span> <span class="p">=</span> <span class="nf">roundupsize</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">newcap</span><span class="p">)</span> <span class="o">*</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">)</span>
		<span class="nx">overflow</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">newcap</span><span class="p">)</span> <span class="p">&gt;</span> <span class="nx">maxAlloc</span><span class="o">/</span><span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span>
		<span class="nx">newcap</span> <span class="p">=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">capmem</span> <span class="o">/</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">)</span>
	<span class="k">case</span> <span class="nf">isPowerOfTwo</span><span class="p">(</span><span class="nx">et</span><span class="p">.</span><span class="nx">size</span><span class="p">):</span>
		<span class="kd">var</span> <span class="nx">shift</span> <span class="kt">uintptr</span>
		<span class="k">if</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span> <span class="o">==</span> <span class="mi">8</span> <span class="p">{</span>
			<span class="c1">// Mask shift for better code generation.
</span><span class="c1"></span>			<span class="nx">shift</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">sys</span><span class="p">.</span><span class="nf">Ctz64</span><span class="p">(</span><span class="nb">uint64</span><span class="p">(</span><span class="nx">et</span><span class="p">.</span><span class="nx">size</span><span class="p">)))</span> <span class="o">&amp;</span> <span class="mi">63</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">shift</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">sys</span><span class="p">.</span><span class="nf">Ctz32</span><span class="p">(</span><span class="nb">uint32</span><span class="p">(</span><span class="nx">et</span><span class="p">.</span><span class="nx">size</span><span class="p">)))</span> <span class="o">&amp;</span> <span class="mi">31</span>
		<span class="p">}</span>
		<span class="nx">lenmem</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">old</span><span class="p">.</span><span class="nx">len</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="nx">shift</span>
		<span class="nx">newlenmem</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">cap</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="nx">shift</span>
		<span class="nx">capmem</span> <span class="p">=</span> <span class="nf">roundupsize</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">newcap</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="nx">shift</span><span class="p">)</span>
		<span class="nx">overflow</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">newcap</span><span class="p">)</span> <span class="p">&gt;</span> <span class="p">(</span><span class="nx">maxAlloc</span> <span class="o">&gt;&gt;</span> <span class="nx">shift</span><span class="p">)</span>
		<span class="nx">newcap</span> <span class="p">=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">capmem</span> <span class="o">&gt;&gt;</span> <span class="nx">shift</span><span class="p">)</span>
	<span class="k">default</span><span class="p">:</span>
		<span class="nx">lenmem</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">old</span><span class="p">.</span><span class="nx">len</span><span class="p">)</span> <span class="o">*</span> <span class="nx">et</span><span class="p">.</span><span class="nx">size</span>
		<span class="nx">newlenmem</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">cap</span><span class="p">)</span> <span class="o">*</span> <span class="nx">et</span><span class="p">.</span><span class="nx">size</span>
		<span class="nx">capmem</span><span class="p">,</span> <span class="nx">overflow</span> <span class="p">=</span> <span class="nx">math</span><span class="p">.</span><span class="nf">MulUintptr</span><span class="p">(</span><span class="nx">et</span><span class="p">.</span><span class="nx">size</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">newcap</span><span class="p">))</span>
		<span class="nx">capmem</span> <span class="p">=</span> <span class="nf">roundupsize</span><span class="p">(</span><span class="nx">capmem</span><span class="p">)</span>
		<span class="nx">newcap</span> <span class="p">=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">capmem</span> <span class="o">/</span> <span class="nx">et</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span>
	<span class="p">}</span>

<span class="c1">// 如果所需要的内存超过了最大可分配内存则panic
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">overflow</span> <span class="o">||</span> <span class="nx">capmem</span> <span class="p">&gt;</span> <span class="nx">maxAlloc</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nf">errorString</span><span class="p">(</span><span class="s">&#34;growslice: cap out of range&#34;</span><span class="p">))</span>
	<span class="p">}</span>

	<span class="kd">var</span> <span class="nx">p</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
  <span class="c1">// 如果当前元素类型不是指针，则会将超出切片当前长度的位置清空
</span><span class="c1"></span>  <span class="c1">// 并在最后使用 将原数组内存中的内容拷贝到新申请的内存中。
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">et</span><span class="p">.</span><span class="nx">ptrdata</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">p</span> <span class="p">=</span> <span class="nf">mallocgc</span><span class="p">(</span><span class="nx">capmem</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
		<span class="nf">memclrNoHeapPointers</span><span class="p">(</span><span class="nf">add</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">newlenmem</span><span class="p">),</span> <span class="nx">capmem</span><span class="o">-</span><span class="nx">newlenmem</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// 如果是指针会根据进行gc方面对其进行加以保护以免空指针在分配期间被gc回收
</span><span class="c1"></span>		<span class="nx">p</span> <span class="p">=</span> <span class="nf">mallocgc</span><span class="p">(</span><span class="nx">capmem</span><span class="p">,</span> <span class="nx">et</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">lenmem</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">writeBarrier</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
			<span class="nf">bulkBarrierPreWriteSrcOnly</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">p</span><span class="p">),</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">old</span><span class="p">.</span><span class="nx">array</span><span class="p">),</span> <span class="nx">lenmem</span><span class="o">-</span><span class="nx">et</span><span class="p">.</span><span class="nx">size</span><span class="o">+</span><span class="nx">et</span><span class="p">.</span><span class="nx">ptrdata</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nf">memmove</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">old</span><span class="p">.</span><span class="nx">array</span><span class="p">,</span> <span class="nx">lenmem</span><span class="p">)</span>
	<span class="c1">//该函数最终会返回一个新的切片
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">slice</span><span class="p">{</span><span class="nx">p</span><span class="p">,</span> <span class="nx">old</span><span class="p">.</span><span class="nx">len</span><span class="p">,</span> <span class="nx">newcap</span><span class="p">}</span>
<span class="p">}</span>

</code></pre></div><h3 id="slice的拷贝">slice的拷贝</h3>
<p>slice的拷贝也是针对切片提供的接口，可以通过调用<code>copy()</code>函数将src切片中的值拷贝到dst切片中，通过该函数进行的切片拷贝后，针对dst切片进行的操作不会对src产生任何的影响，其拷贝长度是按照src与dst切片中最小的len长度去计算的，<code>runtime.slicecopy</code>源代码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">slicecopy</span><span class="p">(</span><span class="nx">toPtr</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">toLen</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">fmPtr</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">fmLen</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">width</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">fmLen</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">toLen</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span>
	<span class="p">}</span>

	<span class="nx">n</span> <span class="o">:=</span> <span class="nx">fmLen</span>
	<span class="k">if</span> <span class="nx">toLen</span> <span class="p">&lt;</span> <span class="nx">n</span> <span class="p">{</span>
		<span class="nx">n</span> <span class="p">=</span> <span class="nx">toLen</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">width</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">n</span>
	<span class="p">}</span>
	
	<span class="nx">size</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="o">*</span> <span class="nx">width</span>
	<span class="k">if</span> <span class="nx">size</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>  
    <span class="c1">// 如果就1个元素 直接赋值过去就好了
</span><span class="c1"></span>		<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">byte</span><span class="p">)(</span><span class="nx">toPtr</span><span class="p">)</span> <span class="p">=</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">byte</span><span class="p">)(</span><span class="nx">fmPtr</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// 直接进行内存的拷贝，如果slice数据量过大将会影响性能
</span><span class="c1"></span>		<span class="nf">memmove</span><span class="p">(</span><span class="nx">toPtr</span><span class="p">,</span> <span class="nx">fmPtr</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">n</span>
<span class="p">}</span>
</code></pre></div><h2 id="总结">总结</h2>
<p>至此slice的源码解析就解析完了，可能有些地方有些理解上的错误，请各位谅解并且帮忙指出修改意见，如果这篇文章能帮到你，这是我的荣幸。</p>
]]></content>
		</item>
		
		<item>
			<title>「Golang」sync.Once用法以及源码讲解</title>
			<link>http://echoblog.cc/posts/golangsync.once%E7%94%A8%E6%B3%95%E4%BB%A5%E5%8F%8A%E6%BA%90%E7%A0%81%E8%AE%B2%E8%A7%A3/</link>
			<pubDate>Mon, 04 Jan 2021 00:00:00 +0000</pubDate>
			
			<guid>http://echoblog.cc/posts/golangsync.once%E7%94%A8%E6%B3%95%E4%BB%A5%E5%8F%8A%E6%BA%90%E7%A0%81%E8%AE%B2%E8%A7%A3/</guid>
			<description>前言  在我们开发过程中经常会使用到单例模式这一经典的设计模式，单例模式可以帮助开发者针对某个（些）变量或者对象或者函数（方法）进行在程序运行期间只有一次的初始化或者函数调用操作，比如在开发项目中针对某一类连接池的初始化（如数据库连接池等）。针对这种情况，我们就需要使用单例模式进行操作。
 单例模式🌰 自己搞得单例模式 要实现一个单例模式，我们会很快就想到了在一个结构体中放置一个flag字段用于标记当前的函数是否被执行过，举个🌰：
type SingletonPattern struct { done bool } func (receiver *SingletonPattern) Do(f func()) { if !receiver.done { f() receiver.done=true } } 看似很美好，但是此时，如果传入的需要调用的函数f()会执行很长时间，比如数据库查询或者做一些连接什么的，当别的goroutine运行到此处的时候由于还没有执行完f()，就会发现done标记仍然是false，那么仍然会调用一次f()，此时就违背了单例模式的初衷。
那么如何解决上面的并发的问题呢。此时就可以使用go标准库中所提供的并发原语&amp;mdash;sync.Once
标准库真香系列之sync.Once 话不多说先上sync.Once 结构体的源代码：
type Once struct { // 标记符号，用于标记是否执行过 	done uint32 // 互斥锁，用于保护并发调用以及防止copy 	m Mutex } 结构体就这么简单，字段done用于标记是否执行过函数，至于为什么使用uint32类型，作者的理解是为了之后使用atomic操作做的妥协，m字段值用于保护并发情况下的情形，并且由于继承了Locker接口可以通过vet校验到其是否被复制
接下来看一下用于执行函数调用的Do()函数的实现：
func (o *Once) Do(f func()) { // 原子获取当前 done 字段是否等于0 	// 如果当前字段等于1 	// 则代表已经 执行过 	// 这是第一层校验 	if atomic.</description>
			<content type="html"><![CDATA[<h2 id="前言">前言</h2>
<blockquote>
<p>在我们开发过程中经常会使用到单例模式这一经典的设计模式，单例模式可以帮助开发者针对某个（些）变量或者对象或者函数（方法）进行在程序运行期间只有一次的初始化或者函数调用操作，比如在开发项目中针对某一类连接池的初始化（如数据库连接池等）。针对这种情况，我们就需要使用单例模式进行操作。</p>
</blockquote>
<h2 id="单例模式">单例模式🌰</h2>
<h4 id="自己搞得单例模式">自己搞得单例模式</h4>
<p>要实现一个单例模式，我们会很快就想到了在一个结构体中放置一个<code>flag</code>字段用于标记当前的函数是否被执行过，举个🌰：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">SingletonPattern</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">done</span> <span class="kt">bool</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">receiver</span> <span class="o">*</span><span class="nx">SingletonPattern</span><span class="p">)</span> <span class="nf">Do</span><span class="p">(</span><span class="nx">f</span> <span class="kd">func</span><span class="p">())</span>  <span class="p">{</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">receiver</span><span class="p">.</span><span class="nx">done</span> <span class="p">{</span>
		<span class="nf">f</span><span class="p">()</span>
		<span class="nx">receiver</span><span class="p">.</span><span class="nx">done</span><span class="p">=</span><span class="kc">true</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>看似很美好，但是此时，如果传入的需要调用的函数<code>f()</code>会执行很长时间，比如数据库查询或者做一些连接什么的，当别的goroutine运行到此处的时候由于还没有执行完<code>f()</code>，就会发现<code>done</code>标记仍然是<code>false</code>，那么仍然会调用一次<code>f()</code>，此时就违背了单例模式的初衷。</p>
<p>那么如何解决上面的并发的问题呢。此时就可以使用go标准库中所提供的并发原语&mdash;<em><strong><code>sync.Once</code></strong></em></p>
<h4 id="标准库真香系列之synconce">标准库真香系列之<code>sync.Once</code></h4>
<p>话不多说先上<code>sync.Once</code> 结构体的源代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Once</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// 标记符号，用于标记是否执行过
</span><span class="c1"></span>	<span class="nx">done</span> <span class="kt">uint32</span>
	<span class="c1">// 互斥锁，用于保护并发调用以及防止copy
</span><span class="c1"></span>	<span class="nx">m</span>    <span class="nx">Mutex</span>
<span class="p">}</span>
</code></pre></div><p>结构体就这么简单，字段<code>done</code>用于标记是否执行过函数，至于为什么使用<code>uint32</code>类型，作者的理解是为了之后使用<code>atomic</code>操作做的妥协，<code>m</code>字段值用于保护并发情况下的情形，并且由于继承了<code>Locker</code>接口可以通过<code>vet</code>校验到其是否被复制</p>
<p>接下来看一下用于执行函数调用的<code>Do()</code>函数的实现：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">Once</span><span class="p">)</span> <span class="nf">Do</span><span class="p">(</span><span class="nx">f</span> <span class="kd">func</span><span class="p">())</span> <span class="p">{</span>
	<span class="c1">// 原子获取当前 done 字段是否等于0
</span><span class="c1"></span>	<span class="c1">// 如果当前字段等于1 
</span><span class="c1"></span>	<span class="c1">// 则代表已经 执行过
</span><span class="c1"></span>	<span class="c1">// 这是第一层校验
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadUint32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">o</span><span class="p">.</span><span class="nx">done</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
	<span class="c1">// 如果为0则代表没被调用过则调用
</span><span class="c1"></span>	<span class="c1">// 此处写成一个函数的原因是为了
</span><span class="c1"></span>	<span class="c1">// 进行函数内联提升性能
</span><span class="c1"></span>		<span class="nx">o</span><span class="p">.</span><span class="nf">doSlow</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">Once</span><span class="p">)</span> <span class="nf">doSlow</span><span class="p">(</span><span class="nx">f</span> <span class="kd">func</span><span class="p">())</span> <span class="p">{</span>
	<span class="c1">// 此处加锁用于防止其他goroutine同时访问调用
</span><span class="c1"></span>	<span class="nx">o</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">o</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="c1">// 二次校验
</span><span class="c1"></span>	<span class="c1">// 为的是防止多个goroutine进入此函数的时候，可能发生的重复执行 f()
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">o</span><span class="p">.</span><span class="nx">done</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// 函数执行结束设置done 字段为 1代表已经执行完毕
</span><span class="c1"></span>		<span class="k">defer</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">StoreUint32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">o</span><span class="p">.</span><span class="nx">done</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
		<span class="c1">// 执行
</span><span class="c1"></span>		<span class="nf">f</span><span class="p">()</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>此时，<code>sync.Once</code> 的所有源代码已经解析完毕了（惊不惊喜，意不意外），其实<code>sync.Once</code> 的过程很简单，就是根据标记进行双重判断确定函数是否执行过，没执行就执行，执行了就跳过。</p>
<h2 id="synconce-的使用问题"><code>sync.Once</code> 的使用问题</h2>
<h4 id="哪来的deadlock">哪来的deadlock？</h4>
<p><code>sync.Once</code> 的确很简单，使用也很简单，但是还是会有使用上可能出现的一些问题比如下列代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">once</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Once</span>
	<span class="nx">once</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span>
		<span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;one once do&#34;</span><span class="p">)</span>
			<span class="nx">once</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span>
				<span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
					<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;second once do&#34;</span><span class="p">)</span>
				<span class="p">})</span>
		<span class="p">})</span>
<span class="p">}</span>
</code></pre></div><p>该代码会出现什么问题？答案是：</p>
<blockquote>
<p>fatal error: all goroutines are asleep - deadlock!</p>
</blockquote>
<p>为什么会这样？因为内层个<code>Do</code>是被外层的同一个<code>once</code>对象所调用，由于此时已经进入了第一个<code>Do</code>并且已经调用了函数，那么此时<code>sync.Once</code> 中的互斥锁字段，已经被加了锁，此时二次加锁就会产生死锁。因此使用<code>sync.Once</code> 最重要的一点就是：*</p>
<blockquote>
<p><strong>不要在执行函数中，嵌套当前的<code>sync.Once</code> 对象
不要在执行函数中，嵌套当前的<code>sync.Once</code> 对象
不要在执行函数中，嵌套当前的<code>sync.Once</code> 对象。
（重要的话要说三遍）</strong></p>
</blockquote>
<h4 id="哪来的invalid-memory-address-or-nil-pointer-dereference">哪来的invalid memory address or nil pointer dereference？</h4>
<p>看一下下面的代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">once</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Once</span>
	<span class="kd">var</span> <span class="nx">conn</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span>
	<span class="nx">once</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span>
		<span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
			<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">Dial</span><span class="p">(</span><span class="s">&#34;tcp&#34;</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="k">return</span>
			<span class="p">}</span>
		<span class="p">})</span>
	<span class="nx">conn</span><span class="p">.</span><span class="nf">RemoteAddr</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><p>在运行时，会出现：</p>
<blockquote>
<p>panic: runtime error: invalid memory address or nil pointer dereference</p>
</blockquote>
<p>为什么？因为<code>sync.Once</code><strong>只保证执行一次，但是不保证执行是否出错</strong>，即<strong>我只管调用，出错了跟我无关</strong>，上述代码中</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">Dial</span><span class="p">(</span><span class="s">&#34;tcp&#34;</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">)</span>
</code></pre></div><p>必定出现err!=nil的情况，此时如果不对<code>conn</code>变量进行判断为<code>nil</code>，就会出现空指针异常，那么，如何来保证他执行成功了呢，我们需要对其进行改造</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Once</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">once</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Once</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">receiver</span> <span class="o">*</span><span class="nx">Once</span><span class="p">)</span> <span class="nf">OnceDo</span><span class="p">(</span><span class="nx">f</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">error</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
	<span class="nx">receiver</span><span class="p">.</span><span class="nx">once</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span>
		<span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">err</span> <span class="p">=</span> <span class="nf">f</span><span class="p">()</span>
		<span class="p">})</span>
	<span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">once</span> <span class="nx">Once</span>
	<span class="kd">var</span> <span class="nx">conn</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span>
	<span class="nx">err</span> <span class="o">:=</span> <span class="nx">once</span><span class="p">.</span><span class="nf">OnceDo</span><span class="p">(</span>
		<span class="kd">func</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
			<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
			<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">Dial</span><span class="p">(</span><span class="s">&#34;tcp&#34;</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="k">return</span> <span class="nx">err</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="kc">nil</span>
		<span class="p">})</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>经过封装，我们就可以得到<code>sync.Once</code> 执行时是否出错，以适配各种错误处理。</p>
<p>此封装可能会有更好的解决方案，上面的方案也仅仅是一个🌰罢了。</p>
<h2 id="总结">总结</h2>
<p>至此<code>sync.Once</code> 的用法以及源码解析就完成了，可能有些地方有些理解上的错误，请各位谅解并且帮忙指出修改意见，如果这篇文章能帮到你，这是我的荣幸。</p>
]]></content>
		</item>
		
		<item>
			<title>「Golang」sync.Pool的源码解</title>
			<link>http://echoblog.cc/posts/golangsync.pool%E7%9A%84%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</link>
			<pubDate>Mon, 04 Jan 2021 00:00:00 +0000</pubDate>
			
			<guid>http://echoblog.cc/posts/golangsync.pool%E7%9A%84%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</guid>
			<description>前言 在平时我们的业务逻辑中，会出现多次，重复的申请在堆上创建的对象用作他用，当并发量不大的时候，可能往往并不会产生一些什么问题，当时一旦当并发量增长的时候就会发现因为重复在堆上创建对象导致了GC的扫描时间与STW（stop-the-world）很长，导致程序性能的降低，因为大量地创建在堆上的对象，也会影响垃圾回收标记的时间，因此来说频繁的在堆上申请对象说对高并发量的程序性能会产生很大的影响。
此时我们可以采用对象池的方式，去针对某些频繁的且大量重复申请的对象预先的创建或者将用完的对象放回对象池中，以便下回使用的时候免去了重新申请内存的问题，这样就有利于减少业务的耗时，还能提高程序的整体性能。 对象池是一种设计模式也是一种性能优化的方式，对象池（对象池模式）的概念如下：
 对象池（英语：object pool pattern）是一种设计模式。一个对象池包含一组已经初始化过且可以使用的对象，而可以在有需求时创建和销毁对象。池的用户可以从池子中取得对象，对其进行操作处理，并在不需要时归还给池子而非直接销毁它。这是一种特殊的工厂对象。 若初始化、实例化的代价高，且有需求需要经常实例化，但每次实例化的数量较少的情况下，使用对象池可以获得显著的效能提升。从池子中取得对象的时间是可预测的，但新建一个实例所需的时间是不确定。
 因此我们可以通过建立一个对象池的方式去优化频繁在堆上创建的对象，Go中官方标准库中就提供了一个线程安全的对象池&amp;mdash;sync.Pool
sync.Pool 首先针对sync.Pool官方给了一个合理的简述：
 // A Pool is a set of temporary objects that may be individually saved and retrieved. sync.Pool是一组临时对象，可以单独保存和检索。 // Any item stored in the Pool may be removed automatically at any time without notification. If the Pool holds the only reference when this happens, the item might be deallocated. 存储在sync.Pool中的任何项目可随时自动删除，无需通知。如果发生这种情况时sync.Pool持有唯一的引用，则该项目可能会被释放。 // A Pool is safe for use by multiple goroutines simultaneously.</description>
			<content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>在平时我们的业务逻辑中，会出现多次，重复的申请在堆上创建的对象用作他用，当并发量不大的时候，可能往往并不会产生一些什么问题，当时一旦当并发量增长的时候就会发现因为重复在堆上创建对象导致了GC的扫描时间与STW（stop-the-world）很长，导致程序性能的降低，因为大量地创建在堆上的对象，也会影响垃圾回收标记的时间，因此来说频繁的在堆上申请对象说对高并发量的程序性能会产生很大的影响。</p>
<p>此时我们可以采用对象池的方式，去针对某些频繁的且大量重复申请的对象预先的创建或者将用完的对象放回对象池中，以便下回使用的时候免去了重新申请内存的问题，这样就有利于减少业务的耗时，还能提高程序的整体性能。
对象池是一种设计模式也是一种性能优化的方式，对象池（<a href="https://zh.wikipedia.org/wiki/%E5%AF%B9%E8%B1%A1%E6%B1%A0%E6%A8%A1%E5%BC%8F">对象池模式</a>）的概念如下：</p>
<blockquote>
<p>对象池（英语：object pool pattern）是一种设计模式。一个对象池包含一组已经初始化过且可以使用的对象，而可以在有需求时创建和销毁对象。池的用户可以从池子中取得对象，对其进行操作处理，并在不需要时归还给池子而非直接销毁它。这是一种特殊的工厂对象。
若初始化、实例化的代价高，且有需求需要经常实例化，但每次实例化的数量较少的情况下，使用对象池可以获得显著的效能提升。从池子中取得对象的时间是可预测的，但新建一个实例所需的时间是不确定。</p>
</blockquote>
<p>因此我们可以通过建立一个对象池的方式去优化频繁在堆上创建的对象，Go中官方标准库中就提供了一个线程安全的对象池&mdash;<code>sync.Pool</code></p>
<h2 id="syncpool"><code>sync.Pool</code></h2>
<p>首先针对<code>sync.Pool</code>官方给了一个合理的简述：</p>
<blockquote>
<p>// A Pool is a set of <em><strong>temporary objects</strong></em> that may be individually saved and retrieved.
<code>sync.Pool</code>是一组<em>临时对象</em>，可以单独保存和检索。
// Any item stored in the Pool may be removed automatically at any time without notification. If the Pool holds the only reference when this happens, the item might be deallocated.
存储在<code>sync.Pool</code>中的任何项目可随时自动删除，无需通知。如果发生这种情况时<code>sync.Pool</code>持有唯一的引用，则该项目可能会被释放。
// A Pool is safe for use by multiple goroutines simultaneously.
// 一个<code>sync.Pool</code>可以安全地同时供多个Goroutine使用。</p>
</blockquote>
<p>总的来说大概就是以下几点：</p>
<ul>
<li><code>sync.Pool</code>这玩意儿存的是一堆 <em><strong>临时对象</strong></em></li>
<li>根据上一条的 <em><strong>临时对象</strong></em> 的含义就是<code>sync.Pool</code>里面存储的相关对象</li>
<li>这些 <em><strong>临时对象</strong></em>  随时可能被抛弃掉，这个抛弃不是指的后面说的GC清除，而是直接将这个 <em><strong>临时对象</strong></em>  抛弃不要将其设置为<code>nil</code></li>
<li>另外，<code>sync.Pool</code>里面的 <em><strong>临时对象</strong></em> 也可随时会被GC清除，但是GC清除的前提是这个 <em><strong>临时对象</strong></em> 没有被任何除<code>sync.Pool</code>之外的东西引用，才会被GC清除。</li>
<li>一个<code>sync.Pool</code>可以安全地同时供多个Goroutine使用。每个<code>sync.Pool</code>都是绑定其对应的GMP模型中的P的（默认读者已经知道了GMP是个啥）。</li>
</ul>
<p>接下来我来讲解一下<code>sync.Pool</code>的结构体内容和其所提供的三个接口<code>New、Get、Put</code>的相关代码实现。</p>
<h3 id="syncpool的结构体实现"><code>sync.Pool</code>的结构体实现：</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Pool</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// noCopy 结构体，从而能看出 sync.Pool与Mutex等一样是不能复制的
</span><span class="c1"></span>	<span class="nx">noCopy</span> <span class="nx">noCopy</span>
	<span class="c1">// local 字段 存储的是一个 存储  [P]poolLocal 类型的数组指针，其中P代表runtime.GOMAXPROCS()设置的值
</span><span class="c1"></span>	<span class="c1">// 这是一个本地的池，几乎所有临时对象的存取都在这个字段完成
</span><span class="c1"></span>	<span class="nx">local</span>     <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> 
	<span class="c1">// local存存储  [P]poolLocal的P大小 代表runtime.GOMAXPROCS()设置的值 
</span><span class="c1"></span>	<span class="nx">localSize</span> <span class="kt">uintptr</span>        

	<span class="c1">// 这两个字段与local两个字段的存储东西相同，但是区别是
</span><span class="c1"></span>	<span class="c1">// victim存储的是local抛弃下的数组，随时会被gc清除
</span><span class="c1"></span>	<span class="c1">// 但是也有可能被捡回去重新使用
</span><span class="c1"></span>	<span class="c1">// 可以把这个字段理解为一个随时抛弃随时捡起的垃圾堆
</span><span class="c1"></span>	<span class="nx">victim</span>     <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>  	
	<span class="nx">victimSize</span> <span class="kt">uintptr</span>         
	
	<span class="c1">// 这个是唯一开放的字段，用于在初始化的时候传入构建新临时对象的函数
</span><span class="c1"></span>	<span class="c1">// 如果这个字段为nil 在调用Get的且没有可用临时对象的时候就不会创建新对象而是返回nil
</span><span class="c1"></span>	<span class="nx">New</span> <span class="kd">func</span><span class="p">()</span> <span class="kd">interface</span><span class="p">{}</span>
<span class="p">}</span>

<span class="c1">// 这个结构体是一个存储着临时对像和全局对象链的结构体
</span><span class="c1"></span> <span class="kd">type</span> <span class="nx">poolLocalInternal</span> <span class="kd">struct</span> <span class="p">{</span>
	 <span class="c1">// 临时对象存储在这里 这个对象只会被一个P 使用因此无需加锁
</span><span class="c1"></span>	<span class="nx">private</span> <span class="kd">interface</span><span class="p">{}</span>  
	<span class="c1">// 这是一个无锁队列，有点类似GMP模型里面的全局任务队列（概念类似），当private 就回去里面取
</span><span class="c1"></span>	<span class="c1">//hared，可以由任意的 P 访问，但是只有本地的 P 才能 pushHead/popHead，其它 P 可以 popTail，
</span><span class="c1"></span>	<span class="nx">shared</span>  <span class="nx">poolChain</span>   
<span class="p">}</span>
<span class="c1">// 一个P对应一个该结构体
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">poolLocal</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">poolLocalInternal</span>

	<span class="c1">// 做了内存对齐
</span><span class="c1"></span>	<span class="nx">pad</span> <span class="p">[</span><span class="mi">128</span> <span class="o">-</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">poolLocalInternal</span><span class="p">{})</span><span class="o">%</span><span class="mi">128</span><span class="p">]</span><span class="kt">byte</span>
<span class="p">}</span>

</code></pre></div><p>结构体中，只有<code>New</code>这个字段是可以包外访问的，这个字段需要在初始化<code>sync.Pool</code>时候传入一个用于生成临时对象的函数，如果要不传入的话当<code>Get</code>在<code>private</code>与<code>shared</code>都没获取到临时对象时，会返回<code>nil</code>而不是新建。</p>
<h3 id="syncpoolpoolcleanup的实现"><code>sync.Pool.poolCleanup</code>的实现</h3>
<p>在前言中说到，<code>sync.Pool</code>会在不定时间的时候对已创建对象进行清除和Gc，这就需要用到<code>sync.Pool.poolCleanup</code>函数，其会在GC开始时STW阶段被调用，他将<code>sync.Pool</code>中<code>victim </code>中的对象移除，然后把 <code>local</code>的数据给<code>victim</code>，这样的话，<code>local </code>就会被清空，而 <code>victim</code>就像一垃圾堆，里面的东西可能会被当做垃圾丢弃了，但是里面有用的东西也可能被捡回来重新使用。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">poolCleanup</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// oldPools 是一个全局的[]*Pool变量
</span><span class="c1"></span>	<span class="c1">// 存的是
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">p</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">oldPools</span> <span class="p">{</span>
		<span class="nx">p</span><span class="p">.</span><span class="nx">victim</span> <span class="p">=</span> <span class="kc">nil</span>
		<span class="nx">p</span><span class="p">.</span><span class="nx">victimSize</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>

	<span class="c1">// 移动local 到 victim
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">p</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">allPools</span> <span class="p">{</span>
		<span class="nx">p</span><span class="p">.</span><span class="nx">victim</span> <span class="p">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">local</span>
		<span class="nx">p</span><span class="p">.</span><span class="nx">victimSize</span> <span class="p">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">localSize</span>
		<span class="nx">p</span><span class="p">.</span><span class="nx">local</span> <span class="p">=</span> <span class="kc">nil</span>
		<span class="nx">p</span><span class="p">.</span><span class="nx">localSize</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>

	<span class="c1">// 此时 所有的 Pool 里面的victim 都是no nil
</span><span class="c1"></span>	<span class="c1">// 而local 是nil
</span><span class="c1"></span>	<span class="nx">oldPools</span><span class="p">,</span> <span class="nx">allPools</span> <span class="p">=</span> <span class="nx">allPools</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><p>那么什么时候垃圾堆<code>victim</code>中的对象会重新使用呢？就是当<code>Get</code>时在<code>private</code>与<code>shared</code>都没获取到临时对象时会去垃圾堆<code>victim</code>找，如果找到了，该对象下次<code>Put</code>回的时候就不会放到垃圾堆<code>victim</code>里了。</p>
<h3 id="syncpoolget的实现"><code>sync.Pool.Get</code>的实现</h3>
<p>接下来看一下最重要的一个接口<code>Get</code>的实现，其可以返回一个可用的临时对象，如果有<code>New</code>这个字段如果初始化时未被传入，则当<code>Get</code>在<code>private</code>与<code>shared</code>都没获取到临时对象时，会返回<code>nil</code>而不是新建。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Pool</span><span class="p">)</span> <span class="nf">Get</span><span class="p">()</span> <span class="kd">interface</span><span class="p">{}</span> <span class="p">{</span>
	<span class="c1">// pin 函数是用于将当前goroutine固定在当前的P上 
</span><span class="c1"></span>	<span class="c1">// 为的是防止突然的上下文切换被其他的P执行了
</span><span class="c1"></span>	<span class="nx">l</span><span class="p">,</span> <span class="nx">pid</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nf">pin</span><span class="p">()</span>
	<span class="c1">// 获取当前本地的 临时对象
</span><span class="c1"></span>	<span class="nx">x</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">private</span>
	<span class="c1">// 临时对象 设为nil
</span><span class="c1"></span>	<span class="nx">l</span><span class="p">.</span><span class="nx">private</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="c1">// 如果本地没有
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">x</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// 就去自己的shared里面找，因为是自己的所以从Head处获取
</span><span class="c1"></span>		<span class="c1">// 如果是别人的就从Tail处获取
</span><span class="c1"></span>		<span class="nx">x</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">shared</span><span class="p">.</span><span class="nf">popHead</span><span class="p">()</span>
		<span class="c1">// 还是没有
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">x</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// 去其他的P的poolLocalInternal里去 “偷”
</span><span class="c1"></span>			<span class="nx">x</span> <span class="p">=</span> <span class="nx">p</span><span class="p">.</span><span class="nf">getSlow</span><span class="p">(</span><span class="nx">pid</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">// 和pin 是相反的
</span><span class="c1"></span>	<span class="nf">runtime_procUnpin</span><span class="p">()</span>
 	 <span class="c1">// 如果还是没找到，并且New被设置了就新建一个 否则返回nil
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">x</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">p</span><span class="p">.</span><span class="nx">New</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">x</span> <span class="p">=</span> <span class="nx">p</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">x</span>
<span class="p">}</span>

<span class="c1">// 去别的P的poolLocalInternal“偷”
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Pool</span><span class="p">)</span> <span class="nf">getSlow</span><span class="p">(</span><span class="nx">pid</span> <span class="kt">int</span><span class="p">)</span> <span class="kd">interface</span><span class="p">{}</span> <span class="p">{</span>
 	<span class="c1">// 获取有多少个p
</span><span class="c1"></span> 	<span class="nx">size</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadUintptr</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">p</span><span class="p">.</span><span class="nx">localSize</span><span class="p">)</span> 
 	 <span class="c1">// 获取最开始的指针
</span><span class="c1"></span>	<span class="nx">locals</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">local</span>                         
	<span class="c1">// 每个P的poolLocalInternal的share都看看 看看有没有可“偷”的临时对象，有就返回
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">int</span><span class="p">(</span><span class="nx">size</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">l</span> <span class="o">:=</span> <span class="nf">indexLocal</span><span class="p">(</span><span class="nx">locals</span><span class="p">,</span> <span class="p">(</span><span class="nx">pid</span><span class="o">+</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="nb">int</span><span class="p">(</span><span class="nx">size</span><span class="p">))</span>
			<span class="c1">// 因为是别人的shared所以就从Tail处获取
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">shared</span><span class="p">.</span><span class="nf">popTail</span><span class="p">();</span> <span class="nx">x</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">x</span>
		<span class="p">}</span>
	<span class="p">}</span>
	
	<span class="c1">// 没有就去victim 垃圾堆里面去找，找的方式和 “偷”一样
</span><span class="c1"></span>	 <span class="nx">size</span> <span class="p">=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadUintptr</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">p</span><span class="p">.</span><span class="nx">victimSize</span><span class="p">)</span>
	<span class="k">if</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">pid</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nx">size</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="nx">locals</span> <span class="p">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">victim</span>
	<span class="nx">l</span> <span class="o">:=</span> <span class="nf">indexLocal</span><span class="p">(</span><span class="nx">locals</span><span class="p">,</span> <span class="nx">pid</span><span class="p">)</span>
	<span class="c1">// 先从垃圾堆的 private 找 没有就去垃圾堆的shared去“偷”
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">x</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">private</span><span class="p">;</span> <span class="nx">x</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">l</span><span class="p">.</span><span class="nx">private</span> <span class="p">=</span> <span class="kc">nil</span>
		<span class="k">return</span> <span class="nx">x</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">int</span><span class="p">(</span><span class="nx">size</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">l</span> <span class="o">:=</span> <span class="nf">indexLocal</span><span class="p">(</span><span class="nx">locals</span><span class="p">,</span> <span class="p">(</span><span class="nx">pid</span><span class="o">+</span><span class="nx">i</span><span class="p">)</span><span class="o">%</span><span class="nb">int</span><span class="p">(</span><span class="nx">size</span><span class="p">))</span>
		<span class="k">if</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">shared</span><span class="p">.</span><span class="nf">popTail</span><span class="p">();</span> <span class="nx">x</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">x</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">// 如果垃圾堆中都没有，则把这个victim标记为空，以后的查找就可以忽略
</span><span class="c1"></span>	<span class="nx">atomic</span><span class="p">.</span><span class="nf">StoreUintptr</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">p</span><span class="p">.</span><span class="nx">victimSize</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><p>其实查找方式很简单，主要有以下几个步骤：</p>
<ol>
<li>先从当前P的<code>poolLocal</code>里面找看看<code>private</code>是否有临时对象可以返回，有的话返回，没有的话查一下自己的<code>shared</code>有没有。</li>
<li>如果没有就去其他P的<code>poolLocal</code>的<code>shared</code>里找看看有没有</li>
<li>如果没有就去垃圾堆<code>victim</code>里去找</li>
<li>如果垃圾堆也没有，就看看是否初始化了<code>New</code>，初始化了就重新创建一个，否则返回<code>nil</code>。</li>
</ol>
<h3 id="syncpoolput的实现"><code>sync.Pool.Put</code>的实现</h3>
<p>相对于### <code>sync.Pool.Get</code>， <code>sync.Pool.Put</code>的实现就简单多了：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"> <span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Pool</span><span class="p">)</span> <span class="nf">Put</span><span class="p">(</span><span class="nx">x</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
<span class="c1">// 如果返回的x是nil 直接忽略
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">x</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	 <span class="c1">// 同样将当前goroutine固定在当前的P上 
</span><span class="c1"></span>	<span class="nx">l</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nf">pin</span><span class="p">()</span>
	<span class="c1">// 如果当前P的private是nil 就放在上面
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">l</span><span class="p">.</span><span class="nx">private</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">l</span><span class="p">.</span><span class="nx">private</span> <span class="p">=</span> <span class="nx">x</span>
		<span class="nx">x</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="c1">// 如果不是那就放到当前P的shared队列头上
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">x</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">l</span><span class="p">.</span><span class="nx">shared</span><span class="p">.</span><span class="nf">pushHead</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
	<span class="p">}</span>
		<span class="c1">// 和pin 是相反的
</span><span class="c1"></span>	<span class="nf">runtime_procUnpin</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><p><code>sync.Pool.Put</code>的实现就简单多了大概步骤如下：</p>
<ol>
<li>如果传入对象是	<code>nil</code>那就不要他，要他也没用。</li>
<li>如果当前<code>private</code>是<code>nil</code>就直接把传入对象赋值给他</li>
<li>否则，就放入<code>shared</code>的头部，供日后使用</li>
</ol>
<h2 id="总结">总结</h2>
<p>至此 <code>sync.Pool</code>的源码解析就解析完了，可能有些地方有些理解上的错误，请各位谅解并且帮忙指出修改意见，如果这篇文章能帮到你，这是我的荣幸。</p>
]]></content>
		</item>
		
		<item>
			<title>「Golang」sync.RWMutex源码讲解</title>
			<link>http://echoblog.cc/posts/golangsync.rwmutex%E6%BA%90%E7%A0%81%E8%AE%B2%E8%A7%A3/</link>
			<pubDate>Mon, 04 Jan 2021 00:00:00 +0000</pubDate>
			
			<guid>http://echoblog.cc/posts/golangsync.rwmutex%E6%BA%90%E7%A0%81%E8%AE%B2%E8%A7%A3/</guid>
			<description>什么是sync.RWMutex 上次写过了sync.Mutex的源代码解析，这回写一下他的扩展版本，sync.RWMutex（下称读写锁）的源代码解析，首先看一下读写锁的作用，如下述：
 sync/rwmutex.go中 // A RWMutex is a reader/writer mutual exclusion lock. // The lock can be held by an arbitrary number of readers or a single writer.
 白话来讲，读写锁就是一个可以并发读但是不可以并发写的锁（此处有疑：不知应该称互斥锁还是称为锁），由于互斥锁的特性，会导致将所有goroutine（下称协程）串行化，从而影响整体程序运行的性能，如果写的数量大于读的数量时，性能损耗暂且可以忽略不计（建议不要忽略），但是当读的数量大于写的数量时，互斥锁对性能的影响是很大的，所以此刻我们需要采用读写锁来进行读操作和写操作的分开。
读写锁可以同时有多个协程进行对某个数据对某个数据进行读取，但是同一时间内只能有一个协程对其进行修改，这样就可以大大提高并发中读操作过多情况下互斥锁只能在同一时间内有一个协程访问这一痛点。
读写锁与互斥锁一样，禁止被复制，因为一旦对读写锁或互斥锁进行复制，连带复制的包括锁本身的状态，也就是说当对一个互斥锁或者读写锁复制时，当锁当前状态已经处于Lock状态时，被复制出来得到的锁也将会处于Lock状态，所以 锁禁止复制
字段解析 接下来看一下读写锁的源代码实现，首先看一下读写锁的结构体字段以及相关的常量字段的用处
 本文所有源代码版本基于1.15
 type RWMutex struct { w Mutex // 一个互斥锁的字段，用户进行写时加互斥锁 	writerSem uint32 // 一个writer的信号量，类似互斥锁中的信号量 	readerSem uint32 // 一个reader的信号量，类似互斥锁中的信号量 	readerCount int32 // 两种作用，1:标记有多少拿到读锁的reader，2:是否有writer需要竞争 	readerWait int32 // writer需要等待读锁解锁的reader的数量 } const rwmutexMaxReaders = 1 &amp;lt;&amp;lt; 30 // 最大reader的上限。即最多有多少的reader同时能拿到读锁  在标准库中有很多的字段或者变量都是使用位移操作进行一个字段作为多个含义去使用，比如我的【Golang】【标准库】sync.</description>
			<content type="html"><![CDATA[<h2 id="什么是syncrwmutex">什么是sync.RWMutex</h2>
<p>上次写过了sync.Mutex的源代码解析，这回写一下他的扩展版本，sync.RWMutex（下称读写锁）的源代码解析，首先看一下读写锁的作用，如下述：</p>
<blockquote>
<p>sync/rwmutex.go中
// A RWMutex is a reader/writer mutual exclusion lock.
// The lock can be held by an arbitrary number of readers or a single writer.</p>
</blockquote>
<p>白话来讲，读写锁就是一个可以并发读但是不可以并发写的锁（此处有疑：不知应该称互斥锁还是称为锁），由于互斥锁的特性，会导致将所有goroutine（下称协程）串行化，从而影响整体程序运行的性能，如果写的数量大于读的数量时，性能损耗暂且可以忽略不计（建议不要忽略），但是当读的数量大于写的数量时，互斥锁对性能的影响是很大的，所以此刻我们需要采用读写锁来进行读操作和写操作的分开。</p>
<p>读写锁可以同时有多个协程进行对某个数据对某个数据进行读取，但是同一时间内只能有一个协程对其进行修改，这样就可以大大提高并发中读操作过多情况下互斥锁只能在同一时间内有一个协程访问这一痛点。</p>
<p>读写锁与互斥锁一样，<em><strong>禁止被复制</strong></em>，因为一旦对读写锁或互斥锁进行复制，连带复制的包括锁本身的状态，也就是说当对一个互斥锁或者读写锁复制时，当锁当前状态已经处于Lock状态时，被复制出来得到的锁也将会处于Lock状态，所以 <em><strong>锁禁止复制</strong></em></p>
<h2 id="字段解析">字段解析</h2>
<p>接下来看一下读写锁的源代码实现，首先看一下读写锁的结构体字段以及相关的常量字段的用处</p>
<blockquote>
<p>本文所有源代码版本基于1.15</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">RWMutex</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">w</span>           <span class="nx">Mutex</span>  <span class="c1">// 一个互斥锁的字段，用户进行写时加互斥锁
</span><span class="c1"></span>	<span class="nx">writerSem</span>   <span class="kt">uint32</span> <span class="c1">// 一个writer的信号量，类似互斥锁中的信号量
</span><span class="c1"></span>	<span class="nx">readerSem</span>   <span class="kt">uint32</span> <span class="c1">// 一个reader的信号量，类似互斥锁中的信号量
</span><span class="c1"></span>	<span class="nx">readerCount</span> <span class="kt">int32</span>  <span class="c1">// 两种作用，1:标记有多少拿到读锁的reader，2:是否有writer需要竞争
</span><span class="c1"></span>	<span class="nx">readerWait</span>  <span class="kt">int32</span>  <span class="c1">// writer需要等待读锁解锁的reader的数量
</span><span class="c1"></span><span class="p">}</span>
<span class="kd">const</span> <span class="nx">rwmutexMaxReaders</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">30</span> <span class="c1">// 最大reader的上限。即最多有多少的reader同时能拿到读锁
</span></code></pre></div><blockquote>
<p>在标准库中有很多的字段或者变量都是使用位移操作进行一个字段作为多个含义去使用，比如我的<a href="https://blog.csdn.net/qq_37005831/article/details/110311956">【Golang】【标准库】sync.Mutex源码解析</a>这篇文章中互斥锁的<strong>state</strong>字段就一个字段进行位移操作后代表4个含义的代表，位移操作的性能本身就很快，这样的写法也提高了整体锁的性能，作者认为，未来的开发过程可以充分使用这种方法进行开发。</p>
</blockquote>
<p>由于是读写锁，那么加锁解锁过程就不能像互斥锁一样只是单一的Lock和Unlock，读写锁的提供的操作有五个分别是：</p>
<ul>
<li>Lock/Unlock：用于writer需要进行写操作时时调用的方法，如果调用时读锁已经被reader所持有，那么将会等待从未调用该方法到调用此方法时所有持有读锁的reader解锁后才会进行writer写锁获取，Unlock是其配对的解锁操作。并且通知从获取到写锁时之后新来的等待读锁的reader获取读锁。</li>
<li>RLock/RUnlock：用于reader进行读操作时调用的方法，当此时没有写锁被获取时，直接获取到读锁，当有写锁被获取时，等待写锁的释放后才会被唤醒并获取读锁，RUlock 是其相反的方法，并且当没有需要等待的读锁时，会通知等待获取写锁的writer进行写锁的获取。</li>
<li>RLocker：这个方法的作用是返回一个读锁的Locker对象，调用Lock和Unlock的时候会调用RLock和RUlock，个人认为这个方法可以构造一个只读锁。</li>
</ul>
<h2 id="rlock">RLock()</h2>
<p>了解了读写锁提供的几个方法，接下来就开始分析源代码，首先分析的时读操作时的RLock方法
本次的源代码解析，我删除了所有<code>if race.Enabled { //todo }</code> 语句，因为其是判断是进行判断当前程序是否开启了race竞态检测模式的代码，即在运行go程序时是否采用<code>go run race xxx.go</code>这种进行进行竞态检测运行模式，所以进行省略</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">rw</span> <span class="o">*</span><span class="nx">RWMutex</span><span class="p">)</span> <span class="nf">RLock</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// 首先对读计数器进行+1 并且判断+1后的值是否小于0 如果小于0则代表当前有已经被获取的写锁
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">AddInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">rw</span><span class="p">.</span><span class="nx">readerCount</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// 此时需要进行阻塞挂起，等待写锁的解锁
</span><span class="c1"></span>		<span class="nf">runtime_SemacquireMutex</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">rw</span><span class="p">.</span><span class="nx">readerSem</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>读锁加锁操作没什么好说的，主要就是针对<code>readerCount</code>字段的判断，如果其+1仍未负数时就代表此时此刻写锁已经被获取，即需要进行阻塞等待写锁的解锁。</p>
<h2 id="runlock">RUnlock()</h2>
<p>接下来看读锁的RUnlock操作：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">rw</span> <span class="o">*</span><span class="nx">RWMutex</span><span class="p">)</span> <span class="nf">RUnlock</span><span class="p">()</span> <span class="p">{</span>
		<span class="c1">// 将已经加锁的读锁数量-1，如果此时-1后小于0时，则代表
</span><span class="c1"></span>		<span class="c1">// 1:有可能反复解锁，此时需要抛出panic
</span><span class="c1"></span>		<span class="c1">// 2:有writer正在等待获取写锁
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">r</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">AddInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">rw</span><span class="p">.</span><span class="nx">readerCount</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span> <span class="nx">r</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">rw</span><span class="p">.</span><span class="nf">rUnlockSlow</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rw</span> <span class="o">*</span><span class="nx">RWMutex</span><span class="p">)</span> <span class="nf">rUnlockSlow</span><span class="p">(</span><span class="nx">r</span> <span class="kt">int32</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 不可重复解锁，此时抛出panic
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">r</span><span class="o">+</span><span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">r</span><span class="o">+</span><span class="mi">1</span> <span class="o">==</span> <span class="o">-</span><span class="nx">rwmutexMaxReaders</span> <span class="p">{</span>
		<span class="nx">race</span><span class="p">.</span><span class="nf">Enable</span><span class="p">()</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;sync: RUnlock of unlocked RWMutex&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 此时有一个writer正在等待获取写锁，
</span><span class="c1"></span>	<span class="c1">// 如果当前解锁的reader是最后一个需要等待的读锁
</span><span class="c1"></span>	<span class="c1">// 则唤醒等待读锁释放完的writer进行写锁的获取
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">AddInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">rw</span><span class="p">.</span><span class="nx">readerWait</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">runtime_Semrelease</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">rw</span><span class="p">.</span><span class="nx">writerSem</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>读锁的解锁其实也是很简单的实现，就是去判断是否有正在等待的写锁，如果没有就直接返回，否则就进行<code>readerWait</code>字段的校验判断其是否是最后一个需要等待的读锁后唤醒等待读锁释放完的writer进行写锁的获取。</p>
<p>读的加锁于解锁操作都已经说完，接下来说一下写锁的加锁和解锁过程。</p>
<h2 id="lock">Lock()</h2>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">rw</span> <span class="o">*</span><span class="nx">RWMutex</span><span class="p">)</span> <span class="nf">Lock</span><span class="p">()</span> <span class="p">{</span> 
	<span class="c1">// 先将Mutex字段进行加锁，以免有其他写锁操作或者其他操作破坏数据
</span><span class="c1"></span>	<span class="nx">rw</span><span class="p">.</span><span class="nx">w</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="c1">// 将readerCount进行取反操作 这也是此字段除了标记reader数量的第二个功能，进行写锁标记
</span><span class="c1"></span>	<span class="c1">// 即标记有writer需要竞争
</span><span class="c1"></span>	<span class="nx">r</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">AddInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">rw</span><span class="p">.</span><span class="nx">readerCount</span><span class="p">,</span> <span class="o">-</span><span class="nx">rwmutexMaxReaders</span><span class="p">)</span> <span class="o">+</span> <span class="nx">rwmutexMaxReaders</span>
	<span class="c1">// 此时将取反的r值交给readerWait代表仍需要等待释放锁的reader的数量
</span><span class="c1"></span>	<span class="c1">// 如果该数量为0 那么代表不需要等待则直接获取写锁即可
</span><span class="c1"></span>	<span class="c1">// 否则就将writer挂起阻塞直至RUlock唤醒
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">r</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">AddInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">rw</span><span class="p">.</span><span class="nx">readerWait</span><span class="p">,</span> <span class="nx">r</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">runtime_SemacquireMutex</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">rw</span><span class="p">.</span><span class="nx">writerSem</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="p">}</span>
 <span class="p">}</span>
</code></pre></div><p>写锁的加锁过程必须先对整体的结构体的Mutex进行加锁，以免有其他的写操作同时对写锁的竞争导致data race。然后进行当前持有读锁的reader的数量进行取反，并且将其值交给<code>readerWait</code>用于标记需要等待释放锁的reader的数量，如果该字段不等于0则代表需要进行读锁解锁等待。当reader调用RUlock时会进行对此字段的-1并且判断，如果此字段为0时，则唤醒writer的阻塞，使得writer获取到写锁。</p>
<h2 id="unlock">Unlock()</h2>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">rw</span> <span class="o">*</span><span class="nx">RWMutex</span><span class="p">)</span> <span class="nf">Unlock</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// 写锁进行解锁时首先将加锁时取反的readerCount再次取反
</span><span class="c1"></span>	<span class="c1">// 也就是解除当前有写锁正在竞争的标记
</span><span class="c1"></span>	<span class="nx">r</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">AddInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">rw</span><span class="p">.</span><span class="nx">readerCount</span><span class="p">,</span> <span class="nx">rwmutexMaxReaders</span><span class="p">)</span>
	<span class="c1">// 如果取反后这个值大于rwmutexMaxReaders 就代表重复解锁
</span><span class="c1"></span>	<span class="c1">// 抛出panic
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">r</span> <span class="o">&gt;=</span> <span class="nx">rwmutexMaxReaders</span> <span class="p">{</span>
		<span class="nx">race</span><span class="p">.</span><span class="nf">Enable</span><span class="p">()</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;sync: Unlock of unlocked RWMutex&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 解锁完毕后需要根据等待的readerCount的数量去依次唤醒这些reader 
</span><span class="c1"></span>	<span class="c1">// 这些reader是在Lock后再次请求获取读锁的reader的数量
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">int</span><span class="p">(</span><span class="nx">r</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nf">runtime_Semrelease</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">rw</span><span class="p">.</span><span class="nx">readerSem</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 把写锁的互斥锁解锁，以便于其他writer进行写操作的竞争
</span><span class="c1"></span>	<span class="nx">rw</span><span class="p">.</span><span class="nx">w</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><p>写锁的解锁方式很简单，先进行<code>readerCount</code>的取反，以便告知无writer正在竞争，然后依次去唤醒这些等待的reader去获取读锁，然后将互斥锁写锁，以便后续的writer进行写操作，在写操作时，加锁时先进行互斥锁的加锁，解锁时后进行互斥锁的解锁，为的是保证字段的修改也受到互斥锁的保护。</p>
<p>go的读写锁采用的是Write-preferring（即写优先）的设计，这样可以保证写操作在大量的读操作进行时不会被饿死。但是相对于Read-preferring（即读优先）的设计会降低读的并发性，但是这种方式避免了写会出现饥饿问题。也是一种良好的解决办法。</p>
<h2 id="总结">总结</h2>
<p>至此sync.RWMutex的源码解析就解析完了，可能有些地方有些理解上的错误，请各位谅解并且帮忙指出修改意见，如果这篇文章能帮到你，这是我的荣幸。</p>
]]></content>
		</item>
		
		<item>
			<title>「Golang」sync.WaitGroup源码讲解.md</title>
			<link>http://echoblog.cc/posts/golangsync.waitgroup%E6%BA%90%E7%A0%81%E8%AE%B2%E8%A7%A3/</link>
			<pubDate>Mon, 04 Jan 2021 00:00:00 +0000</pubDate>
			
			<guid>http://echoblog.cc/posts/golangsync.waitgroup%E6%BA%90%E7%A0%81%E8%AE%B2%E8%A7%A3/</guid>
			<description>sync.WaitGroup介绍 当我们在开发过程中，经常需要在开启多个goroutine后，等待全部的goroutine执行完毕后才进行下一步的业务逻辑执行。此时我们可能会采用轮询的方式去定时侦测已经开启的多个goroutine的业务是否执行完毕，但是这样性能很低，并且持续占用cpu时间片很消耗cpu的资源，此时我们就该使用sync.WaitGroup来完成此次操作。举个🌰，下列代码是开了10个goroutine后等待其各睡眠5秒之后进行后续操作的sync.WaitGroup方法实现。
func main() { // 创建对象 	var wait sync.WaitGroup for i := 0; i &amp;lt; 10; i++ { // 为需要等待结束的goroutine数量+1 	wait.Add(1) go func() { time.Sleep(5*time.Second) // 结束 使得需要等待的数量-1 	// 等同于 wait.Add(-1) 	wait.Done() }() } // 等待所有执行完毕 	wait.Wait() fmt.Println(&amp;#34;wait done&amp;#34;) } 上述代码的睡眠5秒可以替换为任何需要在goroutine中执行的业务逻辑，上述代码中出现了下述几个sync.WaitGroup中提供的方法，提供方法很少很简洁，接下来就开始解析一下sync.WaitGroup的相关信息。
func (wg *WaitGroup) Add(delta int) func (wg *WaitGroup) Done() func (wg *WaitGroup) Wait() sync.WaitGroup源代码解析 1：sync.WaitGroup结构体的解析 type WaitGroup struct { // 一个防止sync.WaitGroup被复制的标记结构体 	noCopy noCopy // 该数组在32为系统与64位系统中代表的用途不同 	// 首先说64位系统： 	// state1[0]代表当前sync.</description>
			<content type="html"><![CDATA[<h2 id="syncwaitgroup介绍"><code>sync.WaitGroup</code>介绍</h2>
<p>当我们在开发过程中，经常需要在开启多个goroutine后，等待全部的goroutine执行完毕后才进行下一步的业务逻辑执行。此时我们可能会采用轮询的方式去定时侦测已经开启的多个goroutine的业务是否执行完毕，但是这样性能很低，并且持续占用cpu时间片很消耗cpu的资源，此时我们就该使用<code>sync.WaitGroup</code>来完成此次操作。举个🌰，下列代码是开了10个goroutine后等待其各睡眠5秒之后进行后续操作的<code>sync.WaitGroup</code>方法实现。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// 创建对象
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">wait</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="c1">// 为需要等待结束的goroutine数量+1
</span><span class="c1"></span>		<span class="nx">wait</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">5</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
			<span class="c1">// 结束 使得需要等待的数量-1
</span><span class="c1"></span>			<span class="c1">// 等同于  wait.Add(-1)
</span><span class="c1"></span>			<span class="nx">wait</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
		<span class="p">}()</span>
	<span class="p">}</span>
	<span class="c1">// 等待所有执行完毕
</span><span class="c1"></span>	<span class="nx">wait</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;wait done&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>上述代码的睡眠5秒可以替换为任何需要在goroutine中执行的业务逻辑，上述代码中出现了下述几个<code>sync.WaitGroup</code>中提供的方法，提供方法很少很简洁，接下来就开始解析一下<code>sync.WaitGroup</code>的相关信息。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">wg</span> <span class="o">*</span><span class="nx">WaitGroup</span><span class="p">)</span> <span class="nf">Add</span><span class="p">(</span><span class="nx">delta</span> <span class="kt">int</span><span class="p">)</span> 
<span class="kd">func</span> <span class="p">(</span><span class="nx">wg</span> <span class="o">*</span><span class="nx">WaitGroup</span><span class="p">)</span> <span class="nf">Done</span><span class="p">()</span> 
<span class="kd">func</span> <span class="p">(</span><span class="nx">wg</span> <span class="o">*</span><span class="nx">WaitGroup</span><span class="p">)</span> <span class="nf">Wait</span><span class="p">()</span>
</code></pre></div><h2 id="syncwaitgroup源代码解析"><code>sync.WaitGroup</code>源代码解析</h2>
<h3 id="1syncwaitgroup结构体的解析">1：<code>sync.WaitGroup</code>结构体的解析</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">WaitGroup</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// 一个防止sync.WaitGroup被复制的标记结构体
</span><span class="c1"></span>	<span class="nx">noCopy</span> <span class="nx">noCopy</span>
	<span class="c1">// 该数组在32为系统与64位系统中代表的用途不同
</span><span class="c1"></span>	<span class="c1">// 首先说64位系统：
</span><span class="c1"></span>	<span class="c1">// state1[0]代表当前sync.WaitGroup 调用Add方法增加了多少的couter
</span><span class="c1"></span>	<span class="c1">// state1[1]代表调用了Wait方法等待结束的Waiter的数量
</span><span class="c1"></span>	<span class="c1">// state1[2]代表Waiter的信号量
</span><span class="c1"></span>	<span class="c1">// 其中 state1[0]与state1[1]作者称为计数标记
</span><span class="c1"></span>	<span class="c1">// 在32位系统中：
</span><span class="c1"></span>	<span class="c1">// state1[0]代表Waiter的信号量
</span><span class="c1"></span>	<span class="c1">// state1[1]代表当前sync.WaitGroup 调用Add方法增加了多少的couter
</span><span class="c1"></span>	<span class="c1">// state1[2]代表调用了Wait方法等待结束的Waiter的数量
</span><span class="c1"></span>	<span class="c1">// 其中 state1[1]与state1[2]作者称为计数标记
</span><span class="c1"></span>	<span class="nx">state1</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">uint32</span>
<span class="p">}</span>
</code></pre></div><h3 id="adddelta-int-方法源代码解析"><code>Add(delta int) </code>方法源代码解析</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// state 方法用于根据系统是32位还是64位返回对应的state1字段的对应的计数和信号量的地址
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">wg</span> <span class="o">*</span><span class="nx">WaitGroup</span><span class="p">)</span> <span class="nf">state</span><span class="p">()</span> <span class="p">(</span><span class="nx">statep</span> <span class="o">*</span><span class="kt">uint64</span><span class="p">,</span> <span class="nx">semap</span> <span class="o">*</span><span class="kt">uint32</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">wg</span><span class="p">.</span><span class="nx">state1</span><span class="p">))</span><span class="o">%</span><span class="mi">8</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// 64位系统返回state1与state1[2]，由于数组是连续内存所以可以通过首地址
</span><span class="c1"></span>		<span class="c1">// 取出state1[0]与state1[1]的所有二进制位
</span><span class="c1"></span>		<span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="kt">uint64</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">wg</span><span class="p">.</span><span class="nx">state1</span><span class="p">)),</span> <span class="o">&amp;</span><span class="nx">wg</span><span class="p">.</span><span class="nx">state1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="c1">// 32位系统返回state1与state1[2]，由于数组是连续内存所以可以通过首地址
</span><span class="c1"></span>		<span class="c1">// 取出state1[0]与state1[1]的所有二进制位
</span><span class="c1"></span>		<span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="kt">uint64</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">wg</span><span class="p">.</span><span class="nx">state1</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span> <span class="o">&amp;</span><span class="nx">wg</span><span class="p">.</span><span class="nx">state1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="c1">// Add 方法传入一个增量 可以为赋值则代表 Done
</span><span class="c1">// 例如 调用Done方法就是对Add方法传入了-1 
</span><span class="c1">// 即Add(-1)
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">wg</span> <span class="o">*</span><span class="nx">WaitGroup</span><span class="p">)</span> <span class="nf">Add</span><span class="p">(</span><span class="nx">delta</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 根据系统位数返回计数标记和信号量标记
</span><span class="c1"></span>	<span class="nx">statep</span><span class="p">,</span> <span class="nx">semap</span> <span class="o">:=</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">state</span><span class="p">()</span>
	<span class="c1">// 做了race检查和异常的检查
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">race</span><span class="p">.</span><span class="nx">Enabled</span> <span class="p">{</span>
		<span class="nx">_</span> <span class="p">=</span> <span class="o">*</span><span class="nx">statep</span> <span class="c1">// 如果信号量是个空指针，则报错
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">delta</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">race</span><span class="p">.</span><span class="nf">ReleaseMerge</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">wg</span><span class="p">))</span>
		<span class="p">}</span>
		<span class="nx">race</span><span class="p">.</span><span class="nf">Disable</span><span class="p">()</span>
		<span class="k">defer</span> <span class="nx">race</span><span class="p">.</span><span class="nf">Enable</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="c1">// 将计数标记的高32位的值+delta
</span><span class="c1"></span>	<span class="c1">// 如果是64位系统则代表state1[0]+delta
</span><span class="c1"></span>	<span class="nx">state</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">AddUint64</span><span class="p">(</span><span class="nx">statep</span><span class="p">,</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">delta</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">32</span><span class="p">)</span>
	<span class="c1">// 转换成正常的数字
</span><span class="c1"></span>	<span class="c1">// 例如 以64为系统为例 当原state1[0]为0时
</span><span class="c1"></span>	<span class="c1">// atomic.AddUint64(statep, uint64(delta)&lt;&lt;32)
</span><span class="c1"></span>	<span class="c1">// 当delta==1时
</span><span class="c1"></span>	<span class="c1">// 结果为 2^32-1
</span><span class="c1"></span>	<span class="c1">// 该操作就是将此数值转变为1
</span><span class="c1"></span>	<span class="nx">v</span> <span class="o">:=</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">state</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">)</span>
	<span class="c1">// w代表需要等待的数量即 64位系统中的state1[1]为state
</span><span class="c1"></span>	<span class="nx">w</span> <span class="o">:=</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">state</span><span class="p">)</span>
	<span class="c1">// 做race判断，并判断delta是否为负数 如果是的话并且v与delta相等则做一些race的同步
</span><span class="c1"></span>	<span class="c1">// fixme 此处解释存疑
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">race</span><span class="p">.</span><span class="nx">Enabled</span> <span class="o">&amp;&amp;</span> <span class="nx">delta</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">v</span> <span class="o">==</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">delta</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// The first increment must be synchronized with Wait.
</span><span class="c1"></span>		<span class="c1">// Need to model this as a read, because there can be
</span><span class="c1"></span>		<span class="c1">// several concurrent wg.counter transitions from 0.
</span><span class="c1"></span>		<span class="nx">race</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">semap</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="c1">// 如果v&lt;0则代表delta的传入的为负值，并且该负值与原couter相减后小于0
</span><span class="c1"></span>	<span class="c1">// 说白了一点就说Add传入的负值超出了原有couter的数量
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">v</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;sync: negative WaitGroup counter&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 如果等待数量不是0 并且delta&gt;0 且v==delta 则代表出现了
</span><span class="c1"></span>	<span class="c1">// 同时并发调用了Add和Wait
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">w</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">delta</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">v</span> <span class="o">==</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">delta</span><span class="p">)</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;sync: WaitGroup misuse: Add called concurrently with Wait&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 正常情况 直接返回
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">v</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">w</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	
	<span class="c1">// 也是同时调用Add和Wait
</span><span class="c1"></span>	<span class="k">if</span> <span class="o">*</span><span class="nx">statep</span> <span class="o">!=</span> <span class="nx">state</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;sync: WaitGroup misuse: Add called concurrently with Wait&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 如果计数值v为0并且waiter的数量w不为0
</span><span class="c1"></span>	<span class="c1">// 则代表delta传入的值使得couter变为了0，但是还是有waiter在等待的话
</span><span class="c1"></span>	<span class="c1">// 就把statep即state1[0]与state1[1]设置为0
</span><span class="c1"></span>	<span class="c1">// 并唤醒所有的正在等待的阻塞goroutine
</span><span class="c1"></span>	<span class="o">*</span><span class="nx">statep</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="p">;</span> <span class="nx">w</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">w</span><span class="o">--</span> <span class="p">{</span>
		<span class="nf">runtime_Semrelease</span><span class="p">(</span><span class="nx">semap</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p><code>Add(delta int) </code>方法的总体执行过程大概如下：</p>
<ol>
<li>根据64位还是32位系统获取对应的标记位</li>
<li>对计数标记位做delta的Add</li>
<li>判断Add之后的state是否为一些非法情况，比如v&lt;0等</li>
<li>如果v和w分别为大于0和等于0则正常返回，代表Add成功</li>
<li>否则判断当v为0时则代表没有counter了，但是还有waiter那么就把state整体设置为0，随后唤醒调用了 <code>Wait()</code>的阻塞的goroutine。</li>
</ol>
<h3 id="done-方法解析"><code>Done()</code> 方法解析</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Done 没什么可说的 就是调用了一下Add(-1)
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">wg</span> <span class="o">*</span><span class="nx">WaitGroup</span><span class="p">)</span> <span class="nf">Done</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h3 id="wait-方法解析"><code>Wait()</code> 方法解析</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">wg</span> <span class="o">*</span><span class="nx">WaitGroup</span><span class="p">)</span> <span class="nf">Wait</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// 根据系统位数返回计数标记和信号量标记
</span><span class="c1"></span>	<span class="nx">statep</span><span class="p">,</span> <span class="nx">semap</span> <span class="o">:=</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">state</span><span class="p">()</span>
	<span class="c1">// race检测
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">race</span><span class="p">.</span><span class="nx">Enabled</span> <span class="p">{</span>
		<span class="nx">_</span> <span class="p">=</span> <span class="o">*</span><span class="nx">statep</span> <span class="c1">// trigger nil deref early
</span><span class="c1"></span>		<span class="nx">race</span><span class="p">.</span><span class="nf">Disable</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="c1">// 循环校验是否所有的goroutine都调用了Done
</span><span class="c1"></span>	<span class="k">for</span> <span class="p">{</span>
		<span class="c1">//原子获取值
</span><span class="c1"></span>		<span class="nx">state</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadUint64</span><span class="p">(</span><span class="nx">statep</span><span class="p">)</span>
		<span class="c1">// v 代表 couter数量 ，即高32位
</span><span class="c1"></span>		<span class="nx">v</span> <span class="o">:=</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">state</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">)</span>
		<span class="c1">// w 代表waiter数量 ，即低32位
</span><span class="c1"></span>		<span class="nx">w</span> <span class="o">:=</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">state</span><span class="p">)</span>
		<span class="c1">// 如果v==0 代表没有 couter了则不用等待了直接返回
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">v</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="c1">// Counter is 0, no need to wait.
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">race</span><span class="p">.</span><span class="nx">Enabled</span> <span class="p">{</span>
				<span class="nx">race</span><span class="p">.</span><span class="nf">Enable</span><span class="p">()</span>
				<span class="nx">race</span><span class="p">.</span><span class="nf">Acquire</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">wg</span><span class="p">))</span>
			<span class="p">}</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="c1">// 如果statep的值与state相等 还有需要等待完成的goroutine 此时则waiter+1
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">CompareAndSwapUint64</span><span class="p">(</span><span class="nx">statep</span><span class="p">,</span> <span class="nx">state</span><span class="p">,</span> <span class="nx">state</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// race检测
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">race</span><span class="p">.</span><span class="nx">Enabled</span> <span class="o">&amp;&amp;</span> <span class="nx">w</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">race</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">semap</span><span class="p">))</span>
			<span class="p">}</span>
			<span class="c1">// 阻塞等待直到被Add唤醒
</span><span class="c1"></span>			<span class="nf">runtime_Semacquire</span><span class="p">(</span><span class="nx">semap</span><span class="p">)</span>
			<span class="c1">// 如果被唤醒了 但是发现地址中的值不是0 代表唤醒错误 panic
</span><span class="c1"></span>			<span class="k">if</span> <span class="o">*</span><span class="nx">statep</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;sync: WaitGroup is reused before previous Wait has returned&#34;</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="c1">// race检测
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">race</span><span class="p">.</span><span class="nx">Enabled</span> <span class="p">{</span>
				<span class="nx">race</span><span class="p">.</span><span class="nf">Enable</span><span class="p">()</span>
				<span class="nx">race</span><span class="p">.</span><span class="nf">Acquire</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">wg</span><span class="p">))</span>
			<span class="p">}</span>
			<span class="k">return</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></div><p><code>Wait() </code>方法的总体执行过程大概如下：</p>
<ol>
<li>获取标记位的地址</li>
<li>获取值</li>
<li>判断v是否为0，如果是则无须等待。</li>
<li>如果v不是0并且statep的值与state相等，则代表还有需要等待完成的goroutine，此时则waiter+1，然后阻塞等待Add方法唤醒</li>
</ol>
<h2 id="总结">总结</h2>
<h3 id="syncwaitgroup-使用的规范"><code>sync.WaitGroup</code> 使用的规范</h3>
<ol>
<li><code>Add(delta int)</code> 方法可以设置为负值，但是必须要确保这个负值delta加上当前计数器的数量的结果大于0。否则会panic。🌰如下</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">wait</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
	<span class="nx">wait</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// 没问题 计数器为1
</span><span class="c1"></span>	<span class="nx">wait</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="c1">// 没问题 计数器为0
</span><span class="c1"></span>	
	<span class="nx">wait</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span> <span class="c1">// panic 此时计数器为0-3 出错
</span><span class="c1"></span><span class="p">}</span>


<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">wait</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
	<span class="nx">wait</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// 没问题 计数器为1
</span><span class="c1"></span>	<span class="nx">wait</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="c1">// 没问题 计数器为2
</span><span class="c1"></span>	
	<span class="nx">wait</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span> <span class="c1">// 没问题 计数器为1
</span><span class="c1"></span>	<span class="nx">wait</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span><span class="c1">// 没问题 计数器为0
</span><span class="c1"></span>	
	<span class="nx">wait</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span><span class="c1">// panic 此时计数器为-1
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>2.<code>Add(delta int)</code>方法必须在 <code>Wait()</code> 方法调用之前全部调用完毕，否则会出现panic。举个🌰，本实例的设想是进入goroutine后<code>Add(delta int)</code>但是<code>Wait()</code> 方法调用早于goroutine中<code>Add(delta int)</code>，所以此时<code>Wait()</code>计数器为0，则不等待直接跳过。代码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">wait</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
	
	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="c1">// 故意sleep 代表执行逻辑
</span><span class="c1"></span>		<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">1</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Add&#34;</span><span class="p">)</span>
		<span class="nx">wait</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
		<span class="nx">wait</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
	<span class="p">}()</span>
	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="c1">// 故意sleep 代表执行逻辑
</span><span class="c1"></span>		<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">1</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Add&#34;</span><span class="p">)</span>
		<span class="nx">wait</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
		<span class="nx">wait</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
	<span class="p">}()</span>
	<span class="nx">wait</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Done&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>3.不可以在前一个<code>Wait()</code>还未结束时，复用<code>sync.WaitGroup</code> ，举个例子代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">wait</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
	<span class="nx">wait</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="c1">// 故意sleep 代表执行逻辑
</span><span class="c1"></span>		<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">1</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span>
		<span class="nx">wait</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span> <span class="c1">// 正常结束
</span><span class="c1"></span>		<span class="nx">wait</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// 此处panic 因为wait还未结束就再次复用
</span><span class="c1"></span>	<span class="p">}()</span>
	<span class="nx">wait</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Done&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><blockquote>
<p><code>sync.WaitGroup</code> 虽然可以重用，但是是有一个前提的，那就是必须等到上一轮的 <code>Wait()</code>  完成之后，才能重用 <code>sync.WaitGroup</code> 执行下一轮的 <code>Add(delta int)</code>/<code>Wait()</code> ，如果你在 <code>Wait()</code>  还没执行完的时候就调用下一轮 Add 方法，就有可能出现 panic。</p>
</blockquote>
<p>至此<code>sync.WaitGroup</code>的源码解析就解析完了，可能有些地方有些理解上的错误，请各位谅解并且帮忙指出修改意见，如果这篇文章能帮到你，这是我的荣幸。</p>
]]></content>
		</item>
		
		<item>
			<title>「Golang」不谈底层源码只谈使用，万字长文话说Golang的数组与切片</title>
			<link>http://echoblog.cc/posts/golang%E4%B8%8D%E8%B0%88%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81%E5%8F%AA%E8%B0%88%E4%BD%BF%E7%94%A8%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87%E8%AF%9D%E8%AF%B4golang%E7%9A%84%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/</link>
			<pubDate>Mon, 04 Jan 2021 00:00:00 +0000</pubDate>
			
			<guid>http://echoblog.cc/posts/golang%E4%B8%8D%E8%B0%88%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81%E5%8F%AA%E8%B0%88%E4%BD%BF%E7%94%A8%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87%E8%AF%9D%E8%AF%B4golang%E7%9A%84%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/</guid>
			<description>作者注：本篇所有代码采用go1.15+版本编写。
 一、前言 之前一直在写一些同步原语和其他一些东西的的源代码分析，感觉写起来很麻烦，今天开始我决定写几期关于go中常用数据结构的解析、用法以及相关的可能会踩到的坑，正好也当作自己的知识体系巩固，今天开始第一个数据结构的解析&amp;mdash;数组与切片。
二、数组 1、什么是数组  数组（Array）是有序的元素序列。 若将有限个类型相同的变量的集合命名，那么这个名称为数组名。组成数组的各个变量称为数组的分量，也称为数组的元素，有时也称为下标变量。用于区分数组的各个元素的数字编号称为下标。数组是在程序设计中，为了处理方便， 把具有相同类型的若干元素按有序的形式组织起来的一种形式。 这些有序排列的同类数据元素的集合称为数组。摘自百度百科【数组】
 也许各位看官是专业的Go开发者，也许是其他语言转来Go的开发者，我想各位从开发程序哪天起，就没少接触数组这个数据结构。如果看官是C/C++开发者，我想对数组的接触就更多了。正如上面的信息所说，数组是一个有序的元素序列，这个元素的类型都是相同的（排除python,php等动态类型检查的语言除外），那么如何说数组是一个有序的元素序列呢？是其保存的数组都是从大到小或者从小到大排序的意思吗？No！有序指的是数组中的每个元素在内存地址中的顺序是相邻的，计算机会为数组分配一块连续的内存来保存其中的元素，我们可以利用数组中元素的索引快速访问特定元素，如下图所示，这是一个数组a，其有四个元素，这四个元素所占的内存位置分别是【0xc000016140,0xc000016148,0xc000016150,0xc000016158】，其间隔为8字节，为什么为8字节呢，因为int类型在64位计算机上的占用空间是8个字节，这就能体现出数组中所谓的有序元素序列的意义。 2、Go中的数组 (1)、数组的初始化 每个语言都有自己的数组的声明和定义方式，再次我就不在叙述了，我要给各位看官介绍的是在Go中的数组相关的声明以及定义的方式，如下代码：
var a [4]int b := [4]int{1, 2, 3, 4} var c = [4]int{1, 2, 3, 4} d := [...]int{1, 2, 3, 4} 上面三种种方式都没什么问题，跟其他语言都大差不差，主要我们来看第三种，即定义数组d的时候，在[...]符号种间的 ... 是个什么玩意。 d := [...]int{1, 2, 3, 4}这种声明方式，会在编译期间将前面的[...]根据后面的元素个数（比如现在一共4个元素）自动推导成为[4]int{1, 2, 3, 4}，也就是说在编译期间b := [4]int{1, 2, 3, 4}与d := [...]int{1, 2, 3, 4}方式是等同的，只不过变量名是不相同的。
(2)、数组的元素获取 Go中针对数组元素的获取与其他语言也是相同的，均通过下标获取元素，下标的起始位置也仍然为0，但是要注意的是
 与C/C++不同的是，虽然Go中数组的首地址即是数组下标为0的元素的地址，但是Go中无法像C/C++中使用数组的首地址进行++的操作，因为Go中不支持地址计算操作（使用unsafe包除外）。
 数组中如果想获取一个数组的长度，可以使用内置函数len()来获取
func main() { var a [4]int a[0] = 5 a[1] = 2 a[2] = 5 a[3] = 7 // len 获取数组长度 	fmt.</description>
			<content type="html"><![CDATA[<h2 id="heading"></h2>
<blockquote>
<p>作者注：本篇所有代码采用go1.15+版本编写。</p>
</blockquote>
<h2 id="一前言">一、前言</h2>
<p>之前一直在写一些同步原语和其他一些东西的的源代码分析，感觉写起来很麻烦，今天开始我决定写几期关于go中常用数据结构的解析、用法以及相关的可能会踩到的坑，正好也当作自己的知识体系巩固，今天开始第一个数据结构的解析&mdash;数组与切片。</p>
<h2 id="二数组">二、数组</h2>
<h3 id="1什么是数组">1、什么是数组</h3>
<blockquote>
<p>数组（Array）是有序的元素序列。 若将有限个类型相同的变量的集合命名，那么这个名称为数组名。组成数组的各个变量称为数组的分量，也称为数组的元素，有时也称为下标变量。用于区分数组的各个元素的数字编号称为下标。数组是在程序设计中，为了处理方便， 把具有相同类型的若干元素按有序的形式组织起来的一种形式。  这些有序排列的同类数据元素的集合称为数组。摘自百度百科<a href="https://baike.baidu.com/item/%E6%95%B0%E7%BB%84">【数组】</a></p>
</blockquote>
<p>也许各位看官是专业的Go开发者，也许是其他语言转来Go的开发者，我想各位从开发程序哪天起，就没少接触数组这个数据结构。如果看官是C/C++开发者，我想对数组的接触就更多了。正如上面的信息所说，数组是一个有序的元素序列，这个元素的类型都是相同的（排除python,php等动态类型检查的语言除外），那么如何说数组是一个有序的元素序列呢？是其保存的数组都是从大到小或者从小到大排序的意思吗？No！有序指的是数组中的每个元素在内存地址中的顺序是相邻的，计算机会为数组分配一块连续的内存来保存其中的元素，我们可以利用数组中元素的索引快速访问特定元素，如下图所示，这是一个数组a，其有四个元素，这四个元素所占的内存位置分别是【0xc000016140,0xc000016148,0xc000016150,0xc000016158】，其间隔为8字节，为什么为8字节呢，因为int类型在64位计算机上的占用空间是8个字节，这就能体现出数组中所谓的有序元素序列的意义。
<img src="https://img-blog.csdnimg.cn/20201220213340802.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MDA1ODMx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="2go中的数组">2、Go中的数组</h3>
<h4 id="1数组的初始化">(1)、数组的初始化</h4>
<p>每个语言都有自己的数组的声明和定义方式，再次我就不在叙述了，我要给各位看官介绍的是在Go中的数组相关的声明以及定义的方式，如下代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">	<span class="kd">var</span> <span class="nx">a</span> <span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="kt">int</span>
	<span class="nx">b</span> <span class="o">:=</span> <span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">}</span>
	<span class="kd">var</span> <span class="nx">c</span> <span class="p">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">}</span>
	<span class="nx">d</span> <span class="o">:=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">}</span>
</code></pre></div><p>上面三种种方式都没什么问题，跟其他语言都大差不差，主要我们来看第三种，即定义数组<code>d</code>的时候，在<code>[...]</code>符号种间的 <code>...</code> 是个什么玩意。
<code>d := [...]int{1, 2, 3, 4}</code>这种声明方式，会在编译期间将前面的<code>[...]</code>根据后面的元素个数（比如现在一共4个元素）自动推导成为<code>[4]int{1, 2, 3, 4}</code>，也就是说在编译期间<code>b := [4]int{1, 2, 3, 4}</code>与<code>d := [...]int{1, 2, 3, 4}</code>方式是等同的，只不过变量名是不相同的。</p>
<h4 id="2数组的元素获取">(2)、数组的元素获取</h4>
<p>Go中针对数组元素的获取与其他语言也是相同的，均通过下标获取元素，下标的起始位置也仍然为0，但是要注意的是</p>
<blockquote>
<p>与C/C++不同的是，虽然Go中数组的首地址即是数组下标为0的元素的地址，但是Go中无法像C/C++中使用数组的首地址进行++的操作，因为Go中不支持地址计算操作（使用unsafe包除外）。</p>
</blockquote>
<p>数组中如果想获取一个数组的长度，可以使用内置函数<code>len()</code>来获取</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">a</span> <span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="kt">int</span>
	<span class="nx">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="mi">5</span>
	<span class="nx">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="mi">2</span>
	<span class="nx">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="p">=</span> <span class="mi">5</span>
	<span class="nx">a</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="p">=</span> <span class="mi">7</span>
	<span class="c1">// len 获取数组长度
</span><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><h4 id="3数组的参数传递">(3)数组的参数传递</h4>
<p>在Go中，调用函数（方法）时，所有的操作均为传值操作，只不过区别是复制的是指针还是复制的是值本身，所以在对所调用的函数进行传递数组时，会将数组整个复制到函数内，而且在函数内部对形参数组的修改对外部不会产生影响，根据下面的代码以及产生的输出可以看到，数组的传递是复制整个数组的行为，在函数内对其修改对外部不会产生影响：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">
<span class="kd">func</span> <span class="nf">ModifyArray</span><span class="p">(</span><span class="nx">array</span> <span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;modify array before:&#34;</span><span class="p">,</span> <span class="nx">array</span><span class="p">)</span>
	<span class="nx">array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="mi">5</span>
	<span class="nx">array</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="mi">2</span>
	<span class="nx">array</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="p">=</span> <span class="mi">5</span>
	<span class="nx">array</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="p">=</span> <span class="mi">7</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;modify array after:&#34;</span><span class="p">,</span> <span class="nx">array</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">a</span> <span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="kt">int</span>
	<span class="nx">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1</span>
	<span class="nx">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="mi">2</span>
	<span class="nx">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="p">=</span> <span class="mi">3</span>
	<span class="nx">a</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="p">=</span> <span class="mi">4</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;call [ModifyArray] before =&gt;&#34;</span><span class="p">,</span> <span class="nx">a</span><span class="p">)</span>
	<span class="nf">ModifyArray</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;call [ModifyArray] after =&gt;&#34;</span><span class="p">,</span> <span class="nx">a</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// out:
</span><span class="c1">// call [ModifyArray] before =&gt; [1 2 3 4]
</span><span class="c1">// modify array before: [1 2 3 4]
</span><span class="c1">// modify array after: [5 2 5 7]
</span><span class="c1">// call [ModifyArray] after =&gt; [1 2 3 4]
</span><span class="c1"></span>
</code></pre></div><p>正是数组由于这种特性，当传递数组时如果数组过大，也会将整个数组复制到函数中，因此会产生很大的性能损耗和内存损耗。另外数组在声明时必须确定整个数组的容量并且无法在运行期间动态的修改，这导致有些时候的灵活性不足，因此Go为了解决这种问题，引入了另一种可以在运行时动态增减长度的数据结构，即切片，也可以称其为动态数组，其长度并不固定，我们可以向切片中追加元素，它会在容量不足时自动扩容。</p>
<h2 id="三切片">三、切片</h2>
<h3 id="1什么是切片">1、什么是切片</h3>
<blockquote>
<p>理论上来讲数组和切片在数据结构上是一种结构，都是顺序表结构，但是由于数组的固定长度特性，在有些时候对于需要动态的长度的使用情况很不友好，此时就需要利用切片进行对固定长度数组的代替，切片在官方的官方解释如下：
Slices wrap arrays to give a more general, powerful, and convenient interface to sequences of data. Except for items with explicit dimension such as transformation matrices, most array programming in Go is done with slices rather than simple arrays.
大概意思是：
切片是一个经过包装的数组，其可为数据序列提供更通用，更强大和更方便的接口。 除了具有明确维数的项（例如转换矩阵）外，Go中的大多数数组编程都是使用切片而不是简单数组完成的。</p>
</blockquote>
<h3 id="2切片的初始化">2、切片的初始化</h3>
<p>切片的初始化方式与数组的初始化方式不尽相同，切片的初始化不需要指定其具体的长度：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">	<span class="nx">a</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">}</span>
	<span class="kd">var</span> <span class="nx">b</span> <span class="p">[]</span><span class="kt">int</span>
	<span class="nx">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
	<span class="nx">d</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
	<span class="nx">e</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>

</code></pre></div><p>上述代码中，我们主要要理解的就是切片<code>c,d,e</code>，<code>make()</code>是一个内置函数，其可以用来创建一个切片用来使用，其函数签名为：<code>func make(t Type, size ...IntegerType) Type</code>
第</p>
<ol>
<li>一个参数传递的是一个可以用于<code>make()</code>函数使用的数据类型，目前能使用<code>make()</code>函数的类型只有<code>slice，chan，map</code>。</li>
<li>第二个参数是切片的长度，即目前切片有多少个元素，参数是必须填写的，并且不能为负数，可以为零，代表当前切片长度为0，在运行时可以通过<code>len()</code>来获取当前切片的长度。</li>
<li>第三个参数为切片的容量，即当前切片最大可以存储多少个元素，该参数可以不传递，当该参数不传递的时候，使用第二个参数来作为第三个参数的默认值，如果传递该参数，则必须保证该参数的值大于等于第二个参数的值，在运行时可以通过<code>cap()</code>来获取当前切片的容量。</li>
</ol>
<h3 id="3切片的结构">3、切片的结构</h3>
<p>在<strong>什么是切片</strong>一节说过，切片是一个经过包装的数组，那么这个切片被包装成了什么样子呢？下面的结构体是在<code>reflect/value.go</code>中的切片的结构体的一个运行期间表示的切片结构体（切片的最底层结构体是在编译期间被转换的），这个结构体可以清楚的展现出切片在底层是一个什么样子的结构体。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">SliceHeader</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Data</span> <span class="kt">uintptr</span>
	<span class="nx">Len</span>  <span class="kt">int</span>
	<span class="nx">Cap</span>  <span class="kt">int</span>
<span class="p">}</span>
</code></pre></div><p>首先介绍一下这三个字段的用处：<code>Data uintptr</code>是一个指向底层数组的指针，这也体现出切片的底层其实实际上也是一个数组，<code>Len  int</code>是一个用于标记当前切片元素个数的字段，可以理解为在初始化切片时<code>make([]int, 4, 10)</code>时的第二个参数，<code>Cap  int</code>是用于标记当前切片的容量的字段可以理解为在初始化切片时<code>make([]int, 4, 10)</code>时的第三个参数。</p>
<h3 id="4切片的追加">4、切片的追加</h3>
<p>切片与数组不同的一点就是可以在运行时动态的向切片内增加或者减少数据，首先我们先来说一下如何向切片中追加数据，请看如下代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">a</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
	<span class="nx">a</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// out:
</span><span class="c1">// [1 2 3]
</span></code></pre></div><p>上述代码中，内置函数<code>func append(slice []Type, elems ...Type) []Type</code>就是用于向切片中追加元素的函数，其第二个参数是可变参数，可变参数的含义是可以根据需要传入0或多个值，上述代码中，<code>make([]int, 0, 10)</code>代表创建一个容量为10，目前元素为0个的切片，如果第二个参数设为大于0的值，则代表当前切片已经有了多少元素，这些元素将被默认的置为零值（数值类型的零值为0，字符串为“”，指针或者interface，map,chan等类型为nil），元素追加操作，会在当前切片元素长度<code>len</code>的后面增加对应数量的新元素，上述代码中追加之前长度为0，追加后长度为3，那么问题来了如果追加的长度超过了设置容量的数值时会怎样？这就引出了切片的另一个特性，动态扩容。</p>
<h3 id="5切片的扩容">5、切片的扩容</h3>
<p>当在调用<code>append()</code>对切片进行追加时，如果添加元素的个数加上原有切片长度大于原有容量的话就会触发扩容操作，扩容操作时，会根据以下的几个条件进行对扩容大小的选择：</p>
<ol>
<li>当期望容量（即当前元素长度加上要添加的元素个数）大于当前容量的两倍时，按照期望容量的大小作为目标容量大小。</li>
<li>如果条件1不满足，并且当前切片长度小于1024时（在下一个大版本即1.16时这个条件会被改变为：当前容量小于1024时）目标容量大小为当前容量大小的两倍。</li>
<li>如果条件1，2都不满足则循环计算并增加目标容量，每次循环增加原有容量的25%，直至目标容量超过期望容量。</li>
</ol>
<p>上述扩容条件只是针对长度与容量来做的计算，实际扩容比这更复杂， 还会考虑到根据切片的元素类型所占用的内存空间以及目标容量的大小做乘积计算后按照元素类型所占用空间为1字节，8字节或者2的倍数字节，做内存对齐操作并向上取整，也就是说最终切片的扩容大小不一定是上述三条中得出的目标容量（此处有些复杂就不再文章中详细表述了，如果有想了解的可以与作者联系一起交流学习）。</p>
<p>切片扩容后，原先切片的底层指向数组的指针会被替换为一个指向新的、长度足够的数组的指针，同时原有的数据也会被拷贝到新的数组地址中。</p>
<h3 id="6切片传递以及扩容带来的问题">6、切片传递以及扩容带来的问题</h3>
<p>当我们想把一个切片传入一个函数或方法中时，由于切片的特性，其复制的仅仅是这个切片的结构体，也就是在3中所讲的切片的结构，其指向数组的指针以及长度，容量均会被复制到函数内。所以在函数内对切片进行修改是会影响到外部切片的。事例代码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">ModifySlice</span><span class="p">(</span><span class="nx">slice</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">slice</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="mi">2</span>
	<span class="nx">slice</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="mi">3</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">a</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;传入函数前的切片内容：&#34;</span><span class="p">,</span> <span class="nx">a</span><span class="p">)</span>
	<span class="nf">ModifySlice</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;传入函数后的切片内容：&#34;</span><span class="p">,</span> <span class="nx">a</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// out:
</span><span class="c1">// 传入函数前的切片内容： [0 0 0]
</span><span class="c1">// 传入函数后的切片内容： [2 3 0]
</span></code></pre></div><p>从代码中可以看出，切片在传入函数后被修改对外部产生了影响，所以在使用切片作为参数传入函数时，一定要注意这一点。</p>
<p>有同学可能想问，如果在函数内部对切片进行追加会发生什么呢？请看下列代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">
<span class="kd">func</span> <span class="nf">AppendSlice</span><span class="p">(</span><span class="nx">slice</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">slice</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">slice</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;函数内追加后的切片内容：&#34;</span><span class="p">,</span> <span class="nx">slice</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">a</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;传入函数前的切片内容：&#34;</span><span class="p">,</span> <span class="nx">a</span><span class="p">)</span>
	<span class="nf">AppendSlice</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;传入函数后的切片内容：&#34;</span><span class="p">,</span> <span class="nx">a</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// out:
</span><span class="c1">// 传入函数前的切片内容： [0 0]
</span><span class="c1">// 函数内修改完毕的切片内容： [0 0 1]
</span><span class="c1">// 传入函数后的切片内容： [0 0]
</span></code></pre></div><p>诶？为什么会这样，说好的切片在函数内部对其修改会影响外部切片呢？请听我如实道来：</p>
<ol>
<li>首先的确，切片传入函数内并对其修改的确会对外部产生影响，但是仅限于使用下标操作。</li>
<li>在函数内使用<code>append()</code>函数追加元素的确也会对外部切片产生影响，**但是！**在函数内<code>append()</code>之后，虽然在切片内部指向底层数组的指针的确也增加了新的元素，并且其切片的长度字段也增加了1，但问题是切片的长度字段是值复制，在传递切片的时候把整个切片结构体复制进来的时候，由于长度字段和容量字段都不是指针，所以他复制的只是传入那一刻的切片元素长度，由于是值复制，在函数内对这个长度字段进行修改就完全不会影响外部的切片，所以我们看到的结果就成了这个样子。</li>
<li>但是有人要问了，那到底这个元素是否被追加到切片了，答案是的确追加到了，但是由于外部切片的长度字段并没有改变，在输出的时候只是输出了从0到长度字段-1 这么多的元素，所以哪怕是被追加到了底层数组指针的对应位置，由于长度字段的值没有达到那个对应位置，因此就不能显示出那个位置的元素。</li>
</ol>
<p>综上所述，切片传入函数中并且对齐进行<code>append()</code>操作时虽然的确增加进去了但是外部却无法显示，因此，<em><strong>不要在函数内对切片进行<code>append()</code>除非你传入的是一个指向切片的指针。</strong></em></p>
<p>关于切片与函数内扩容，还有一个坑需要大家注意，请看下述代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">AppendSlice</span><span class="p">(</span><span class="nx">slice</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">slice</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">slice</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
	<span class="nx">slice</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1</span>
	<span class="nx">slice</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="mi">2</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;函数内追加后的切片内容：&#34;</span><span class="p">,</span> <span class="nx">slice</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">a</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;传入函数前的切片内容：&#34;</span><span class="p">,</span> <span class="nx">a</span><span class="p">)</span>
	<span class="nf">AppendSlice</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;传入函数后的切片内容：&#34;</span><span class="p">,</span> <span class="nx">a</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// out:
</span><span class="c1">// 传入函数前的切片内容： [0 0]
</span><span class="c1">// 函数内修改完毕的切片内容： [1 2 1]
</span><span class="c1">// 传入函数后的切片内容： [0 0]
</span><span class="c1"></span>

</code></pre></div><p>有人会问这不科学，我知道了<code>append()</code>在函数内追加对外部切片没有影响，但是为啥使用下标修改还是没有影响？答案就在于<code>append()</code>的扩容操作，上面说过<code>append()</code>扩容操作会</p>
<blockquote>
<p><em><strong>将原先切片的底层指向数组的指针会被替换为一个指向新的、长度足够的数组的指针，同时原有的数据也会被拷贝到新的数组地址中</strong></em></p>
</blockquote>
<p>那么这就好解释为什么在上面的代码中在追加完之后对其下标修改还是对外部没有影响了，答案就是在此<code>append()</code>时由于原本的容量并不足以添加新的元素，所以产生了扩容，扩容就会将原有的底层数组切片被替换掉。既然被替换了也就代表跟外部的切片完全没有关系了，因此，上面代码的输出也就合情合理了。</p>
<blockquote>
<p><strong>总而言之，并不建议在函数内部对外部传入的切片进行任何的<code>append()</code>操作，因为有时候有可能会产生出各种意想不到的情况，如果必须在函数内进行<code>append()</code>操作的话，请传递指向切片的指针。</strong></p>
</blockquote>
<h3 id="7切片的截取复制">7、切片的截取复制</h3>
<p>有时候我们可能需要把一个切片复制给另一个变量去做某些事情，此时我们就需要了解关于切片的复制，切片的复制有两种方式，一种是与原切片关联的截取，一种是与原切片无关的复制（这块是我自己起的名字，实在不知道该怎么称呼了）</p>
<h4 id="1与原切片有关的截取">1、与原切片有关的截取</h4>
<p>go语言提供了一种切片的复截取方式，代码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">sliceA</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">}</span>

	<span class="nx">sliceB</span> <span class="o">:=</span> <span class="nx">sliceA</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>

	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Slice A:&#34;</span><span class="p">,</span> <span class="nx">sliceA</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Slice B:&#34;</span><span class="p">,</span> <span class="nx">sliceB</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// out:
</span><span class="c1">// Slice A: [1 2 3 4 5]
</span><span class="c1">// Slice B: [2 3]
</span><span class="c1"></span>
</code></pre></div><p>上述代码中，<code>sliceB := sliceA[1:3]</code>代表把<code>sliceA</code>切片中，下标从1开始到2的元素复制给<code>sliceB</code>，其中<code>[x:y]</code>的取值范围是一个左闭右开区间（数学不好应该是这样称呼吧），即：$$[x:y)$$ 这个样子，如果x为不填代表从0开始到y-1的范围内的元素，如果y不填代表从x到切片<code>len()-1</code>的范围内的元素。</p>
<p>截取切片有一个可能会踩到的坑希望各位可以避开，请看如下代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">sliceA</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">}</span>
	<span class="nx">sliceB</span> <span class="o">:=</span> <span class="nx">sliceA</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Slice A:&#34;</span><span class="p">,</span> <span class="nx">sliceA</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Slice B:&#34;</span><span class="p">,</span> <span class="nx">sliceB</span><span class="p">)</span>
	<span class="nx">sliceB</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="mi">333</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Modify Slice A:&#34;</span><span class="p">,</span> <span class="nx">sliceA</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Modify Slice B:&#34;</span><span class="p">,</span> <span class="nx">sliceB</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// out:
</span><span class="c1">// Slice A: [1 2 3 4 5]
</span><span class="c1">// Slice B: [2 3]
</span><span class="c1">// Modify Slice A: [1 333 3 4 5]
</span><span class="c1">// Modify Slice B: [333 3]
</span><span class="c1"></span>
</code></pre></div><p>我对<code>sliceB</code>的下标为0的元素进行了赋值为333，但是为什么<code>sliceA</code>下标为1的元素也同时发生了改变呢？这就要从切片截取的截取方式来说明了。</p>
<blockquote>
<p>切片的截取是在原切片的底层数组之中直接复制对应起始位置的指针和截取长度赋值给新的切片的，用上面的代码举例，实际上<code>sliceB</code>与<code>sliceA</code>指向的是同一块的数组地址空间，只不过<code>sliceB</code>指向的是<code>sliceA[1]</code>的地址，我们打印一下地址就可以看出来：</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">sliceA</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">}</span>
	<span class="nx">sliceB</span> <span class="o">:=</span> <span class="nx">sliceA</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Slice A [1] addr:&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">sliceA</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Slice B [0] addr:&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">sliceB</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

<span class="p">}</span>
<span class="c1">// out:
</span><span class="c1">// Slice A [1] addr: 0xc000018128
</span><span class="c1">// Slice B [0] addr: 0xc000018128
</span></code></pre></div><blockquote>
<p>从上述代码的输出就可以看到<code>sliceA[1]</code>的地址和<code>sliceB[0]</code>的地址相同，也就是说切片的截取操作并不复制切片指向的元素。它创建一个新的切片并复用原来切片的底层数组。 这使得切片操作和数组索引一样高效。因此，通过一个新切片修改元素会影响到原始切片的对应元素。</p>
</blockquote>
<p>但是虽然说对新的切片进行修改会影响原切片，但是有一种方式是例外的</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">sliceA</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">}</span>
	<span class="nx">sliceB</span> <span class="o">:=</span> <span class="nx">sliceA</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
	<span class="nx">sliceB</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">sliceB</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Append after slice A :&#34;</span><span class="p">,</span> <span class="nx">sliceA</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Append after slice B :&#34;</span><span class="p">,</span> <span class="nx">sliceB</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// out:
</span><span class="c1">// Append after slice A : [1 2 3 4 5]
</span><span class="c1">// Append after slice B : [2 3 1 2 3 4]
</span></code></pre></div><p>诶？这是为什么，为什么没有修改<code>sliceA</code>，答案是：</p>
<blockquote>
<p>在切片截取时，新切片的容量是按照<code>[x:y]</code>截取时中<code>cap(sliceA)-x</code>的值计算的，也就是说在上述代码中，<code>sliceB</code>的容量是<code>cap(sliceA)-1</code>也就是5-1等于4，那么在下面进行<code>append</code>操作时，需要添加进去的4个元素加上原有的长度2已经超过了容量4，所以产生了扩容，上面扩容章节说了：<em><strong>当发生扩容时会产生一个新的底层数组并将原有的数据拷贝将原先切片的底层指向数组的指针会被替换为一个指向新的、长度足够的数组的指针，同时原有的数据也会被拷贝到新的数组地址中</strong></em>，由于变成了新的底层数组，所以对原有的<code>sliceA</code>切片也就没有影响了。</p>
</blockquote>
<p>那么有人想问了，有没有一种方法能让我复制出的新切片在对其修改的时候，不影响原切片呢？答案是有的，go提供了一个内嵌函数<code>copy()</code>。</p>
<h4 id="2与原切片无关的copy">2、与原切片无关的<code>copy()</code></h4>
<p>如果想把 <code>sliceA</code>完整的复制到<code>sliceB</code>并且在修改<code>sliceB</code>时不修改 <code>sliceA</code>，该怎么办呢？go提供了一个内嵌函数<code>copy()</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nb">copy</span><span class="p">(</span><span class="nx">dst</span><span class="p">,</span> <span class="nx">src</span> <span class="p">[]</span><span class="nx">Type</span><span class="p">)</span> <span class="kt">int</span>
</code></pre></div><p>该函数接受两个切片作为参数并且返回复制了多少个元素，第一个参数是目标切片，第二个参数是原切片，即把第二个切片里面的值复制给第一个参数的切片。请看下面代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">sliceA</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">}</span>
	<span class="nx">sliceB</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
	<span class="nb">copy</span><span class="p">(</span><span class="nx">sliceB</span><span class="p">,</span> <span class="nx">sliceA</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;slice A :&#34;</span><span class="p">,</span> <span class="nx">sliceA</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;slice B :&#34;</span><span class="p">,</span> <span class="nx">sliceB</span><span class="p">)</span>
	<span class="nx">sliceB</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="mi">213123</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;modify slice A :&#34;</span><span class="p">,</span> <span class="nx">sliceA</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;modify slice B :&#34;</span><span class="p">,</span> <span class="nx">sliceB</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;slice A [0] addr:&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">sliceA</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;slice B [0] addr:&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">sliceB</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

<span class="p">}</span>

<span class="c1">// out:
</span><span class="c1">// slice A : [1 2 3 4 5]
</span><span class="c1">// slice B : [1 2]
</span><span class="c1">// modify slice A : [1 2 3 4 5]
</span><span class="c1">// modify slice B : [213123 2]
</span><span class="c1">// slice A [0] addr: 0xc000018120
</span><span class="c1">// slice B [0] addr: 0xc000016140
</span><span class="c1"></span>
</code></pre></div><p>有上述代码可以看出，我复制了 <code>sliceA</code>给 <code>sliceB</code>，为什么只复制了前两个呢？<strong>因为<code>copy()</code>最终的复制长度，取决于目标切片当前的元素长度</strong>，**即 <code>sliceA</code>能够复制给 <code>sliceB</code>多少个值，取决于 <code>len(sliceB)</code>或<code>len(sliceA)</code>哪个比较小。**而复制操作是从下标0开始往后复制，直到复制到<code>len(sliceB)</code>或<code>len(sliceA)</code>最小的那个值的地方停止（这里可能没太说清楚，自己尝试一下就能了解了）。</p>
<p>在上述代码中，对复制完的<code>sliceB</code>进行了修改，修改后发现并没有影响<code>sliceA</code>，然后打印其地址发现并不相同，因为两者并不是引用的同一个底层数组。</p>
<h2 id="三总结">三、总结</h2>
<p>这篇文章写了大约八个小时，因为第一次写这么长的东西，所以有些东西可能解释的不太清楚或者表述的不太明白，希望大家可以见谅，另外如果文中哪里有说错的，请各位批评指正，如果能帮到各位，是我的荣幸。</p>
]]></content>
		</item>
		
		<item>
			<title>「Golang」关于通过proto消息名，创建proto.Message对象</title>
			<link>http://echoblog.cc/posts/golang%E5%85%B3%E4%BA%8E%E9%80%9A%E8%BF%87proto%E6%B6%88%E6%81%AF%E5%90%8D%E5%88%9B%E5%BB%BAproto.message%E5%AF%B9%E8%B1%A1/</link>
			<pubDate>Mon, 04 Jan 2021 00:00:00 +0000</pubDate>
			
			<guid>http://echoblog.cc/posts/golang%E5%85%B3%E4%BA%8E%E9%80%9A%E8%BF%87proto%E6%B6%88%E6%81%AF%E5%90%8D%E5%88%9B%E5%BB%BAproto.message%E5%AF%B9%E8%B1%A1/</guid>
			<description>前几天在做一些proto相关业务逻辑编写，在编写过程中，需要通过proto的message full name 去动态的创建一个proto.Message对象，在网上找一些相关的内容也没找到，所以就自己研究了一下并且实现了这个功能。
下面是proto v1版本实现代码。
//该实现仅用于proto v1版本实现 即	github.com/golang/protobuf 库 func parseRequest(msgName protoreflect.FullName, data []byte) (proto.Message,error) { // 获取full name对应的message ，如果不存在则返回error 	msgType, err := protoregistry.GlobalTypes.FindMessageByName(msgName) if err != nil { return nil, err } //上面返回的是一个message 反射类型，需要把它new出一个 protoreflect.Message类型然后转换成protoiface.MessageV1 	//此时 根据源代码显示 proto.Message实现为 type Message = protoiface.MessageV1 	//即type Message 为 protoiface.MessageV1 的别名 	msg := proto.MessageV1(msgType.New()) err = proto.Unmarshal(data, msg) if err != nil { return nil, err } return msg, nil } proto v2版本实现如下</description>
			<content type="html"><![CDATA[<p>  前几天在做一些proto相关业务逻辑编写，在编写过程中，需要通过proto的message full name 去动态的创建一个proto.Message对象，在网上找一些相关的内容也没找到，所以就自己研究了一下并且实现了这个功能。</p>
<p>下面是proto v1版本实现代码。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">//该实现仅用于proto v1版本实现 即	github.com/golang/protobuf 库
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">parseRequest</span><span class="p">(</span><span class="nx">msgName</span> <span class="nx">protoreflect</span><span class="p">.</span><span class="nx">FullName</span><span class="p">,</span> <span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">proto</span><span class="p">.</span><span class="nx">Message</span><span class="p">,</span><span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 获取full name对应的message ，如果不存在则返回error
</span><span class="c1"></span>	<span class="nx">msgType</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">protoregistry</span><span class="p">.</span><span class="nx">GlobalTypes</span><span class="p">.</span><span class="nf">FindMessageByName</span><span class="p">(</span><span class="nx">msgName</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="c1">//上面返回的是一个message 反射类型，需要把它new出一个 protoreflect.Message类型然后转换成protoiface.MessageV1
</span><span class="c1"></span>	<span class="c1">//此时 根据源代码显示 proto.Message实现为 type Message = protoiface.MessageV1
</span><span class="c1"></span>	<span class="c1">//即type Message 为 protoiface.MessageV1 的别名
</span><span class="c1"></span>	<span class="nx">msg</span> <span class="o">:=</span> <span class="nx">proto</span><span class="p">.</span><span class="nf">MessageV1</span><span class="p">(</span><span class="nx">msgType</span><span class="p">.</span><span class="nf">New</span><span class="p">())</span>
	<span class="nx">err</span> <span class="p">=</span> <span class="nx">proto</span><span class="p">.</span><span class="nf">Unmarshal</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="nx">msg</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">msg</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><p>proto v2版本实现如下</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">//该实现仅用于proto v2版本实现 即&#34;google.golang.org/protobuf/proto&#34;库
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">parseRequest</span><span class="p">(</span><span class="nx">msgName</span> <span class="nx">protoreflect</span><span class="p">.</span><span class="nx">FullName</span><span class="p">,</span> <span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">proto</span><span class="p">.</span><span class="nx">Message</span><span class="p">,</span><span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 获取full name对应的message ，如果不存在则返回error
</span><span class="c1"></span>	<span class="nx">msgType</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">protoregistry</span><span class="p">.</span><span class="nx">GlobalTypes</span><span class="p">.</span><span class="nf">FindMessageByName</span><span class="p">(</span><span class="nx">msgName</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="c1">//上面返回的是一个message type 反射类型，需要把它new出一个 protoreflect.Message类型然后转换成protoreflect.ProtoMessage
</span><span class="c1"></span>	<span class="c1">//此时 根据源代码显示 proto.Message实现为 type Message = protoreflect.ProtoMessage	
</span><span class="c1"></span>	<span class="c1">//即type Message 为 protoreflect.ProtoMessage的别名
</span><span class="c1"></span>	<span class="nx">msg</span> <span class="o">:=</span> <span class="nx">msgType</span><span class="p">.</span><span class="nf">New</span><span class="p">().</span><span class="nf">Interface</span><span class="p">()</span>
	<span class="nx">err</span> <span class="p">=</span> <span class="nx">proto</span><span class="p">.</span><span class="nf">Unmarshal</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="nx">msg</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">msg</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><p>  整体业务流程是，传进一个proto的 full name 然后根据这个名字去创建对应的message，然后把data 解析到这个message中。</p>
<blockquote>
<p>关于protov1 v2版本的区别，v2版本的动态特性更强。具体区别请看下面的链接
<a href="https://www.infoq.cn/article/dyX9bq5uFyK4hCEPgmuj"> https://www.infoq.cn/article/dyX9bq5uFyK4hCEPgmuj</a></p>
</blockquote>
<blockquote>
<p>第一次写博客写的不好，望请见谅希望各位海涵，希望可以帮到大家。</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>「Golang」关于通道的一些总结</title>
			<link>http://echoblog.cc/posts/golang%E5%85%B3%E4%BA%8E%E9%80%9A%E9%81%93%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/</link>
			<pubDate>Mon, 04 Jan 2021 00:00:00 +0000</pubDate>
			
			<guid>http://echoblog.cc/posts/golang%E5%85%B3%E4%BA%8E%E9%80%9A%E9%81%93%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/</guid>
			<description> 通道分为有缓冲与无缓冲，创建方式分别为make(chan type)或make(chan type ,0) 与make(chan type ,len)。 无缓冲通道在没有接收端或没有发送端的时候将会阻塞。 无缓冲通道可以完成两个go程的同步消息处理操作，并且无缓冲通道的接收数据会发生在唤醒放者之前。 如下图（画的不好见谅）：  如果有缓冲通道在发送时发现队列已满，则发送方将等待直至接收方取出数据，如果队列为空则接收方同样等待发送方放入数据。 for range 可以在一个未关闭的同道中循环接收数据，与 for { i, ok := &amp;lt;-ch if !ok { break } fmt.Println(i) } 等同，但当通道关闭时则会跳出循环。 select{} 将会永久阻塞，即无任何case的select 会永久阻塞 select的多个case满足则会随机选择，此特点是为了防止饥饿问题。 通道为nil时发送与接收均会阻塞，在select也会永不执行  </description>
			<content type="html"><![CDATA[<ol>
<li>通道分为有缓冲与无缓冲，创建方式分别为make(chan type)或make(chan type ,0) 与make(chan type ,len)。</li>
<li>无缓冲通道在没有接收端或没有发送端的时候将会阻塞。</li>
<li>无缓冲通道可以完成两个go程的同步消息处理操作，并且无缓冲通道的接收数据会发生在唤醒放者之前。 如下图（画的不好见谅）：
<img src="https://img-blog.csdnimg.cn/20201127193619713.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MDA1ODMx,size_16,color_FFFFFF,t_70" alt="序号3解释"></li>
<li>如果有缓冲通道在发送时发现队列已满，则发送方将等待直至接收方取出数据，如果队列为空则接收方同样等待发送方放入数据。</li>
<li>for range 可以在一个未关闭的同道中循环接收数据，与
<code>for { i, ok := &lt;-ch if !ok { break } fmt.Println(i) }</code> 等同，但当通道关闭时则会跳出循环。</li>
<li>select{} 将会永久阻塞，即无任何case的select 会永久阻塞</li>
<li>select的多个case满足则会随机选择，此特点是为了防止饥饿问题。</li>
<li>通道为nil时发送与接收均会阻塞，在select也会永不执行</li>
</ol>
]]></content>
		</item>
		
		<item>
			<title>「Golang」遇到的有趣的Go赋值问题并附带以下不负责任的解析</title>
			<link>http://echoblog.cc/posts/golang%E9%81%87%E5%88%B0%E7%9A%84%E6%9C%89%E8%B6%A3%E7%9A%84go%E8%B5%8B%E5%80%BC%E9%97%AE%E9%A2%98%E5%B9%B6%E9%99%84%E5%B8%A6%E4%BB%A5%E4%B8%8B%E4%B8%8D%E8%B4%9F%E8%B4%A3%E4%BB%BB%E7%9A%84%E8%A7%A3%E6%9E%90/</link>
			<pubDate>Mon, 04 Jan 2021 00:00:00 +0000</pubDate>
			
			<guid>http://echoblog.cc/posts/golang%E9%81%87%E5%88%B0%E7%9A%84%E6%9C%89%E8%B6%A3%E7%9A%84go%E8%B5%8B%E5%80%BC%E9%97%AE%E9%A2%98%E5%B9%B6%E9%99%84%E5%B8%A6%E4%BB%A5%E4%B8%8B%E4%B8%8D%E8%B4%9F%E8%B4%A3%E4%BB%BB%E7%9A%84%E8%A7%A3%E6%9E%90/</guid>
			<description>今天在做一道题的时候发现了这么一个有趣的题目：
func main() { index := 1 a := []string{&amp;#34;f&amp;#34;, &amp;#34;ff&amp;#34;, &amp;#34;fff&amp;#34;} index, a[index-1] = 88888, &amp;#34;ffff&amp;#34; fmt.Println(a) } 这个输出是什么呢？我第一眼看的时候感觉会输出panic，因为下标超界，但是运行之后发现没这么简单，运行结果如下 运行之后我惊了，不知道为什么会这样，然后我就输出了汇编看了一下（去掉了一些多余的汇编代码，我们只看赋值那行的汇编）：
 本篇文章基于go1.15+版本以及mac os 操作系统
 //把index的值复制到DX寄存器中 0x00f2 00242 MOVQ &amp;#34;&amp;#34;.index+48(SP), DX // DX寄存器的值-1 在此能看出是先对其进行了-1 0x00f7 00247 DECQ DX // 把DX寄存器里的值复制autotmp_4+56这个地址上 0x00fa 00250 MOVQ DX, &amp;#34;&amp;#34;..autotmp_4+56(SP) // 把88888赋值给index+48地址即赋值88888给index 0x00ff 00255 MOVQ $88888, &amp;#34;&amp;#34;.index+48(SP) // 把刚才-1了的值放在AX寄存器中 0x0108 00264 MOVQ &amp;#34;&amp;#34;..autotmp_4+56(SP), AX // 把a就是那个数组的偏移104个地址的值放入DX寄存器 0x010d 00269 MOVQ &amp;#34;&amp;#34;.a+104(SP), DX // 把a就是那个数组的偏移112个地址的值放入DX寄存器 0x0112 00274 MOVQ &amp;#34;&amp;#34;.</description>
			<content type="html"><![CDATA[<p>今天在做一道题的时候发现了这么一个有趣的题目：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">index</span> <span class="o">:=</span> <span class="mi">1</span>
	<span class="nx">a</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;f&#34;</span><span class="p">,</span> <span class="s">&#34;ff&#34;</span><span class="p">,</span> <span class="s">&#34;fff&#34;</span><span class="p">}</span>
	<span class="nx">index</span><span class="p">,</span> <span class="nx">a</span><span class="p">[</span><span class="nx">index</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="mi">88888</span><span class="p">,</span> <span class="s">&#34;ffff&#34;</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>这个输出是什么呢？我第一眼看的时候感觉会输出panic，因为下标超界，但是运行之后发现没这么简单，运行结果如下
<img src="https://img-blog.csdnimg.cn/20201222175359288.png" alt="在这里插入图片描述">
运行之后我惊了，不知道为什么会这样，然后我就输出了汇编看了一下（去掉了一些多余的汇编代码，我们只看赋值那行的汇编）：</p>
<blockquote>
<p>本篇文章基于go1.15+版本以及mac os 操作系统</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">//把index的值复制到DX寄存器中
</span><span class="c1"></span><span class="mh">0x00f2</span> <span class="mo">00242</span> <span class="nx">MOVQ</span>    <span class="s">&#34;&#34;</span><span class="p">.</span><span class="nx">index</span><span class="o">+</span><span class="mi">48</span><span class="p">(</span><span class="nx">SP</span><span class="p">),</span> <span class="nx">DX</span> 
 <span class="c1">// DX寄存器的值-1 在此能看出是先对其进行了-1
</span><span class="c1"></span><span class="mh">0x00f7</span> <span class="mo">00247</span> <span class="nx">DECQ</span>    <span class="nx">DX</span> 
<span class="c1">// 把DX寄存器里的值复制autotmp_4+56这个地址上
</span><span class="c1"></span><span class="mh">0x00fa</span> <span class="mo">00250</span> <span class="nx">MOVQ</span>    <span class="nx">DX</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">..</span><span class="nx">autotmp_4</span><span class="o">+</span><span class="mi">56</span><span class="p">(</span><span class="nx">SP</span><span class="p">)</span> 
<span class="c1">// 把88888赋值给index+48地址即赋值88888给index
</span><span class="c1"></span><span class="mh">0x00ff</span> <span class="mo">00255</span> <span class="nx">MOVQ</span>    <span class="err">$</span><span class="mi">88888</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">.</span><span class="nx">index</span><span class="o">+</span><span class="mi">48</span><span class="p">(</span><span class="nx">SP</span><span class="p">)</span>
<span class="c1">// 把刚才-1了的值放在AX寄存器中
</span><span class="c1"></span><span class="mh">0x0108</span> <span class="mo">00264</span> <span class="nx">MOVQ</span>    <span class="s">&#34;&#34;</span><span class="p">..</span><span class="nx">autotmp_4</span><span class="o">+</span><span class="mi">56</span><span class="p">(</span><span class="nx">SP</span><span class="p">),</span> <span class="nx">AX</span>
<span class="c1">// 把a就是那个数组的偏移104个地址的值放入DX寄存器
</span><span class="c1"></span><span class="mh">0x010d</span> <span class="mo">0026</span><span class="mi">9</span> <span class="nx">MOVQ</span>    <span class="s">&#34;&#34;</span><span class="p">.</span><span class="nx">a</span><span class="o">+</span><span class="mi">104</span><span class="p">(</span><span class="nx">SP</span><span class="p">),</span> <span class="nx">DX</span>
<span class="c1">// 把a就是那个数组的偏移112个地址的值放入DX寄存器
</span><span class="c1"></span><span class="mh">0x0112</span> <span class="mo">00274</span> <span class="nx">MOVQ</span>    <span class="s">&#34;&#34;</span><span class="p">.</span><span class="nx">a</span><span class="o">+</span><span class="mi">112</span><span class="p">(</span><span class="nx">SP</span><span class="p">),</span> <span class="nx">CX</span>
<span class="c1">// 比较AX寄存器和CX寄存器 
</span><span class="c1"></span><span class="mh">0x0117</span> <span class="mo">0027</span><span class="mi">9</span> <span class="nx">CMPQ</span>    <span class="nx">AX</span><span class="p">,</span> <span class="nx">CX</span>
<span class="c1">// 如果没溢出就跳到293
</span><span class="c1"></span><span class="mh">0x011a</span> <span class="mo">002</span><span class="mi">82</span> <span class="nx">JCS</span>     <span class="mi">293</span>
<span class="c1">// 否则
</span><span class="c1"></span><span class="mh">0x011c</span> <span class="mo">002</span><span class="mi">84</span> <span class="nx">NOP</span>
<span class="c1">// 跳到605
</span><span class="c1"></span><span class="mh">0x0120</span> <span class="mo">002</span><span class="mi">88</span> <span class="nx">JMP</span>     <span class="mi">605</span>
<span class="c1">// 逻辑移位（好像是）
</span><span class="c1"></span><span class="mh">0x0125</span> <span class="mo">002</span><span class="mi">93</span> <span class="nx">SHLQ</span>    <span class="err">$</span><span class="mi">4</span><span class="p">,</span> <span class="nx">AX</span>
<span class="c1">// 把DX的AX*1的地址给CX Ax就是被-1后的那个值存放的地方
</span><span class="c1"></span><span class="mh">0x0129</span> <span class="mo">002</span><span class="mi">97</span> <span class="nf">LEAQ</span>    <span class="p">(</span><span class="nx">DX</span><span class="p">)(</span><span class="nx">AX</span><span class="o">*</span><span class="mi">1</span><span class="p">),</span> <span class="nx">CX</span>
<span class="mh">0x012d</span> <span class="mo">00301</span> <span class="nx">LEAQ</span>    <span class="mi">8</span><span class="p">(</span><span class="nx">CX</span><span class="p">),</span> <span class="nx">CX</span>
<span class="mh">0x0131</span> <span class="mo">00305</span> <span class="nx">MOVQ</span>    <span class="err">$</span><span class="mi">4</span><span class="p">,</span> <span class="p">(</span><span class="nx">CX</span><span class="p">)</span>
<span class="c1">// 反正就是之前做了一堆复制和传地址操作把DX的AX*1的地址给了DI
</span><span class="c1"></span><span class="mh">0x0138</span> <span class="mo">00312</span> <span class="nf">LEAQ</span>    <span class="p">(</span><span class="nx">DX</span><span class="p">)(</span><span class="nx">AX</span><span class="o">*</span><span class="mi">1</span><span class="p">),</span> <span class="nx">DI</span>
<span class="err">·····</span>
<span class="c1">// 把ffff这个字符串放到AX寄存器内
</span><span class="c1"></span><span class="mh">0x014a</span> <span class="mo">00330</span> <span class="nx">LEAQ</span>    <span class="k">go</span><span class="p">.</span><span class="kt">string</span><span class="p">.</span><span class="s">&#34;ffff&#34;</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">AX</span>
<span class="c1">// 从AX寄存器复制出ffff复制到DI就是要修改的数组的那个位置
</span><span class="c1"></span><span class="mh">0x0151</span> <span class="mo">00337</span> <span class="nx">MOVQ</span>    <span class="nx">AX</span><span class="p">,</span> <span class="p">(</span><span class="nx">DI</span><span class="p">)</span>

</code></pre></div><p>大概就是这样，其实最根本的原因就是</p>
<blockquote>
<p><strong>对<code>index-1</code>这个操作早于给<code>index</code>赋值这个操作，并且提前将其放到了某块地址中</strong>。<strong>所以后续的数组下标赋值操作是根据这个放在某个地址中的i<code>ndex-1</code>的值进行的赋值。</strong></p>
</blockquote>
<h2 id="总结一下">总结一下：</h2>
<blockquote>
<p>这种多重赋值分为两个步骤，有先后顺序：
计算等号左边的索引表达式和取址表达式，接着计算等号右边的表达式</p>
</blockquote>
<blockquote>
<p>作者对汇编不甚了解，如果哪里有错误请大佬指正。</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>「Reprint」关于Golang内联优化的一些策略和限制</title>
			<link>http://echoblog.cc/posts/reprint%E5%85%B3%E4%BA%8Egolang%E5%86%85%E8%81%94%E4%BC%98%E5%8C%96%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AD%96%E7%95%A5%E5%92%8C%E9%99%90%E5%88%B6/</link>
			<pubDate>Mon, 04 Jan 2021 00:00:00 +0000</pubDate>
			
			<guid>http://echoblog.cc/posts/reprint%E5%85%B3%E4%BA%8Egolang%E5%86%85%E8%81%94%E4%BC%98%E5%8C%96%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AD%96%E7%95%A5%E5%92%8C%E9%99%90%E5%88%B6/</guid>
			<description>[译] Go语言inline内联的策略与限制</description>
			<content type="html"><![CDATA[<p><a href="https://www.pengrl.com/p/20028/">[译] Go语言inline内联的策略与限制</a></p>
]]></content>
		</item>
		
	</channel>
</rss>
