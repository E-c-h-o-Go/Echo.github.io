<!DOCTYPE html>
<html lang="zh-cn">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<meta name="theme-color" content="#EAEAEA">
	<meta name="msapplication-TileColor" content="#EAEAEA">
<meta itemprop="name" content="「Golang」for range 使用方法及避坑指南">
<meta itemprop="description" content="[TOC]
前言 循坏控制结构是一种在各种编程语言中常用的程序控制结构，其与顺序控制结构、选择控制结构组成了程序的控制结构，程序控制结构是指以某种顺序执行的一系列动作，用于解决某个问题。理论和实践证明，无论多复杂的算法均可通过顺序、选择、循环3种基本控制结构构造出来。
在Go中，提供了两种循环控制结构for和goto，但是后者不推荐使用（原因请查看艾兹格·迪杰斯特拉（Edsger Wybe Dijkstra）在1968年的一篇名称为《GOTO语句有害论》的论文），但是就作者而言goto在某些业务情况下，是很好用的，所以也不需要完全就反对他。
 本文代码基于Go 1.16版本，不同版本如有差异请见谅
 万能的for循环 在Go中，与c语言（及大部分语言）不同的是，去掉了while,do..while 循环，将其完全简化为for，虽然这样看起来是缺少了很多功能，但是while,do..while 等功能完全可以通过for来实现 。
接下来，通过几个代码来展示出，for循环，如何实现while,do..while 的相关逻辑。
func main() { N := 10 for i := 0; i &lt; N; i&#43;&#43; { // TODO 	} for { /* * while true{ *	// TODO *	} * */ } for N &gt; 10 { /* * while N&gt;10 { *	// TODO *	} * */ } for { // TODO 	// do{ 	// TODO 	// }while(N&gt;10)  if N &lt;= 10 { break } } } 代码有些粗糙，望大家见谅，可以看得出来，一个for就可以完成while,do.">
<meta itemprop="datePublished" content="2021-03-03T00:00:00+00:00" />
<meta itemprop="dateModified" content="2021-03-03T00:00:00+00:00" />
<meta itemprop="wordCount" content="1739">



<meta itemprop="keywords" content="Golang," />
<meta property="og:title" content="「Golang」for range 使用方法及避坑指南" />
<meta property="og:description" content="[TOC]
前言 循坏控制结构是一种在各种编程语言中常用的程序控制结构，其与顺序控制结构、选择控制结构组成了程序的控制结构，程序控制结构是指以某种顺序执行的一系列动作，用于解决某个问题。理论和实践证明，无论多复杂的算法均可通过顺序、选择、循环3种基本控制结构构造出来。
在Go中，提供了两种循环控制结构for和goto，但是后者不推荐使用（原因请查看艾兹格·迪杰斯特拉（Edsger Wybe Dijkstra）在1968年的一篇名称为《GOTO语句有害论》的论文），但是就作者而言goto在某些业务情况下，是很好用的，所以也不需要完全就反对他。
 本文代码基于Go 1.16版本，不同版本如有差异请见谅
 万能的for循环 在Go中，与c语言（及大部分语言）不同的是，去掉了while,do..while 循环，将其完全简化为for，虽然这样看起来是缺少了很多功能，但是while,do..while 等功能完全可以通过for来实现 。
接下来，通过几个代码来展示出，for循环，如何实现while,do..while 的相关逻辑。
func main() { N := 10 for i := 0; i &lt; N; i&#43;&#43; { // TODO 	} for { /* * while true{ *	// TODO *	} * */ } for N &gt; 10 { /* * while N&gt;10 { *	// TODO *	} * */ } for { // TODO 	// do{ 	// TODO 	// }while(N&gt;10)  if N &lt;= 10 { break } } } 代码有些粗糙，望大家见谅，可以看得出来，一个for就可以完成while,do." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://echoblog.cc/posts/golangfor-range-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E5%8F%8A%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97/" />
<meta property="article:published_time" content="2021-03-03T00:00:00+00:00" />
<meta property="article:modified_time" content="2021-03-03T00:00:00+00:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="「Golang」for range 使用方法及避坑指南"/>
<meta name="twitter:description" content="[TOC]
前言 循坏控制结构是一种在各种编程语言中常用的程序控制结构，其与顺序控制结构、选择控制结构组成了程序的控制结构，程序控制结构是指以某种顺序执行的一系列动作，用于解决某个问题。理论和实践证明，无论多复杂的算法均可通过顺序、选择、循环3种基本控制结构构造出来。
在Go中，提供了两种循环控制结构for和goto，但是后者不推荐使用（原因请查看艾兹格·迪杰斯特拉（Edsger Wybe Dijkstra）在1968年的一篇名称为《GOTO语句有害论》的论文），但是就作者而言goto在某些业务情况下，是很好用的，所以也不需要完全就反对他。
 本文代码基于Go 1.16版本，不同版本如有差异请见谅
 万能的for循环 在Go中，与c语言（及大部分语言）不同的是，去掉了while,do..while 循环，将其完全简化为for，虽然这样看起来是缺少了很多功能，但是while,do..while 等功能完全可以通过for来实现 。
接下来，通过几个代码来展示出，for循环，如何实现while,do..while 的相关逻辑。
func main() { N := 10 for i := 0; i &lt; N; i&#43;&#43; { // TODO 	} for { /* * while true{ *	// TODO *	} * */ } for N &gt; 10 { /* * while N&gt;10 { *	// TODO *	} * */ } for { // TODO 	// do{ 	// TODO 	// }while(N&gt;10)  if N &lt;= 10 { break } } } 代码有些粗糙，望大家见谅，可以看得出来，一个for就可以完成while,do."/>

	<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
	<link rel="manifest" href="/site.webmanifest">
	<link rel="mask-icon" href="/safari-pinned-tab.svg" color="">
	<link rel="shortcut icon" href="/favicon.ico">

	<title>「Golang」for range 使用方法及避坑指南</title>
	<link rel="stylesheet" href="http://echoblog.cc/css/style.min.eac77496566fd7d5768fd650ddb0b2b181ca6a2d7c5fdd6fe6b8ba4bf47e566f.css" integrity="sha256-6sd0llZv19V2j9ZQ3bCysYHKai18X91v5ri6S/R+Vm8=" crossorigin="anonymous">
	
</head>

<body id="page">
	
	<header id="site-header" class="animated slideInUp">
		<div class="hdr-wrapper section-inner">
			<div class="hdr-left">
				<div class="site-branding">
					<a href="http://echoblog.cc/">_Echo_</a>
				</div>
				<nav class="site-nav hide-in-mobile">
					
				<a href="http://echoblog.cc/posts/">Posts</a>
				<a href="http://echoblog.cc/about/">About</a>

				</nav>
			</div>
			<div class="hdr-right hdr-icons">
				<span class="hdr-social hide-in-mobile"><a href="https://blog.csdn.net/qq_37005831?spm=1000.2115.3001.5343" target="_blank" rel="noopener me" title="Csdn"><svg xmlns="http://www.w3.org/2000/svg" class="feather feather-link" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a><a href="https://github.com/E-c-h-o-Go" target="_blank" rel="noopener me" title="Github"><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path></svg></a></span><button id="menu-btn" class="hdr-btn" title=""><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></button>
			</div>
		</div>
	</header>
	<div id="mobile-menu" class="animated fast">
		<ul>
			<li><a href="http://echoblog.cc/posts/">Posts</a></li>
			<li><a href="http://echoblog.cc/about/">About</a></li>
		</ul>
	</div>


	<main class="site-main section-inner animated fadeIn faster">
		<article class="thin">
			<header class="post-header">
				<div class="post-meta"><span>Mar 3, 2021</span></div>
				<h1>「Golang」for range 使用方法及避坑指南</h1>
			</header>
			<div class="content">
				<p>[TOC]</p>
<h2 id="前言">前言<a href="#前言" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p><a href="https://baike.baidu.com/item/%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/22019284#4">循坏控制结构</a>是一种在各种编程语言中常用的程序控制结构，其与顺序控制结构、选择控制结构组成了程序的控制结构，程序控制结构是指以某种顺序执行的一系列动作，用于解决某个问题。理论和实践证明，无论多复杂的算法均可通过顺序、选择、循环3种基本控制结构构造出来。</p>
<p>在Go中，提供了两种循环控制结构<code>for</code>和<code>goto</code>，但是后者不推荐使用（原因请查看<a href="https://zh.wikipedia.org/wiki/%E8%89%BE%E5%85%B9%E6%A0%BC%C2%B7%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89">艾兹格·迪杰斯特拉</a>（Edsger Wybe Dijkstra）在1968年的一篇名称为《GOTO语句有害论》的论文），但是就作者而言<code>goto</code>在某些业务情况下，是很好用的，所以也不需要完全就反对他。</p>
<blockquote>
<p>本文代码基于Go 1.16版本，不同版本如有差异请见谅</p>
</blockquote>
<h2 id="万能的for循环">万能的for循环<a href="#万能的for循环" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>在Go中，与c语言（及大部分语言）不同的是，去掉了<code>while</code>,<code>do..while</code> 循环，将其完全简化为<code>for</code>，虽然这样看起来是缺少了很多功能，但是<code>while</code>,<code>do..while</code>  等功能完全可以通过<code>for</code>来实现 。</p>
<p>接下来，通过几个代码来展示出，<code>for</code>循环，如何实现<code>while</code>,<code>do..while</code> 的相关逻辑。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">N</span> <span class="o">:=</span> <span class="mi">10</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">N</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="c1">// TODO
</span><span class="c1"></span>	<span class="p">}</span>

	<span class="k">for</span> <span class="p">{</span>
		<span class="cm">/*
</span><span class="cm">		*   while true{
</span><span class="cm">		*	  // TODO
</span><span class="cm">		*	}
</span><span class="cm">		*
</span><span class="cm">		*/</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="nx">N</span> <span class="p">&gt;</span> <span class="mi">10</span> <span class="p">{</span>
		<span class="cm">/*
</span><span class="cm">		*   while N&gt;10 {
</span><span class="cm">		*	  // TODO
</span><span class="cm">		*	}
</span><span class="cm">		*
</span><span class="cm">		*/</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="c1">// TODO
</span><span class="c1"></span>		<span class="c1">// do{
</span><span class="c1"></span>		<span class="c1">//  TODO
</span><span class="c1"></span>		<span class="c1">// }while(N&gt;10)
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">N</span> <span class="o">&lt;=</span> <span class="mi">10</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>代码有些粗糙，望大家见谅，可以看得出来，一个<code>for</code>就可以完成<code>while</code>,<code>do..while</code> 所有的功能，从而看出Go的循环控制结构是多么的强大。</p>
<h2 id="嫌for-i--0-i--n-i-麻烦来看看语法糖">嫌<code>for i := 0; i &lt; N; i++ {}</code>麻烦？来看看语法糖<a href="#嫌for-i--0-i--n-i-麻烦来看看语法糖" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>在我们的Go编写的业务逻辑中，常用的循环方式，为经典的三段式循环，即<code>for i := 0; i &lt; N; i++ {}</code>，这种循环可以帮我们方便的遍历数组，切片等数据结构，还可以轻松的进行一定次数循环的操作，那么当我们想要遍历<code>map</code>和<code>channel</code>时，该如何呢？Go给我们提供了一个新关键字<code>range</code>来进行遍历，可以把它理解为一个三段式循环的语法糖，它不光可以遍历<code>map</code>和<code>channel</code>，同样的也可以遍历数组，切片等数据结构，但是与传统循环不同的是，他不可以进行普通的次数循环，那么接下来我们来看一下其遍历数组，切片，<code>map</code>和<code>channel</code>的相关操作以及所能碰到的坑。</p>
<h3 id="遍历数组和切片">遍历数组和切片<a href="#遍历数组和切片" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>遍历数组和切片的方式都是一样的，因为切片的使用概率要大于数组，所以主要讲的切片的遍历，数组可以与其相同方式进行使用，首先 Show me code！</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">slice</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">}</span>
	<span class="c1">// first 
</span><span class="c1"></span>	<span class="k">for</span> <span class="k">range</span> <span class="nx">slice</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="c1">// second
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">k</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">slice</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">k</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// third
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">slice</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>接下来我们挨个的分析一下first,second,third三个注释下面的三种循环方式的区别以及一些特点：</p>
<ol>
<li>使用first方式遍历数组和切片，因其<code>range</code>前没有接收变量，因此代表此次循环并不在意返回的索引以及数据，只关心循环次数。</li>
<li>second方式遍历数组和切片，因其<code>range</code>前仅有一个接收变量，因此代表此次循环仅关心返回的索引，不关心返回的数据，此代码等同于<code>for k,_ := range slice</code></li>
<li>third方式遍历数组和切片，该方法是<code>range</code>的完全体使用形式，因此代表此次循环及关心返回的索引，也关心返回的数据。</li>
</ol>
<p>三种形式，每种形式都有不同的编译编译器优化后的代码，因为<code>range</code>算是一个语法糖，最终其都会在编译期间优化为传统的三段式循环，那么接下来，来看一下这三种形式的编译期间被转换的代码。</p>
<blockquote>
<p>下面的代码信息全部引用自：go/src/cmd/compile/internal/gc/range.go</p>
<p>优化后代码引自：https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-for-range/</p>
<p>首先提前说一下下面会出现的所有变量名的含义，该含义全部引用自编译器源代码。</p>
<p>v1,v2 =&gt;代表 range前变量的索引、数据字段即</p>
<p>for k,v:=range slice{}中的k、v</p>
<p>ha  =&gt; 被遍历元素的复制版</p>
<p>for k,v:=range slice {}中 slice的复制品</p>
<p>a =&gt; 可以理解为被遍历元素</p>
<p>for k,v:=range slice {}中 slice的复制品</p>
<p>即 ha 为 a 的复制版</p>
<p>hn =&gt; len(slice) ，即slice的长度</p>
<p>hv1 =&gt; 循环内的循环指针，可以理解为</p>
<p>for i := 0; i &lt; N; i++ {}中的 i</p>
</blockquote>
<h4 id="忽略索引和数据">忽略索引和数据<a href="#忽略索引和数据" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>首先来看<code>range</code>前没有接收变量、此次循环并不在意返回的索引以及数据，只关心循环次数的循环方式，会产生什么样的译编译器优化后的代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">ha</span> <span class="o">:=</span> <span class="nx">a</span>
<span class="nx">hv1</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="nx">hn</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">ha</span><span class="p">)</span>
<span class="nx">v1</span> <span class="o">:=</span> <span class="nx">hv1</span>
<span class="k">for</span> <span class="p">;</span> <span class="nx">hv1</span> <span class="p">&lt;</span> <span class="nx">hn</span><span class="p">;</span> <span class="nx">hv1</span><span class="o">++</span> <span class="p">{</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre></div><p>由上述代码可以看出，在使用<code>range</code>循环的过程中，原数据被拷贝了一份，然后随后的三段式循环过程完全是围绕着这个复制版本进行操作。</p>
<p>忽略索引和数据就已经讲完了，没什么可说的，很简单，但需要注意的是，<code>range</code>循环被编译器优化改变后，是采用原数据的复制版本进行循环操作的，而不是直接使用原数据进行循环操作，因此，对于切片和数组来说，某些可能修改原数据但不会修改复制版本的操作，不会对每次循环的数据产生影响（还没进行测试，理论上是的）。</p>
<h4 id="只关心索引">只关心索引<a href="#只关心索引" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>其次来看一下<code>range</code>前仅有一个接收变量，因此代表此次循环仅关心返回的索引，不关心返回的数据，会产生什么样的编译器优化后的代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">ha</span> <span class="o">:=</span> <span class="nx">a</span>
<span class="nx">hv1</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="nx">hn</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">ha</span><span class="p">)</span>
<span class="nx">v1</span> <span class="o">:=</span> <span class="nx">hv1</span>
<span class="k">for</span> <span class="p">;</span> <span class="nx">hv1</span> <span class="p">&lt;</span> <span class="nx">hn</span><span class="p">;</span> <span class="nx">hv1</span><span class="o">++</span> <span class="p">{</span>
    <span class="nx">v1</span> <span class="p">=</span> <span class="nx">hv1</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre></div><p>由上述代码可以看出，使用了一个变量v1作为接受索引数据的变量，与其对应的是<code>for k := range slice</code>中的k，之所以没有使用hv1直接作为索引变量的原因，个人猜测是怕再循环过程中误修改循环指针的值，即hv1的值，而产生一些不明来源的问题。</p>
<p>从上面可以看出，<code>range</code>的每次循环都是针对一个变量进行循环的赋值，而不是每次循环重新申请内存空间，此处是一个很常见的出现面试题以及出现坑的地方，具体的内容一会会进行详解。</p>
<h4 id="关心返回的索引和数据">关心返回的索引和数据<a href="#关心返回的索引和数据" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>最后来看一下<code>range</code>的完全体使用形式，此次循环及关心返回的索引，也关心返回的数据。因此其代码相对上一个也更复杂，接下来看一下会产生什么样的译编译器优化后的代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">ha</span> <span class="o">:=</span> <span class="nx">a</span>
<span class="nx">hv1</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="nx">hn</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">ha</span><span class="p">)</span>
<span class="nx">v1</span> <span class="o">:=</span> <span class="nx">hv1</span>
<span class="nx">v2</span> <span class="o">:=</span> <span class="kc">nil</span>
<span class="k">for</span> <span class="p">;</span> <span class="nx">hv1</span> <span class="p">&lt;</span> <span class="nx">hn</span><span class="p">;</span> <span class="nx">hv1</span><span class="o">++</span> <span class="p">{</span>
    <span class="nx">tmp</span> <span class="o">:=</span> <span class="nx">ha</span><span class="p">[</span><span class="nx">hv1</span><span class="p">]</span>
    <span class="nx">v1</span><span class="p">,</span> <span class="nx">v2</span> <span class="p">=</span> <span class="nx">hv1</span><span class="p">,</span> <span class="nx">tmp</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre></div><p>上述代码可见，v2是数据对应的变量，与其对应的是<code>for k，v:= range slice</code>中的v，v1则对应的是k，跟只关心索引的循环一样，每次循环都是针对一个变量进行循环的赋值，而不是每次循环重新申请内存空间。但是在循环中，出现的<code>tmp</code>变量是循环申请的，这是为什么？我个人理解是为了防止切片的元素类型是个指针，如果是个指针的话，直接赋值给v2，随后如果用户在循环过程中对其进行修改就会影响到原切片的复制版本的底层数据，这样是不好的行为（个人猜测，如果有更好的解释可以留言告知于我，在此表示感谢）。</p>
<h3 id="遍历字符串">遍历字符串<a href="#遍历字符串" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>我们还可以使用<code>range</code>来遍历字符串，使用方式与数组和切片相同，但是有一个地方需要拿出来讲一下，例子代码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">str</span><span class="o">:=</span> <span class="s">&#34;GopherEcho这是我的公众号&#34;</span>
	<span class="k">for</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">str</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Print</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="s">&#34;:&#34;</span><span class="p">,</span> <span class="nb">string</span><span class="p">(</span><span class="nx">v</span><span class="p">),</span> <span class="s">&#34;  &#34;</span><span class="p">)</span>
	<span class="p">}</span>
  <span class="c1">// out:
</span><span class="c1"></span>  <span class="c1">// 0:G  1:o  2:p  3:h  4:e  5:r  6:E  7:c  8:h  9:o  10:这  13:是  16:我  19:的  22:公  25:众  28:号  
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>在k&lt;10之前输出都很正常，为什么当k==10的时候每次间隔都为3了呢？这需要我们仍然从编译器优化后的代码的代码来看起，遍历字符串的时候，编译器依旧会将<code>range</code>修改为普通的三段式遍历形式，那么其被修改成什么了呢？接下来看代码：</p>
<blockquote>
<p>下列代码摘自：go/src/cmd/compile/internal/gc/range.go 362-375行</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">	<span class="nx">ha</span> <span class="o">:=</span> <span class="nx">a</span>
	<span class="k">for</span> <span class="nx">hv1</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">hv1</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">ha</span><span class="p">);</span> <span class="p">{</span>
		<span class="nx">hv1t</span> <span class="o">:=</span> <span class="nx">hv1</span>
		<span class="nx">hv2</span> <span class="o">:=</span> <span class="nb">rune</span><span class="p">(</span><span class="nx">ha</span><span class="p">[</span><span class="nx">hv1</span><span class="p">])</span>
		<span class="k">if</span> <span class="nx">hv2</span> <span class="p">&lt;</span> <span class="nx">utf8</span><span class="p">.</span><span class="nx">RuneSelf</span> <span class="p">{</span>
			<span class="nx">hv1</span><span class="o">++</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">hv2</span><span class="p">,</span> <span class="nx">hv1</span> <span class="p">=</span> <span class="nf">decoderune</span><span class="p">(</span><span class="nx">ha</span><span class="p">,</span> <span class="nx">hv1</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">v1</span><span class="p">,</span> <span class="nx">v2</span> <span class="p">=</span> <span class="nx">hv1t</span><span class="p">,</span> <span class="nx">hv2</span>
 	<span class="c1">//	todo 
</span><span class="c1"></span>  <span class="p">}</span>
</code></pre></div><p>接下来我来解释一下这段代码，首先仍然和遍历数组和切片一样，会对原对象进行一次拷贝，接下来开始使用传统三段式遍历方式进行遍历，接下来看第4行，其把当前遍历到的字节（字符串底层类似为byte数组）转换为rune类型，然后判断该rune类型是否为utf8码点，如果第5行判断为true，则代表当前的rune是一个ASCII字符，此时索引仅+1即可，如果为false，需要将其转换为对应长度的rune字符并且对应索引也会随之增加，<code>decoderune(ha, hv1)</code>这个函数，在go/src/runtime/utf8.go的第60行，感兴趣的可以去看看，在此就不做赘述了，随后，赋值给v1,v1即<code>for k, v := range str </code>的k和v。至此，字符串的遍历也讲完了，没啥可说的主要就是针对utf8码点进行了索引递增，每个中文字符占用3个byte长度。</p>
<blockquote>
<p><code>decoderune</code>函数的功能就是返回 s[k:]开头的非 ASCII 符文和 s 中符文后的索引。其中，s为传入的字符串，k为索引</p>
<p>我截了个该函数的图，大家感兴趣可以看看</p>
<p><img src="/Users/cuiwenbin/Library/Application%20Support/typora-user-images/%E6%88%AA%E5%B1%8F2021-03-01%2022.38.55.png" alt="截屏2021-03-01 22.38.55"></p>
</blockquote>
<h3 id="遍历map">遍历Map<a href="#遍历map" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>在之前的文章里面，我进行了Map的源代码的解析，深入的解析了针对Map的读写以及扩容等源代码，接下来讲解一下通过使用<code>range</code>来遍历Map（说的像别的方式可以遍历一样😠）首先看一下遍历Map的方式：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">m</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span>
		<span class="mi">1</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
		<span class="mi">3</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span>
		<span class="mi">4</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">m</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></div><p>跟字符串啥的使用方式没啥区别，都是那玩意儿，不用太在意，我们主要看的是编译器修改后的代码。</p>
<p>遍历Map跟其他的字符串、数组、切片遍历方式不太一样，虽然也是被还原成三段式循环，但是调用了<code>runtime.mapiterinit</code>和<code>runtime.mapiternext</code>函数,因此我需要连带解析这两个函数的代码，接下来首选看一下，遍历Map的时候，<code>range</code>到底被还原成了神马东西？</p>
<blockquote>
<p>优化后代码引自：https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-for-range/</p>
<p>变量名含义：</p>
<p>hit =&gt; map的迭代器对象</p>
<p>th =&gt; 迭代器的元素类型</p>
<p>t =&gt; 元素类型</p>
<p>key  =&gt; 遍历的map的key</p>
<p>val =&gt; 遍历的map的value</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">ha</span> <span class="o">:=</span> <span class="nx">a</span>
<span class="nx">hit</span> <span class="o">:=</span> <span class="nf">hiter</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">Type</span><span class="p">)</span>
<span class="nx">th</span> <span class="o">:=</span> <span class="nx">hit</span><span class="p">.</span><span class="nx">Type</span>
<span class="nf">mapiterinit</span><span class="p">(</span><span class="nf">typename</span><span class="p">(</span><span class="nx">t</span><span class="p">),</span> <span class="nx">ha</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">hit</span><span class="p">)</span>
<span class="k">for</span> <span class="p">;</span> <span class="nx">hit</span><span class="p">.</span><span class="nx">key</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="nf">mapiternext</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">hit</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// for range m 时 key，val 都没有
</span><span class="c1"></span>    <span class="c1">// 讲道理哦，我是不知道忽略k，v遍历map有啥用
</span><span class="c1"></span>    <span class="nx">key</span> <span class="o">:=</span> <span class="o">*</span><span class="nx">hit</span><span class="p">.</span><span class="nx">key</span> <span class="c1">// for k := range m 时只有他
</span><span class="c1"></span>    <span class="nx">val</span> <span class="o">:=</span> <span class="o">*</span><span class="nx">hit</span><span class="p">.</span><span class="nx">val</span> <span class="c1">// for k,v := range m 时 key val 都有
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>代码如上述展示，讲道理也没啥可说的，依旧是做一个拷贝，通过hiter函数构造一个新的迭代器对象hit，然后初始化一个用于迭代（遍历）Map的迭代器对象，然后进行初始化，然后使用这个迭代器来进行针对Map的遍历操作，接下来直接看重点，看<code>runtime.mapiterinit</code>和<code>runtime.mapiternext</code>这两个鬼东西到底怎么实现的。</p>
<p>我将剔除一些无用代码，如race相关代码</p>
<p>首先看<code>runtime.mapiterinit</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 传入参数是，map的类型，对应的map，以及迭代器的变量
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">mapiterinit</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">it</span> <span class="o">*</span><span class="nx">hiter</span><span class="p">)</span> <span class="p">{</span>
	
	<span class="c1">// 空map你遍历个p啊
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">h</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nx">h</span><span class="p">.</span><span class="nx">count</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	
  <span class="c1">// 10-21行
</span><span class="c1"></span>  <span class="c1">// 就是把要遍历的map里面的一些信息
</span><span class="c1"></span>  <span class="c1">// 赋值给迭代器
</span><span class="c1"></span>	<span class="nx">it</span><span class="p">.</span><span class="nx">t</span> <span class="p">=</span> <span class="nx">t</span>
	<span class="nx">it</span><span class="p">.</span><span class="nx">h</span> <span class="p">=</span> <span class="nx">h</span>
	
 	<span class="nx">it</span><span class="p">.</span><span class="nx">B</span> <span class="p">=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span>
	<span class="nx">it</span><span class="p">.</span><span class="nx">buckets</span> <span class="p">=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span>
	<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">bucket</span><span class="p">.</span><span class="nx">ptrdata</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">h</span><span class="p">.</span><span class="nf">createOverflow</span><span class="p">()</span>
		<span class="nx">it</span><span class="p">.</span><span class="nx">overflow</span> <span class="p">=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">overflow</span>
		<span class="nx">it</span><span class="p">.</span><span class="nx">oldoverflow</span> <span class="p">=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">oldoverflow</span>
	<span class="p">}</span>
	<span class="c1">// 这里要注意了
</span><span class="c1"></span>  <span class="c1">// fastrand() 会随机分配一个哈希值
</span><span class="c1"></span>  <span class="c1">// 迭代会从这个hash值开始
</span><span class="c1"></span>  <span class="c1">// 这也是为什么遍历map的时候是随机结果的原因
</span><span class="c1"></span> 	<span class="nx">r</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nf">fastrand</span><span class="p">())</span>
  <span class="c1">// 如果当前桶大于 31-bucketCntBits 
</span><span class="c1"></span>  <span class="c1">// 那么就让随机出来的hash值
</span><span class="c1"></span>  <span class="c1">// 重新hash 然后做个修改
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span> <span class="p">&gt;</span> <span class="mi">31</span><span class="o">-</span><span class="nx">bucketCntBits</span> <span class="p">{</span>
		<span class="nx">r</span> <span class="o">+=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nf">fastrand</span><span class="p">())</span> <span class="o">&lt;&lt;</span> <span class="mi">31</span>
	<span class="p">}</span>
  <span class="c1">// 根据随机的hash 
</span><span class="c1"></span>  <span class="c1">// 算出第一个遍历的桶
</span><span class="c1"></span>	<span class="nx">it</span><span class="p">.</span><span class="nx">startBucket</span> <span class="p">=</span> <span class="nx">r</span> <span class="o">&amp;</span> <span class="nf">bucketMask</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span>
	<span class="nx">it</span><span class="p">.</span><span class="nx">offset</span> <span class="p">=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">r</span> <span class="o">&gt;&gt;</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span> <span class="o">&amp;</span> <span class="p">(</span><span class="nx">bucketCnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
	<span class="c1">// 当前的迭代桶
</span><span class="c1"></span> 	<span class="nx">it</span><span class="p">.</span><span class="nx">bucket</span> <span class="p">=</span> <span class="nx">it</span><span class="p">.</span><span class="nx">startBucket</span>

  <span class="c1">// 迭代器可以并发初始化
</span><span class="c1"></span>  <span class="c1">// 但是 只有一个迭代器
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">old</span> <span class="o">:=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">flags</span><span class="p">;</span> <span class="nx">old</span><span class="o">&amp;</span><span class="p">(</span><span class="nx">iterator</span><span class="p">|</span><span class="nx">oldIterator</span><span class="p">)</span> <span class="o">!=</span> <span class="nx">iterator</span><span class="p">|</span><span class="nx">oldIterator</span> <span class="p">{</span>
		<span class="nx">atomic</span><span class="p">.</span><span class="nf">Or8</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">h</span><span class="p">.</span><span class="nx">flags</span><span class="p">,</span> <span class="nx">iterator</span><span class="p">|</span><span class="nx">oldIterator</span><span class="p">)</span>
	<span class="p">}</span>
 
	<span class="nf">mapiternext</span><span class="p">(</span><span class="nx">it</span><span class="p">)</span>
<span class="p">}</span>
 
</code></pre></div><p><code>runtime.mapiterinit</code>函数大概就是如上述所说，但是有一点要注意的是，Map遍历的顺序是随机的，并不是按照固定顺序进行遍历，这是因为官方不想让使用者依赖迭代顺序，具体是为什么？官方回复如下：</p>
<blockquote>
<p>Iterating in maps</p>
<p>In Go 1, the order in which elements are visited when iterating over a map using a <code>for</code> <code>range</code> statement is defined to be unpredictable, even if the same loop is run multiple times with the same map. Code should not assume that the elements are visited in any particular order.</p>
<p>This change means that code that depends on iteration order is very likely to break early and be fixed long before it becomes a problem. Just as important, it allows the map implementation to ensure better map balancing even when programs are using range loops to select an element from a map.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">    <span class="nx">m</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="s">&#34;Sunday&#34;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#34;Monday&#34;</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>
    <span class="k">for</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">value</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">m</span> <span class="p">{</span>
        <span class="c1">// This loop should not assume Sunday will be visited first.
</span><span class="c1"></span>        <span class="nf">f</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span>
    <span class="p">}</span>
</code></pre></div><p><em>Updating</em>: This is one change where tools cannot help. Most existing code will be unaffected, but some programs may break or misbehave; we recommend manual checking of all range statements over maps to verify they do not depend on iteration order. There were a few such examples in the standard repository; they have been fixed. Note that it was already incorrect to depend on the iteration order, which was unspecified. This change codifies the unpredictability.</p>
<p>引自：https://golang.org/doc/go1#iteration</p>
</blockquote>
<p>接下来继续讲解<code>runtime.mapiternext</code>函数，这个函数hin长，但是我尽量讲完全。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 传入参数是哪个迭代器
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">mapiternext</span><span class="p">(</span><span class="nx">it</span> <span class="o">*</span><span class="nx">hiter</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 拿出迭代器中保存的那个map
</span><span class="c1"></span>	<span class="nx">h</span> <span class="o">:=</span> <span class="nx">it</span><span class="p">.</span><span class="nx">h</span>

  <span class="c1">// 判断是否处于并发读写状态
</span><span class="c1"></span>  <span class="c1">// 如果处于
</span><span class="c1"></span>  <span class="c1">// boom！
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">flags</span><span class="o">&amp;</span><span class="nx">hashWriting</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;concurrent map iteration and map write&#34;</span><span class="p">)</span>
	<span class="p">}</span>
  <span class="c1">// map的类型
</span><span class="c1"></span>	<span class="nx">t</span> <span class="o">:=</span> <span class="nx">it</span><span class="p">.</span><span class="nx">t</span>
	<span class="c1">// 迭代器初始化的时候选择的哪个桶
</span><span class="c1"></span>	<span class="nx">bucket</span> <span class="o">:=</span> <span class="nx">it</span><span class="p">.</span><span class="nx">bucket</span>
  <span class="c1">// 当前遍历到的桶
</span><span class="c1"></span>	<span class="nx">b</span> <span class="o">:=</span> <span class="nx">it</span><span class="p">.</span><span class="nx">bptr</span>
  <span class="c1">// 应该是遍历到哪个tophash了的索引
</span><span class="c1"></span>	<span class="nx">i</span> <span class="o">:=</span> <span class="nx">it</span><span class="p">.</span><span class="nx">i</span>
  <span class="c1">// 没搞懂
</span><span class="c1"></span>	<span class="nx">checkBucket</span> <span class="o">:=</span> <span class="nx">it</span><span class="p">.</span><span class="nx">checkBucket</span>

<span class="nx">next</span><span class="p">:</span>
  <span class="c1">// 如果当前遍历的桶是个nil
</span><span class="c1"></span>  <span class="c1">// 就找看看有没有能遍历的桶
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">b</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="c1">// 这代表循环结束绕回了最开始迭代的哪个桶
</span><span class="c1"></span>    <span class="c1">// 结束了 返回
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">bucket</span> <span class="o">==</span> <span class="nx">it</span><span class="p">.</span><span class="nx">startBucket</span> <span class="o">&amp;&amp;</span> <span class="nx">it</span><span class="p">.</span><span class="nx">wrapped</span> <span class="p">{</span>
			<span class="c1">// end of iteration
</span><span class="c1"></span>			<span class="nx">it</span><span class="p">.</span><span class="nx">key</span> <span class="p">=</span> <span class="kc">nil</span>
			<span class="nx">it</span><span class="p">.</span><span class="nx">elem</span> <span class="p">=</span> <span class="kc">nil</span>
			<span class="k">return</span>
		<span class="p">}</span>
    <span class="c1">// 如果当前map正在处于搬迁状态
</span><span class="c1"></span>    <span class="c1">// 并且 还没搬迁完
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nf">growing</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nx">it</span><span class="p">.</span><span class="nx">B</span> <span class="o">==</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span> <span class="p">{</span>
			 <span class="c1">// 那么就从旧桶遍历
</span><span class="c1"></span>			<span class="nx">oldbucket</span> <span class="o">:=</span> <span class="nx">bucket</span> <span class="o">&amp;</span> <span class="nx">it</span><span class="p">.</span><span class="nx">h</span><span class="p">.</span><span class="nf">oldbucketmask</span><span class="p">()</span>
      <span class="c1">// 算出来要遍历的旧桶的偏移位置
</span><span class="c1"></span>			<span class="nx">b</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">oldbuckets</span><span class="p">,</span> <span class="nx">oldbucket</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span>
      <span class="c1">// 看看这桶需不需要遍历
</span><span class="c1"></span>      <span class="c1">// 就是看看桶里有没有玩意儿
</span><span class="c1"></span>			<span class="k">if</span> <span class="p">!</span><span class="nf">evacuated</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
				<span class="nx">checkBucket</span> <span class="p">=</span> <span class="nx">bucket</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="nx">b</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">it</span><span class="p">.</span><span class="nx">buckets</span><span class="p">,</span> <span class="nx">bucket</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span>
				<span class="nx">checkBucket</span> <span class="p">=</span> <span class="nx">noCheck</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="c1">// 如果不处于增长状态 那就遍历正常的桶
</span><span class="c1"></span>			<span class="nx">b</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">it</span><span class="p">.</span><span class="nx">buckets</span><span class="p">,</span> <span class="nx">bucket</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span>
			<span class="nx">checkBucket</span> <span class="p">=</span> <span class="nx">noCheck</span>
		<span class="p">}</span>
    <span class="c1">// 看看是否循环一圈了
</span><span class="c1"></span>		<span class="nx">bucket</span><span class="o">++</span>
		<span class="k">if</span> <span class="nx">bucket</span> <span class="o">==</span> <span class="nf">bucketShift</span><span class="p">(</span><span class="nx">it</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">bucket</span> <span class="p">=</span> <span class="mi">0</span>
			<span class="nx">it</span><span class="p">.</span><span class="nx">wrapped</span> <span class="p">=</span> <span class="kc">true</span>
		<span class="p">}</span>
		<span class="nx">i</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>
  <span class="c1">// 找到了可以遍历的桶了
</span><span class="c1"></span>  <span class="c1">// 开始遍历这个桶
</span><span class="c1"></span>	<span class="k">for</span> <span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">bucketCnt</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="c1">// 通过tophash看看对应位置有没有存储的数据
</span><span class="c1"></span>		<span class="nx">offi</span> <span class="o">:=</span> <span class="p">(</span><span class="nx">i</span> <span class="o">+</span> <span class="nx">it</span><span class="p">.</span><span class="nx">offset</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="nx">bucketCnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">if</span> <span class="nf">isEmpty</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">offi</span><span class="p">])</span> <span class="o">||</span> <span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">offi</span><span class="p">]</span> <span class="o">==</span> <span class="nx">evacuatedEmpty</span> <span class="p">{</span>
			<span class="k">continue</span>
		<span class="p">}</span>
    <span class="c1">// 位偏移算出key
</span><span class="c1"></span>		<span class="nx">k</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">offi</span><span class="p">)</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">))</span>
		<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">indirectkey</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">k</span> <span class="p">=</span> <span class="o">*</span><span class="p">((</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">k</span><span class="p">))</span>
		<span class="p">}</span>
    <span class="c1">// 位偏移算出value的地址
</span><span class="c1"></span>		<span class="nx">e</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span>
             <span class="nx">dataOffset</span><span class="o">+</span><span class="nx">bucketCnt</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">)</span><span class="o">+</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">offi</span><span class="p">)</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">elemsize</span><span class="p">))</span>
    
    <span class="c1">// 下面这个判断与是否处于搬迁状态有关
</span><span class="c1"></span>    <span class="c1">// 如果在搬迁期间就用mapaccessK(t, h, k)取出key，value
</span><span class="c1"></span>    <span class="c1">// 否则直接操作内存取key和value
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">checkBucket</span> <span class="o">!=</span> <span class="nx">noCheck</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">h</span><span class="p">.</span><span class="nf">sameSizeGrow</span><span class="p">()</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">reflexivekey</span><span class="p">()</span> <span class="o">||</span> <span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">.</span><span class="nf">equal</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
				<span class="nx">hash</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">hasher</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">hash0</span><span class="p">))</span>
				<span class="k">if</span> <span class="nx">hash</span><span class="o">&amp;</span><span class="nf">bucketMask</span><span class="p">(</span><span class="nx">it</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="o">!=</span> <span class="nx">checkBucket</span> <span class="p">{</span>
					<span class="k">continue</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">if</span> <span class="nx">checkBucket</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="nx">it</span><span class="p">.</span><span class="nx">B</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">offi</span><span class="p">]</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">continue</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">offi</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">evacuatedX</span> <span class="o">&amp;&amp;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">offi</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">evacuatedY</span><span class="p">)</span> <span class="o">||</span>
			<span class="p">!(</span><span class="nx">t</span><span class="p">.</span><span class="nf">reflexivekey</span><span class="p">()</span> <span class="o">||</span> <span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">.</span><span class="nf">equal</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">k</span><span class="p">))</span> <span class="p">{</span>
			<span class="nx">it</span><span class="p">.</span><span class="nx">key</span> <span class="p">=</span> <span class="nx">k</span>
			<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">indirectelem</span><span class="p">()</span> <span class="p">{</span>
				<span class="nx">e</span> <span class="p">=</span> <span class="o">*</span><span class="p">((</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">e</span><span class="p">))</span>
			<span class="p">}</span>
			<span class="nx">it</span><span class="p">.</span><span class="nx">elem</span> <span class="p">=</span> <span class="nx">e</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">rk</span><span class="p">,</span> <span class="nx">re</span> <span class="o">:=</span> <span class="nf">mapaccessK</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">rk</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="k">continue</span> 
			<span class="p">}</span>
			<span class="nx">it</span><span class="p">.</span><span class="nx">key</span> <span class="p">=</span> <span class="nx">rk</span>
			<span class="nx">it</span><span class="p">.</span><span class="nx">elem</span> <span class="p">=</span> <span class="nx">re</span>
		<span class="p">}</span>
		<span class="nx">it</span><span class="p">.</span><span class="nx">bucket</span> <span class="p">=</span> <span class="nx">bucket</span>
		<span class="k">if</span> <span class="nx">it</span><span class="p">.</span><span class="nx">bptr</span> <span class="o">!=</span> <span class="nx">b</span> <span class="p">{</span>  
			<span class="nx">it</span><span class="p">.</span><span class="nx">bptr</span> <span class="p">=</span> <span class="nx">b</span>
		<span class="p">}</span>
		<span class="nx">it</span><span class="p">.</span><span class="nx">i</span> <span class="p">=</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span>
		<span class="nx">it</span><span class="p">.</span><span class="nx">checkBucket</span> <span class="p">=</span> <span class="nx">checkBucket</span>
		<span class="k">return</span>
	<span class="p">}</span>
  <span class="c1">// 遍历溢出桶，如果没有则b == nil 
</span><span class="c1"></span>  <span class="c1">// 进入找桶逻辑
</span><span class="c1"></span>	<span class="nx">b</span> <span class="p">=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">overflow</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
	<span class="nx">i</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="k">goto</span> <span class="nx">next</span>
<span class="p">}</span>

</code></pre></div><p><code>runtime.mapiternext</code>函数代码讲完了，可能有点糙糙的，但是大概的的意思都差不多，那么总结一下：</p>
<ol>
<li>根据当前迭代器获取到对应的Map，然后根据当前桶是否处于搬迁状态来决定是遍历常规的桶还是遍历旧桶。</li>
<li>如果当前处于搬迁状态，那么在遍历对应桶的内部的时候会采用mapaccessK(t, h, k)去获取对应的key，value的地址。</li>
<li>如果不处于搬迁状态，则按照普通的位偏移模式去对key和对应的value进行位偏移取址。</li>
</ol>
<h3 id="遍历channel">遍历Channel<a href="#遍历channel" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>现在就剩下最后一个东西的遍历了，那就是Channel（终于快写完了），Channel的遍历方式其实和Map差不多，但是有一个问题是需要各位注意的，Show me code！</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">channel</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">channel</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><blockquote>
<p>（不要在意这个代码会死锁就是个演示而已）</p>
</blockquote>
<p>遍历Channel与遍历其他的数据结构不同的是，遍历Channel只允许<code>range</code>来前有一个接收变量（废话，channel还能返回索引嘛？），这是一个需要注意的问题。</p>
<p>遍历Channel时，在编译期间也进行了把<code>range</code>转换为传统三段式循环的代码，接下来看一下转换后代码的各个变量的含义，以及转换后的代码：</p>
<blockquote>
<p>优化后代码引自：https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-for-range/</p>
<p>变量名含义：</p>
<p>hb =&gt; 可以理解为在通常接收通道信息时  value ,ok := &lt;-channel 中的ok</p>
<p>hv1 =&gt; 可以理解为在通常接收通道信息时  value ,ok := &lt;-channel 中的value</p>
<p>v1 =&gt;  for v := range channel 中的 v</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">ha</span> <span class="o">:=</span> <span class="nx">a</span>
<span class="nx">hv1</span><span class="p">,</span> <span class="nx">hb</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">ha</span>
<span class="k">for</span> <span class="p">;</span> <span class="nx">hb</span> <span class="o">!=</span> <span class="kc">false</span><span class="p">;</span> <span class="nx">hv1</span><span class="p">,</span> <span class="nx">hb</span> <span class="p">=</span> <span class="o">&lt;-</span><span class="nx">ha</span> <span class="p">{</span>
    <span class="nx">v1</span> <span class="o">:=</span> <span class="nx">hv1</span>
    <span class="nx">hv1</span> <span class="p">=</span> <span class="kc">nil</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre></div><p>上述代码是经过编译器转换成传统三段式循环之后的代码，接下来讲解一下：</p>
<ol>
<li>老规矩，先做一份遍历对象的拷贝。</li>
<li>使用ok-idom 方式进行Channel数据的接收，此处有可能会阻塞，如果Channel被关闭，则hb==false</li>
<li>然后进入循环，把拿到的值拷贝给v1，然后hv1置空，是为了一个提出的issus，在源码中写了注释：</li>
</ol>
<blockquote>
<p>Zero hv1. This prevents hv1 from being the sole, inaccessible reference to an otherwise GC-able value during the next channel receive. 	See issue 15281</p>
</blockquote>
<ol start="4">
<li>然后从2重新开始循环。</li>
</ol>
<h3 id="坑有坑有大坑">坑！有坑！有大坑！<a href="#坑有坑有大坑" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>既然<code>range</code>这么Nb，那是否可以经常用呢？我的回答是可以，但是<code>range</code>有一些坑（或者说不是坑只是没正确使用），会导致业务逻辑出现混乱的问题，接下来举几个🌰。</p>
<h4 id="相同的玩意儿">相同的玩意儿？<a href="#相同的玩意儿" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>首先，看代码！</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">slice</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">}</span>

	<span class="nx">slicePtr</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="o">*</span><span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>

	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">slice</span> <span class="p">{</span>
		<span class="nx">slicePtr</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">slicePtr</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">v</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">slicePtr</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Print</span><span class="p">(</span><span class="o">*</span><span class="nx">v</span><span class="p">,</span> <span class="s">&#34;,&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// out :
</span><span class="c1"></span>	<span class="c1">// 6,6,6,6,6,6,
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>上述代码中，我创建了一个int切片slice，然后又创建了一个*int切片slicePtr，通过使用<code>range</code>来循环slice添加到slicePtr，此时，添加完毕后，我们想要的输出应该是 1,2,3,4,5,6, 但是实际输出却是6,6,6,6,6,6,</p>
<p>这是为什么呢？可以回到 <a href="###%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87">遍历数组和切片</a>一节中看到，在<code>range</code>被修改为传统三段式循环时，在进入循环之前就会创建v1 := hv1，v2 := nil变量，并且在每次循环中针对这两个变量只是产生了覆盖而不是重新申请内存，因此，在<code>range</code>前的两个变量在循环过程中的地址都是相同的（可以跑一下下面的代码去试试，看看输出）,因此，上面代码的问题在于，每次循环slicePtr取引用的都是相同地址，在循环后，这个地址存的是slice的最后一个值，即6，所以在输出slicePtr的时候，产生的输出均为6。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">slice</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">}</span>

	<span class="k">for</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">slice</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">k</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">v</span><span class="p">)</span>
	<span class="p">}</span>
 
<span class="p">}</span>
</code></pre></div><p>那么如何避免这个问题呢？使用一个中间变量即可，正确代码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
   <span class="nx">slice</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">}</span>

   <span class="nx">slicePtr</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="o">*</span><span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>

   <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">slice</span> <span class="p">{</span>
      <span class="nx">temp</span> <span class="o">:=</span> <span class="nx">v</span>
      <span class="nx">slicePtr</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">slicePtr</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">temp</span><span class="p">)</span>
   <span class="p">}</span>
   <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">slicePtr</span> <span class="p">{</span>
      <span class="nx">fmt</span><span class="p">.</span><span class="nf">Print</span><span class="p">(</span><span class="o">*</span><span class="nx">v</span><span class="p">,</span> <span class="s">&#34;,&#34;</span><span class="p">)</span>
   <span class="p">}</span>
   <span class="c1">// out :
</span><span class="c1"></span>   <span class="c1">// 1,2,3,4,5,6,
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><h4 id="到底能循环多久">到底能循环多久？<a href="#到底能循环多久" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>首先看一下代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
   <span class="nx">slice</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">}</span>
   <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">slice</span> <span class="p">{</span>
      <span class="nx">slice</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">slice</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
   <span class="p">}</span>
   <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">slice</span><span class="p">)</span>
  <span class="c1">// out:
</span><span class="c1"></span>  <span class="c1">// [1 2 3 4 5 6 1 2 3 4 5 6]
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>上面的代码，在循环中每次循环进行append，按照常理来说这个循环会一直持续下去，但是为什么只添加了一遍就不在循环了呢？还可以回到 <a href="###%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87">遍历数组和切片</a>一节中看到，在<code>range</code>被修改为传统三段式循环时，在进入循环之前会对原数据产生一次拷贝，并且使用这个拷贝判断循环的最大长度hn，因此，只添加了一次循环的长度就结束了循环。</p>
<h3 id="性能">性能？<a href="#性能" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>既然<code>range</code>这么好用，那么是否有一些其他问题呢？比如说性能问题？，接下来作者就进行三种测试来分别看一下传统的三段式循环和<code>range</code>的性能差异</p>
<blockquote>
<p>测试环境采用：</p>
<p>Go 1.16版本</p>
<p>Goland 2021.1 EAP版本</p>
<p>goos: darwin
goarch: amd64
cpu: Intel(R) Core(TM) i5-1038NG7 CPU @ 2.00GHz</p>
<p>memory：16GB</p>
</blockquote>
<h4 id="遍历切片数组的性能">遍历切片/数组的性能<a href="#遍历切片数组的性能" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">TestArray</span> <span class="p">[</span><span class="mi">100000</span><span class="p">]</span><span class="kt">int</span>
<span class="kd">var</span> <span class="nx">TestSlice</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">100000</span><span class="p">,</span> <span class="mi">100000</span><span class="p">)</span>

<span class="kd">func</span> <span class="nf">BenchmarkArrayRange</span><span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">TestArray</span> <span class="p">{</span>
			<span class="c1">// io.Discard 抛弃输出
</span><span class="c1"></span>			<span class="nx">_</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprintln</span><span class="p">(</span><span class="nx">io</span><span class="p">.</span><span class="nx">Discard</span><span class="p">,</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">BenchmarkArrayFor</span><span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">TestArray</span><span class="p">);</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
			<span class="c1">// io.Discard 抛弃输出
</span><span class="c1"></span>			<span class="nx">_</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprintln</span><span class="p">(</span><span class="nx">io</span><span class="p">.</span><span class="nx">Discard</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">TestArray</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">BenchmarkSliceRange</span><span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">TestSlice</span> <span class="p">{</span>
			<span class="c1">// io.Discard 抛弃输出
</span><span class="c1"></span>			<span class="nx">_</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprintln</span><span class="p">(</span><span class="nx">io</span><span class="p">.</span><span class="nx">Discard</span><span class="p">,</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">BenchmarkSliceFor</span><span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">TestSlice</span><span class="p">);</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
			<span class="c1">// io.Discard 抛弃输出
</span><span class="c1"></span>			<span class="nx">_</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprintln</span><span class="p">(</span><span class="nx">io</span><span class="p">.</span><span class="nx">Discard</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">TestSlice</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></div><p>遍历方式采用gotest的基准测试方式，测试在数组/切片长度为100000的情况下，传统的三段式循环和<code>range</code>的性能差异（结果出来的时候我很惊讶为啥会这么慢）</p>
<blockquote>
<p>BenchmarkArrayRange
BenchmarkArrayRange-8   	     132	   8902794 ns/op
BenchmarkArrayFor
BenchmarkArrayFor-8     	     183	   6219940 ns/op</p>
<p>BenchmarkSliceRange
BenchmarkSliceRange-8   	     136	   8848273 ns/op
BenchmarkSliceFor
BenchmarkSliceFor-8     	     182	   6483446 ns/op</p>
</blockquote>
<p>从上述测试结果可以看出 采用<code>range</code>遍历数组/切片的时候相比采用普通三段式方式遍历，性能大概差了30%左右，这种性能差异在数据很大的遍历中影响还是很大的，个人理解还是因为在<code>range</code>时会拷贝原数据，对于原数据的拷贝是一个很耗性能的操作，因此会出现30%的性能损耗。</p>
<h4 id="遍历map-1">遍历Map<a href="#遍历map-1" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>使用Map的时候，想遍历，怕是只有使用<code>range</code>了，也没啥别的办法，那么就只测试一下Map在<code>range</code>下的性能表现：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">TestMap</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">100000</span><span class="p">)</span>

<span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
   <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">100000</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
   <span class="nx">reRand</span><span class="p">:</span>
      <span class="nx">key</span><span class="p">,</span> <span class="nx">value</span> <span class="o">:=</span> <span class="nx">rand</span><span class="p">.</span><span class="nf">Int</span><span class="p">(),</span> <span class="nx">rand</span><span class="p">.</span><span class="nf">Int</span><span class="p">()</span>
      <span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">TestMap</span><span class="p">[</span><span class="nx">key</span><span class="p">];</span> <span class="nx">ok</span> <span class="p">{</span>
         <span class="k">goto</span> <span class="nx">reRand</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
         <span class="nx">TestMap</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="nx">value</span>
      <span class="p">}</span>
   <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">BenchmarkRange</span><span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
      <span class="k">for</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">TestMap</span> <span class="p">{</span>
         <span class="nx">_</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprintln</span><span class="p">(</span><span class="nx">io</span><span class="p">.</span><span class="nx">Discard</span><span class="p">,</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
      <span class="p">}</span>
   <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>同样是100000级别的数据量，测试启动时随机分配，接下来看一下性能表现：</p>
<blockquote>
<p>BenchmarkRange
BenchmarkRange-8   	      62	  17623282 ns/op</p>
</blockquote>
<p>照比遍历切片要慢了接近70%的性能，不过这也没办法，毕竟除了拿<code>range</code>也没啥别的办法去遍历Map。</p>
<h2 id="总结">总结<a href="#总结" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>关于<code>range</code>的一些用法，坑，和性能也差不多讲完了，大概就这些，可能我也没想到什么其他的了。总之希望可以给各位帮助。</p>

			</div>
			<hr class="post-end">
			<footer class="post-info">
				<p>
					<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line></svg><span class="tag"><a href="http://echoblog.cc/tags/golang">Golang</a></span>
				</p>
				<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg></p>
				<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>2021-03-03 08:00 &#43;0800</p>
			</footer>
		</article>
		<div class="post-nav thin">
			<a class="prev-post" href="http://echoblog.cc/posts/golangmap%E8%A7%A3%E6%9E%90/">
				<span class="post-nav-label">&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg></span><br><span>「Golang」 Map源码解析</span>
			</a>
		</div>
		<div id="comments" class="thin" >
			<style>
				textarea{
					color: #0a0a0a;
				}
			</style>
<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
			<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
			<div id="gitalk-container"></div>
			<script src="https://cdn.bootcss.com/js-sha1/0.6.0/sha1.js"></script>
			<script>
				const gitalk = new Gitalk({
					clientID: '995328ca3d420ab499bc',
					clientSecret: '7efc85b29c231f5ec361d9f5b44c3802cc17cb58',
					repo: 'Echo.github.io',
					owner: 'E-c-h-o-Go',
					admin: ['E-c-h-o-Go'],
					id: sha1(location.pathname),      
					distractionFreeMode: false  
				})

				gitalk.render('gitalk-container')

			</script>
		</div>
	</main>


	<footer id="site-footer" class="section-inner thin animated fadeIn faster">
		<p>&copy; 2021 <a href="http://echoblog.cc/">_Echo_</a> &#183; <a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0</a></p>
		<p>
			Made with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> &#183; Theme <a href="https://github.com/Track3/hermit" target="_blank" rel="noopener">Hermit</a> &#183; <a href="http://echoblog.cc/posts/index.xml" target="_blank" title="rss"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a>
		</p>
	</footer>



	<script src="http://echoblog.cc/js/bundle.min.4a9a0ac3d2217822c7865b4161e6c2a71de1d70492264337755427898dd718f6.js" integrity="sha256-SpoKw9IheCLHhltBYebCpx3h1wSSJkM3dVQniY3XGPY=" crossorigin="anonymous"></script>
	

</body>

</html>
