<!DOCTYPE html>
<html lang="zh-cn">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<meta name="theme-color" content="#EAEAEA">
	<meta name="msapplication-TileColor" content="#EAEAEA">
<meta itemprop="name" content="「Golang」Slice源码讲解">
<meta itemprop="description" content="前言  ​ 在golang中有很多的数据结构是很常用的数据结构，比如array，slice，map等，其中最为常用的就是array和slice还有map了，理论上来讲array和slice在数据结构上是一种结构，都是顺序结构，但是由于array的固定长度特性，在有些时候对于需要动态的长度的使用情况很不友好，此时就需要利用slice进行对固定长度数组的代替
 什么是Slice  官方解释如下：
​	Slices wrap arrays to give a more general, powerful, and convenient interface to sequences of data. Except for items with explicit dimension such as transformation matrices, most array programming in Go is done with slices rather than simple arrays.
大概意思如下：
​	Slice是一个经过包装的array，其可为数据序列提供更通用，更强大和更方便的接口。 除了具有明确维数的项（例如转换矩阵）外，Go中的大多数数组编程都是使用切片而不是简单数组完成的。
 ​	切片个人认为有点像c&#43;&#43;标准库中的vector，只不过是底层的实现方式可能有些许不同（不太了解c&#43;&#43;，如果有大佬知道vector的底层实现的话，可以解惑一下），slice是一个把go数组进行了包装的一个结构体，但是这个结构体只是在编译等其他层面能看到，在我们使用过程中只需要像定义数组那样定义就可以在编译期间被转换为slice结构体。接下来我来解析一下slice的相关结构体源代码以及操作源代码。
代码解析  本篇文章所有代码基于Go1.15&#43;版本编写
 slice的结构体 // slice 结构体，这个结构体会在编译期间构建 // 如果想在运行期间使用的话可以使用其对应的reflect结构体 // 即reflect.SliceHeader type slice struct { // 一个指向底层数组的指针 	array unsafe.">
<meta itemprop="datePublished" content="2021-01-04T00:00:00+00:00" />
<meta itemprop="dateModified" content="2021-01-04T00:00:00+00:00" />
<meta itemprop="wordCount" content="580">



<meta itemprop="keywords" content="Golang," />
<meta property="og:title" content="「Golang」Slice源码讲解" />
<meta property="og:description" content="前言  ​ 在golang中有很多的数据结构是很常用的数据结构，比如array，slice，map等，其中最为常用的就是array和slice还有map了，理论上来讲array和slice在数据结构上是一种结构，都是顺序结构，但是由于array的固定长度特性，在有些时候对于需要动态的长度的使用情况很不友好，此时就需要利用slice进行对固定长度数组的代替
 什么是Slice  官方解释如下：
​	Slices wrap arrays to give a more general, powerful, and convenient interface to sequences of data. Except for items with explicit dimension such as transformation matrices, most array programming in Go is done with slices rather than simple arrays.
大概意思如下：
​	Slice是一个经过包装的array，其可为数据序列提供更通用，更强大和更方便的接口。 除了具有明确维数的项（例如转换矩阵）外，Go中的大多数数组编程都是使用切片而不是简单数组完成的。
 ​	切片个人认为有点像c&#43;&#43;标准库中的vector，只不过是底层的实现方式可能有些许不同（不太了解c&#43;&#43;，如果有大佬知道vector的底层实现的话，可以解惑一下），slice是一个把go数组进行了包装的一个结构体，但是这个结构体只是在编译等其他层面能看到，在我们使用过程中只需要像定义数组那样定义就可以在编译期间被转换为slice结构体。接下来我来解析一下slice的相关结构体源代码以及操作源代码。
代码解析  本篇文章所有代码基于Go1.15&#43;版本编写
 slice的结构体 // slice 结构体，这个结构体会在编译期间构建 // 如果想在运行期间使用的话可以使用其对应的reflect结构体 // 即reflect.SliceHeader type slice struct { // 一个指向底层数组的指针 	array unsafe." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://echoblog.cc/posts/golangslice%E6%BA%90%E7%A0%81%E8%AE%B2%E8%A7%A3/" />
<meta property="article:published_time" content="2021-01-04T00:00:00+00:00" />
<meta property="article:modified_time" content="2021-01-04T00:00:00+00:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="「Golang」Slice源码讲解"/>
<meta name="twitter:description" content="前言  ​ 在golang中有很多的数据结构是很常用的数据结构，比如array，slice，map等，其中最为常用的就是array和slice还有map了，理论上来讲array和slice在数据结构上是一种结构，都是顺序结构，但是由于array的固定长度特性，在有些时候对于需要动态的长度的使用情况很不友好，此时就需要利用slice进行对固定长度数组的代替
 什么是Slice  官方解释如下：
​	Slices wrap arrays to give a more general, powerful, and convenient interface to sequences of data. Except for items with explicit dimension such as transformation matrices, most array programming in Go is done with slices rather than simple arrays.
大概意思如下：
​	Slice是一个经过包装的array，其可为数据序列提供更通用，更强大和更方便的接口。 除了具有明确维数的项（例如转换矩阵）外，Go中的大多数数组编程都是使用切片而不是简单数组完成的。
 ​	切片个人认为有点像c&#43;&#43;标准库中的vector，只不过是底层的实现方式可能有些许不同（不太了解c&#43;&#43;，如果有大佬知道vector的底层实现的话，可以解惑一下），slice是一个把go数组进行了包装的一个结构体，但是这个结构体只是在编译等其他层面能看到，在我们使用过程中只需要像定义数组那样定义就可以在编译期间被转换为slice结构体。接下来我来解析一下slice的相关结构体源代码以及操作源代码。
代码解析  本篇文章所有代码基于Go1.15&#43;版本编写
 slice的结构体 // slice 结构体，这个结构体会在编译期间构建 // 如果想在运行期间使用的话可以使用其对应的reflect结构体 // 即reflect.SliceHeader type slice struct { // 一个指向底层数组的指针 	array unsafe."/>

	<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
	<link rel="manifest" href="/site.webmanifest">
	<link rel="mask-icon" href="/safari-pinned-tab.svg" color="">
	<link rel="shortcut icon" href="/favicon.ico">

	<title>「Golang」Slice源码讲解</title>
	<link rel="stylesheet" href="http://echoblog.cc/css/style.min.eac77496566fd7d5768fd650ddb0b2b181ca6a2d7c5fdd6fe6b8ba4bf47e566f.css" integrity="sha256-6sd0llZv19V2j9ZQ3bCysYHKai18X91v5ri6S/R+Vm8=" crossorigin="anonymous">
	
</head>

<body id="page">
	
	<header id="site-header" class="animated slideInUp">
		<div class="hdr-wrapper section-inner">
			<div class="hdr-left">
				<div class="site-branding">
					<a href="http://echoblog.cc/">_Echo_</a>
				</div>
				<nav class="site-nav hide-in-mobile">
					
				<a href="http://echoblog.cc/posts/">Posts</a>
				<a href="http://echoblog.cc/about/">About</a>

				</nav>
			</div>
			<div class="hdr-right hdr-icons">
				<span class="hdr-social hide-in-mobile"><a href="https://blog.csdn.net/qq_37005831?spm=1000.2115.3001.5343" target="_blank" rel="noopener me" title="Csdn"><svg xmlns="http://www.w3.org/2000/svg" class="feather feather-link" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a><a href="https://github.com/E-c-h-o-Go" target="_blank" rel="noopener me" title="Github"><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path></svg></a></span><button id="menu-btn" class="hdr-btn" title=""><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></button>
			</div>
		</div>
	</header>
	<div id="mobile-menu" class="animated fast">
		<ul>
			<li><a href="http://echoblog.cc/posts/">Posts</a></li>
			<li><a href="http://echoblog.cc/about/">About</a></li>
		</ul>
	</div>


	<main class="site-main section-inner animated fadeIn faster">
		<article class="thin">
			<header class="post-header">
				<div class="post-meta"><span>Jan 4, 2021</span></div>
				<h1>「Golang」Slice源码讲解</h1>
			</header>
			<div class="content">
				<h2 id="前言">前言<a href="#前言" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<blockquote>
<p>​        在golang中有很多的数据结构是很常用的数据结构，比如array，slice，map等，其中最为常用的就是array和slice还有map了，理论上来讲array和slice在数据结构上是一种结构，都是顺序结构，但是由于array的固定长度特性，在有些时候对于需要动态的长度的使用情况很不友好，此时就需要利用slice进行对固定长度数组的代替</p>
</blockquote>
<h2 id="什么是slice">什么是Slice<a href="#什么是slice" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<blockquote>
<p>官方解释如下：</p>
<p>​		Slices wrap arrays to give a more general, powerful, and convenient interface to sequences of data. Except for items with explicit dimension such as transformation matrices, most array programming in Go is done with slices rather than simple arrays.</p>
<p>大概意思如下：</p>
<p>​		Slice是一个经过包装的array，其可为数据序列提供更通用，更强大和更方便的接口。 除了具有明确维数的项（例如转换矩阵）外，Go中的大多数数组编程都是使用切片而不是简单数组完成的。</p>
</blockquote>
<p>​		切片个人认为有点像c++标准库中的vector，只不过是底层的实现方式可能有些许不同（不太了解c++，如果有大佬知道vector的底层实现的话，可以解惑一下），slice是一个把go数组进行了包装的一个结构体，但是这个结构体只是在编译等其他层面能看到，在我们使用过程中只需要像定义数组那样定义就可以在编译期间被转换为slice结构体。接下来我来解析一下slice的相关结构体源代码以及操作源代码。</p>
<h2 id="代码解析">代码解析<a href="#代码解析" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<blockquote>
<p>本篇文章所有代码基于Go1.15+版本编写</p>
</blockquote>
<h3 id="slice的结构体">slice的结构体<a href="#slice的结构体" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// slice 结构体，这个结构体会在编译期间构建
</span><span class="c1">// 如果想在运行期间使用的话可以使用其对应的reflect结构体
</span><span class="c1">// 即reflect.SliceHeader
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">slice</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// 一个指向底层数组的指针
</span><span class="c1"></span>	<span class="nx">array</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
	<span class="c1">// slice当前元素个数 即len()时返回的数
</span><span class="c1"></span>	<span class="nx">len</span>   <span class="kt">int</span>
	<span class="c1">// slice的容量 即cap()时返回的数
</span><span class="c1"></span>	<span class="nx">cap</span>   <span class="kt">int</span>
<span class="p">}</span>
</code></pre></div><h3 id="slice的初始化">slice的初始化<a href="#slice的初始化" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>slice的初始化方式分为三种：</p>
<ol>
<li>
<p>下标初始化方式：<code>a:=slice[:] // 这个slice是一个其他以创建好的slice</code>。这种创建方式时最接近底层的创建方式，在编译期间该语句会被转换为编译器的<code>OpSliceMake</code>操作,该操作会调用<code>SliceMake</code>操作，<code>SliceMake</code>操作会接受四个参数创建新的切片，元素类型、数组指针、切片大小和容量，这与上一章所展示的slice的结构体的字段构成相同，<strong>另外下标初始化方式不会对原数组中的数据进行复制，而是直接引用指向原数组的指针，这会导致在修改切片<code>a</code>时，对原切片<code>slice</code>也会产生影响。</strong></p>
</li>
<li>
<p>字面量初始化方式:```a:=[]int{1,2,3}``，过程如下</p>
<ol>
<li>该方法在编译期间创建首先会生成一个长度为3（该长度根据字面量数量自动推断）的数组</li>
<li>给这个数组的元素进行赋值</li>
<li>而后会new出一个新的长度为3（该长度根据字面量数量</li>
<li>自动推断）的数组的指针</li>
<li>将这个指针按照最基本的下标初始化方式进行赋值给slice</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">arr</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">int</span>
<span class="nx">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1</span>
<span class="nx">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="mi">2</span>
<span class="nx">arr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="p">=</span> <span class="mi">3</span>
<span class="kd">var</span> <span class="nx">arrp</span> <span class="o">*</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">int</span> <span class="p">=</span> <span class="nb">new</span><span class="p">([</span><span class="mi">3</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>
<span class="o">*</span><span class="nx">arrp</span> <span class="p">=</span> <span class="nx">arr</span>
<span class="nx">slice</span> <span class="o">:=</span> <span class="nx">arrp</span><span class="p">[:]</span>
</code></pre></div></li>
<li>
<p>通过关键字<code>make([]int,3,3)</code>创建切片：通过<code>make</code>关键字进行切片初始化，首先会在编译阶段对其传入的len与cap进行校验，校验其是否为负值，是否<code>len</code>&gt;<code>cap</code>，并且通过判断切片的大小以及是否逃逸来确定其是否会初始化在堆上，如果当切片足够小并且没有发生逃逸时，会创建一个<code>cap</code>值的数组，然后像字面量初始化方式一样对其进行初始化，如果<code>cap</code>为0，则按照<code>len</code>的值创建对应长度的数组。如果发生逃逸或者切片过大时，会调用<code>runtime.makeslice()</code>函数进行堆上的切片内存分配。<code>runtime.makeslice</code>代码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 该函数传入需要初始化的切片的类型，长度以及容量，返回的指针会通过调用方组建成一个完成的slice结构体
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">makeslice</span><span class="p">(</span><span class="nx">et</span> <span class="o">*</span><span class="nx">_type</span><span class="p">,</span> <span class="nx">len</span><span class="p">,</span> <span class="nx">cap</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="p">{</span>
  <span class="c1">// 判断类型，和容量的乘积会不会超过可分配内存的大小，以及长度是否为0和容量是否小于长度
</span><span class="c1"></span> <span class="nx">mem</span><span class="p">,</span> <span class="nx">overflow</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nf">MulUintptr</span><span class="p">(</span><span class="nx">et</span><span class="p">.</span><span class="nx">size</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">cap</span><span class="p">))</span>
 <span class="k">if</span> <span class="nx">overflow</span> <span class="o">||</span> <span class="nx">mem</span> <span class="p">&gt;</span> <span class="nx">maxAlloc</span> <span class="o">||</span> <span class="nx">len</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">len</span> <span class="p">&gt;</span> <span class="nx">cap</span> <span class="p">{</span>
     <span class="nx">mem</span><span class="p">,</span> <span class="nx">overflow</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nf">MulUintptr</span><span class="p">(</span><span class="nx">et</span><span class="p">.</span><span class="nx">size</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">len</span><span class="p">))</span>
     <span class="k">if</span> <span class="nx">overflow</span> <span class="o">||</span> <span class="nx">mem</span> <span class="p">&gt;</span> <span class="nx">maxAlloc</span> <span class="o">||</span> <span class="nx">len</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
         <span class="nf">panicmakeslicelen</span><span class="p">()</span>
     <span class="p">}</span>
     <span class="nf">panicmakeslicecap</span><span class="p">()</span>
 <span class="p">}</span>
 <span class="c1">// 如果都正常，则调用此函数申请返回一个连续 切片中元素大小×切片容量 长度的内存空间的指针
</span><span class="c1"></span> <span class="k">return</span> <span class="nf">mallocgc</span><span class="p">(</span><span class="nx">mem</span><span class="p">,</span> <span class="nx">et</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></li>
</ol>
<h3 id="访问元素">访问元素<a href="#访问元素" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>slice的访问元素是通过slice结构体中
$$
对应索引的元素地址=指向底层数组的指针+对应元素的占用字节数*索引
$$
编译器会通过对应索引的元素地址返回其中对应的值，即直接进行地址访问</p>
<h3 id="追加和扩容">追加和扩容<a href="#追加和扩容" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>​		slice相比于array的一大优点就是可以根据使用情况动态的进行扩容，来适应随时增加的数据，在追加时，通过调用<code>append</code>函数来针对slice进行尾部追加，如果此时slice的<code>cap</code>值小于当前<code>len</code>加上<code>append</code>中传入值的数量，那么就会出发扩容操作，<code>append</code>函数没有明确的函数体，而是通过编译期间被转换。当<code>append</code>发现需要扩容时，则会调用<code>runtime.growslice</code>方法，该方法源代码如下（以去除一些无用代码）：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">growslice</span><span class="p">(</span><span class="nx">et</span> <span class="o">*</span><span class="nx">_type</span><span class="p">,</span> <span class="nx">old</span> <span class="nx">slice</span><span class="p">,</span> <span class="nx">cap</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">slice</span> <span class="p">{</span>
	<span class="c1">// 如果需求的容量小于就容量则报错
</span><span class="c1"></span>  <span class="c1">// 理论上来讲不应该出现这个问题
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">cap</span> <span class="p">&lt;</span> <span class="nx">old</span><span class="p">.</span><span class="nx">cap</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nf">errorString</span><span class="p">(</span><span class="s">&#34;growslice: cap out of range&#34;</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="c1">// append 没法创建一个nil指针的但是len不为0的切片
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">et</span><span class="p">.</span><span class="nx">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">slice</span><span class="p">{</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">zerobase</span><span class="p">),</span> <span class="nx">old</span><span class="p">.</span><span class="nx">len</span><span class="p">,</span> <span class="nx">cap</span><span class="p">}</span>
	<span class="p">}</span>
	
	<span class="nx">newcap</span> <span class="o">:=</span> <span class="nx">old</span><span class="p">.</span><span class="nx">cap</span>
	<span class="nx">doublecap</span> <span class="o">:=</span> <span class="nx">newcap</span> <span class="o">+</span> <span class="nx">newcap</span>
  <span class="c1">// 如果需求容量大于双倍的旧容量那就直接使用需求容量
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">cap</span> <span class="p">&gt;</span> <span class="nx">doublecap</span> <span class="p">{</span>
		<span class="nx">newcap</span> <span class="p">=</span> <span class="nx">cap</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// 如果当前len小于1024则容量直接翻倍，否则按照1.25倍去递增直到满足需求容量
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">old</span><span class="p">.</span><span class="nx">len</span> <span class="p">&lt;</span> <span class="mi">1024</span> <span class="p">{</span>
			<span class="nx">newcap</span> <span class="p">=</span> <span class="nx">doublecap</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">for</span> <span class="mi">0</span> <span class="p">&lt;</span> <span class="nx">newcap</span> <span class="o">&amp;&amp;</span> <span class="nx">newcap</span> <span class="p">&lt;</span> <span class="nx">cap</span> <span class="p">{</span>
				<span class="nx">newcap</span> <span class="o">+=</span> <span class="nx">newcap</span> <span class="o">/</span> <span class="mi">4</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">newcap</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">newcap</span> <span class="p">=</span> <span class="nx">cap</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="kd">var</span> <span class="nx">overflow</span> <span class="kt">bool</span>
	<span class="kd">var</span> <span class="nx">lenmem</span><span class="p">,</span> <span class="nx">newlenmem</span><span class="p">,</span> <span class="nx">capmem</span> <span class="kt">uintptr</span>
<span class="c1">// 在扩容时不能单单按照len来判断扩容所需要的内存长度
</span><span class="c1">// 还要根据切片的元素类型去进行内存对齐
</span><span class="c1">// 当元素的占用字节数为1，8 或者2的倍数时会进行内存对对齐
</span><span class="c1">// 内存对齐策略按照向上取整方式进行
</span><span class="c1">// 取整的目标时go内存分配策略中67个class分页中的大小进行取整
</span><span class="c1"></span>	<span class="k">switch</span> <span class="p">{</span>
	<span class="k">case</span> <span class="nx">et</span><span class="p">.</span><span class="nx">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
		<span class="nx">lenmem</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">old</span><span class="p">.</span><span class="nx">len</span><span class="p">)</span>
		<span class="nx">newlenmem</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">cap</span><span class="p">)</span>
		<span class="nx">capmem</span> <span class="p">=</span> <span class="nf">roundupsize</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">newcap</span><span class="p">))</span>
		<span class="nx">overflow</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">newcap</span><span class="p">)</span> <span class="p">&gt;</span> <span class="nx">maxAlloc</span>
		<span class="nx">newcap</span> <span class="p">=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">capmem</span><span class="p">)</span>
	<span class="k">case</span> <span class="nx">et</span><span class="p">.</span><span class="nx">size</span> <span class="o">==</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">:</span>
		<span class="nx">lenmem</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">old</span><span class="p">.</span><span class="nx">len</span><span class="p">)</span> <span class="o">*</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span>
		<span class="nx">newlenmem</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">cap</span><span class="p">)</span> <span class="o">*</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span>
		<span class="nx">capmem</span> <span class="p">=</span> <span class="nf">roundupsize</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">newcap</span><span class="p">)</span> <span class="o">*</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">)</span>
		<span class="nx">overflow</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">newcap</span><span class="p">)</span> <span class="p">&gt;</span> <span class="nx">maxAlloc</span><span class="o">/</span><span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span>
		<span class="nx">newcap</span> <span class="p">=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">capmem</span> <span class="o">/</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">)</span>
	<span class="k">case</span> <span class="nf">isPowerOfTwo</span><span class="p">(</span><span class="nx">et</span><span class="p">.</span><span class="nx">size</span><span class="p">):</span>
		<span class="kd">var</span> <span class="nx">shift</span> <span class="kt">uintptr</span>
		<span class="k">if</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span> <span class="o">==</span> <span class="mi">8</span> <span class="p">{</span>
			<span class="c1">// Mask shift for better code generation.
</span><span class="c1"></span>			<span class="nx">shift</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">sys</span><span class="p">.</span><span class="nf">Ctz64</span><span class="p">(</span><span class="nb">uint64</span><span class="p">(</span><span class="nx">et</span><span class="p">.</span><span class="nx">size</span><span class="p">)))</span> <span class="o">&amp;</span> <span class="mi">63</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">shift</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">sys</span><span class="p">.</span><span class="nf">Ctz32</span><span class="p">(</span><span class="nb">uint32</span><span class="p">(</span><span class="nx">et</span><span class="p">.</span><span class="nx">size</span><span class="p">)))</span> <span class="o">&amp;</span> <span class="mi">31</span>
		<span class="p">}</span>
		<span class="nx">lenmem</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">old</span><span class="p">.</span><span class="nx">len</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="nx">shift</span>
		<span class="nx">newlenmem</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">cap</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="nx">shift</span>
		<span class="nx">capmem</span> <span class="p">=</span> <span class="nf">roundupsize</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">newcap</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="nx">shift</span><span class="p">)</span>
		<span class="nx">overflow</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">newcap</span><span class="p">)</span> <span class="p">&gt;</span> <span class="p">(</span><span class="nx">maxAlloc</span> <span class="o">&gt;&gt;</span> <span class="nx">shift</span><span class="p">)</span>
		<span class="nx">newcap</span> <span class="p">=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">capmem</span> <span class="o">&gt;&gt;</span> <span class="nx">shift</span><span class="p">)</span>
	<span class="k">default</span><span class="p">:</span>
		<span class="nx">lenmem</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">old</span><span class="p">.</span><span class="nx">len</span><span class="p">)</span> <span class="o">*</span> <span class="nx">et</span><span class="p">.</span><span class="nx">size</span>
		<span class="nx">newlenmem</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">cap</span><span class="p">)</span> <span class="o">*</span> <span class="nx">et</span><span class="p">.</span><span class="nx">size</span>
		<span class="nx">capmem</span><span class="p">,</span> <span class="nx">overflow</span> <span class="p">=</span> <span class="nx">math</span><span class="p">.</span><span class="nf">MulUintptr</span><span class="p">(</span><span class="nx">et</span><span class="p">.</span><span class="nx">size</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">newcap</span><span class="p">))</span>
		<span class="nx">capmem</span> <span class="p">=</span> <span class="nf">roundupsize</span><span class="p">(</span><span class="nx">capmem</span><span class="p">)</span>
		<span class="nx">newcap</span> <span class="p">=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">capmem</span> <span class="o">/</span> <span class="nx">et</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span>
	<span class="p">}</span>

<span class="c1">// 如果所需要的内存超过了最大可分配内存则panic
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">overflow</span> <span class="o">||</span> <span class="nx">capmem</span> <span class="p">&gt;</span> <span class="nx">maxAlloc</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nf">errorString</span><span class="p">(</span><span class="s">&#34;growslice: cap out of range&#34;</span><span class="p">))</span>
	<span class="p">}</span>

	<span class="kd">var</span> <span class="nx">p</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
  <span class="c1">// 如果当前元素类型不是指针，则会将超出切片当前长度的位置清空
</span><span class="c1"></span>  <span class="c1">// 并在最后使用 将原数组内存中的内容拷贝到新申请的内存中。
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">et</span><span class="p">.</span><span class="nx">ptrdata</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">p</span> <span class="p">=</span> <span class="nf">mallocgc</span><span class="p">(</span><span class="nx">capmem</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
		<span class="nf">memclrNoHeapPointers</span><span class="p">(</span><span class="nf">add</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">newlenmem</span><span class="p">),</span> <span class="nx">capmem</span><span class="o">-</span><span class="nx">newlenmem</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// 如果是指针会根据进行gc方面对其进行加以保护以免空指针在分配期间被gc回收
</span><span class="c1"></span>		<span class="nx">p</span> <span class="p">=</span> <span class="nf">mallocgc</span><span class="p">(</span><span class="nx">capmem</span><span class="p">,</span> <span class="nx">et</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">lenmem</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">writeBarrier</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
			<span class="nf">bulkBarrierPreWriteSrcOnly</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">p</span><span class="p">),</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">old</span><span class="p">.</span><span class="nx">array</span><span class="p">),</span> <span class="nx">lenmem</span><span class="o">-</span><span class="nx">et</span><span class="p">.</span><span class="nx">size</span><span class="o">+</span><span class="nx">et</span><span class="p">.</span><span class="nx">ptrdata</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nf">memmove</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">old</span><span class="p">.</span><span class="nx">array</span><span class="p">,</span> <span class="nx">lenmem</span><span class="p">)</span>
	<span class="c1">//该函数最终会返回一个新的切片
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">slice</span><span class="p">{</span><span class="nx">p</span><span class="p">,</span> <span class="nx">old</span><span class="p">.</span><span class="nx">len</span><span class="p">,</span> <span class="nx">newcap</span><span class="p">}</span>
<span class="p">}</span>

</code></pre></div><h3 id="slice的拷贝">slice的拷贝<a href="#slice的拷贝" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>slice的拷贝也是针对切片提供的接口，可以通过调用<code>copy()</code>函数将src切片中的值拷贝到dst切片中，通过该函数进行的切片拷贝后，针对dst切片进行的操作不会对src产生任何的影响，其拷贝长度是按照src与dst切片中最小的len长度去计算的，<code>runtime.slicecopy</code>源代码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">slicecopy</span><span class="p">(</span><span class="nx">toPtr</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">toLen</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">fmPtr</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">fmLen</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">width</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">fmLen</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">toLen</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span>
	<span class="p">}</span>

	<span class="nx">n</span> <span class="o">:=</span> <span class="nx">fmLen</span>
	<span class="k">if</span> <span class="nx">toLen</span> <span class="p">&lt;</span> <span class="nx">n</span> <span class="p">{</span>
		<span class="nx">n</span> <span class="p">=</span> <span class="nx">toLen</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">width</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">n</span>
	<span class="p">}</span>
	
	<span class="nx">size</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="o">*</span> <span class="nx">width</span>
	<span class="k">if</span> <span class="nx">size</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>  
    <span class="c1">// 如果就1个元素 直接赋值过去就好了
</span><span class="c1"></span>		<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">byte</span><span class="p">)(</span><span class="nx">toPtr</span><span class="p">)</span> <span class="p">=</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">byte</span><span class="p">)(</span><span class="nx">fmPtr</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// 直接进行内存的拷贝，如果slice数据量过大将会影响性能
</span><span class="c1"></span>		<span class="nf">memmove</span><span class="p">(</span><span class="nx">toPtr</span><span class="p">,</span> <span class="nx">fmPtr</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">n</span>
<span class="p">}</span>
</code></pre></div><h2 id="总结">总结<a href="#总结" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>至此slice的源码解析就解析完了，可能有些地方有些理解上的错误，请各位谅解并且帮忙指出修改意见，如果这篇文章能帮到你，这是我的荣幸。</p>

			</div>
			<hr class="post-end">
			<footer class="post-info">
				<p>
					<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line></svg><span class="tag"><a href="http://echoblog.cc/tags/golang">Golang</a></span>
				</p>
				<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg></p>
				<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>2021-01-04 08:00 &#43;0800</p>
			</footer>
		</article>
		<div class="post-nav thin">
			<a class="next-post" href="http://echoblog.cc/posts/golang%E5%B9%B6%E5%8F%91%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84map%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%E5%8F%8A%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97/">
				<span class="post-nav-label"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left"><line x1="19" y1="12" x2="5" y2="12"></line><polyline points="12 19 5 12 12 5"></polyline></svg>&nbsp;</span><br><span>「Golang」 sync.Mutex源码讲解</span>
			</a>
			<a class="prev-post" href="http://echoblog.cc/posts/golangsync.once%E7%94%A8%E6%B3%95%E4%BB%A5%E5%8F%8A%E6%BA%90%E7%A0%81%E8%AE%B2%E8%A7%A3/">
				<span class="post-nav-label">&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg></span><br><span>「Golang」sync.Once用法以及源码讲解</span>
			</a>
		</div>
		<div id="comments" class="thin">
</div>
		<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
		<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
		<div id="gitalk-container"></div>
		<script src="https://cdn.bootcss.com/js-sha1/0.6.0/sha1.js"></script>
		<script>
			const gitalk = new Gitalk({
				clientID: '995328ca3d420ab499bc',
				clientSecret: '7efc85b29c231f5ec361d9f5b44c3802cc17cb58',
				repo: 'Echo.github.io',
				owner: 'E-c-h-o-Go',
				admin: ['E-c-h-o-Go'],
				id: sha1(location.pathname),      
				distractionFreeMode: false  
			})

			gitalk.render('gitalk-container')

		</script>
	</main>


	<footer id="site-footer" class="section-inner thin animated fadeIn faster">
		<p>&copy; 2021 <a href="http://echoblog.cc/">_Echo_</a> &#183; <a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0</a></p>
		<p>
			Made with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> &#183; Theme <a href="https://github.com/Track3/hermit" target="_blank" rel="noopener">Hermit</a> &#183; <a href="http://echoblog.cc/posts/index.xml" target="_blank" title="rss"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a>
		</p>
	</footer>



	<script src="http://echoblog.cc/js/bundle.min.4a9a0ac3d2217822c7865b4161e6c2a71de1d70492264337755427898dd718f6.js" integrity="sha256-SpoKw9IheCLHhltBYebCpx3h1wSSJkM3dVQniY3XGPY=" crossorigin="anonymous"></script>
	

</body>

</html>
